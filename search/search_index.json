{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Valkey GLIDE","text":"<p>Valkey General Language Independent Driver for the Enterprise (GLIDE), is an open-source Valkey client library. Valkey GLIDE is one of the official client libraries for Valkey, and it supports all Valkey commands. Valkey GLIDE supports Valkey 7.2 and above, and Redis open-source 6.2, 7.0 and 7.2. Application programmers use Valkey GLIDE to safely and reliably connect their applications to Valkey- and Redis OSS- compatible services. Valkey GLIDE is designed for reliability, optimized performance, and high-availability, for Valkey and Redis OSS based applications. It is sponsored and supported by AWS, and is pre-configured with best practices learned from over a decade of operating Redis OSS-compatible services used by hundreds of thousands of customers. To help ensure consistency in application development and operations, Valkey GLIDE is implemented using a core driver framework, written in Rust, with language specific extensions. This design ensures consistency in features across languages and reduces overall complexity.</p>"},{"location":"#supported-engine-versions","title":"Supported Engine Versions","text":"<p>Refer to the Supported Engine Versions table for details.</p>"},{"location":"#getting-started-python-wrapper","title":"Getting Started - Python Wrapper","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<p>The release of Valkey GLIDE was tested on the following platforms:</p> <p>Linux:</p> <ul> <li>Ubuntu 22.04.1 (x86_64 and aarch64)</li> <li>Amazon Linux 2023 (AL2023) (x86_64)</li> </ul> <p>macOS:</p> <ul> <li>macOS 14.7 (Apple silicon/aarch_64)</li> </ul>"},{"location":"#python-supported-versions","title":"Python Supported Versions","text":"Python Version 3.9 3.10 3.11 3.12 3.13"},{"location":"#installation-and-setup","title":"Installation and Setup","text":""},{"location":"#installing-via-package-manager-pip","title":"Installing via Package Manager (pip)","text":"<p>To install Valkey GLIDE using <code>pip</code>, follow these steps:</p> <ol> <li>Open your terminal.</li> <li>Execute the command below:     <pre><code>$ pip install valkey-glide\n</code></pre></li> <li>After installation, confirm the client is accessible by running:     <pre><code>$ python3\n&gt;&gt;&gt; import glide\n</code></pre></li> </ol>"},{"location":"#basic-examples","title":"Basic Examples","text":""},{"location":"#cluster-mode","title":"Cluster Mode:","text":"<pre><code>import asyncio\nfrom glide import GlideClusterClientConfiguration, NodeAddress, GlideClusterClient\nasync def test_cluster_client():\n    addresses = [NodeAddress(\"address.example.com\", 6379)]\n    config = GlideClusterClientConfiguration(addresses)\n    client = await GlideClusterClient.create(config)\n    set_result = await client.set(\"foo\", \"bar\")\n    print(f\"Set response is {set_result}\")\n    get_result = await client.get(\"foo\")\n    print(f\"Get response is {get_result}\")\n\nasyncio.run(test_cluster_client())\n</code></pre> <p>Output:</p> <pre><code>Set response is OK\nGet response is bar\n</code></pre>"},{"location":"#standalone-mode","title":"Standalone Mode:","text":"<pre><code>import asyncio\nfrom glide import GlideClientConfiguration, NodeAddress, GlideClient\nasync def test_standalone_client():\n    addresses = [\n            NodeAddress(\"server_primary.example.com\", 6379),\n            NodeAddress(\"server_replica.example.com\", 6379)\n    ]\n    config = GlideClientConfiguration(addresses)\n    client = await GlideClient.create(config)\n    set_result = await client.set(\"foo\", \"bar\")\n    print(f\"Set response is {set_result}\")\n    get_result = await client.get(\"foo\")\n    print(f\"Get response is {get_result}\")\n\nasyncio.run(test_standalone_client())\n</code></pre> <p>Output:</p> <pre><code>Set response is OK\nGet response is bar\n</code></pre> <p>For complete examples with error handling, please refer to the cluster example and the standalone example.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Visit our wiki for examples and further details on TLS, Read strategy, Timeouts and various other configurations.</p>"},{"location":"#building-testing","title":"Building &amp; Testing","text":"<p>Development instructions for local building &amp; testing the package are in the DEVELOPER.md file.</p>"},{"location":"python/base_client/","title":"Base","text":"<p>               Bases: <code>CoreCommands</code></p> Source code in <code>glide/glide_client.py</code> <pre><code>class BaseClient(CoreCommands):\n    def __init__(self, config: BaseClientConfiguration):\n        \"\"\"\n        To create a new client, use the `create` classmethod\n        \"\"\"\n        self.config: BaseClientConfiguration = config\n        self._available_futures: Dict[int, asyncio.Future] = {}\n        self._available_callback_indexes: List[int] = list()\n        self._buffered_requests: List[TRequest] = list()\n        self._writer_lock = threading.Lock()\n        self.socket_path: Optional[str] = None\n        self._reader_task: Optional[asyncio.Task] = None\n        self._is_closed: bool = False\n        self._pubsub_futures: List[asyncio.Future] = []\n        self._pubsub_lock = threading.Lock()\n        self._pending_push_notifications: List[Response] = list()\n\n    @classmethod\n    async def create(cls, config: BaseClientConfiguration) -&gt; Self:\n        \"\"\"Creates a Glide client.\n\n        Args:\n            config (ClientConfiguration): The client configurations.\n                If no configuration is provided, a default client to \"localhost\":6379 will be created.\n\n        Returns:\n            Self: a Glide Client instance.\n        \"\"\"\n        config = config\n        self = cls(config)\n        init_future: asyncio.Future = asyncio.Future()\n        loop = asyncio.get_event_loop()\n\n        def init_callback(socket_path: Optional[str], err: Optional[str]):\n            if err is not None:\n                raise ClosingError(err)\n            elif socket_path is None:\n                raise ClosingError(\n                    \"Socket initialization error: Missing valid socket path.\"\n                )\n            else:\n                # Received socket path\n                self.socket_path = socket_path\n                loop.call_soon_threadsafe(init_future.set_result, True)\n\n        start_socket_listener_external(init_callback=init_callback)\n\n        # will log if the logger was created (wrapper or costumer) on info\n        # level or higher\n        ClientLogger.log(LogLevel.INFO, \"connection info\", \"new connection established\")\n        # Wait for the socket listener to complete its initialization\n        await init_future\n        # Create UDS connection\n        await self._create_uds_connection()\n        # Start the reader loop as a background task\n        self._reader_task = asyncio.create_task(self._reader_loop())\n        # Set the client configurations\n        await self._set_connection_configurations()\n        return self\n\n    async def _create_uds_connection(self) -&gt; None:\n        try:\n            # Open an UDS connection\n            async with async_timeout.timeout(DEFAULT_TIMEOUT_IN_MILLISECONDS):\n                reader, writer = await asyncio.open_unix_connection(\n                    path=self.socket_path\n                )\n            self._reader = reader\n            self._writer = writer\n        except Exception as e:\n            await self.close(f\"Failed to create UDS connection: {e}\")\n            raise\n\n    def __del__(self) -&gt; None:\n        try:\n            if self._reader_task:\n                self._reader_task.cancel()\n        except RuntimeError as e:\n            if \"no running event loop\" in str(e):\n                # event loop already closed\n                pass\n\n    async def close(self, err_message: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Terminate the client by closing all associated resources, including the socket and any active futures.\n        All open futures will be closed with an exception.\n\n        Args:\n            err_message (Optional[str]): If not None, this error message will be passed along with the exceptions when closing all open futures.\n            Defaults to None.\n        \"\"\"\n        self._is_closed = True\n        for response_future in self._available_futures.values():\n            if not response_future.done():\n                err_message = \"\" if err_message is None else err_message\n                response_future.set_exception(ClosingError(err_message))\n        try:\n            self._pubsub_lock.acquire()\n            for pubsub_future in self._pubsub_futures:\n                if not pubsub_future.done() and not pubsub_future.cancelled():\n                    pubsub_future.set_exception(ClosingError(\"\"))\n        finally:\n            self._pubsub_lock.release()\n\n        self._writer.close()\n        await self._writer.wait_closed()\n        self.__del__()\n\n    def _get_future(self, callback_idx: int) -&gt; asyncio.Future:\n        response_future: asyncio.Future = asyncio.Future()\n        self._available_futures.update({callback_idx: response_future})\n        return response_future\n\n    def _get_protobuf_conn_request(self) -&gt; ConnectionRequest:\n        return self.config._create_a_protobuf_conn_request()\n\n    async def _set_connection_configurations(self) -&gt; None:\n        conn_request = self._get_protobuf_conn_request()\n        response_future: asyncio.Future = self._get_future(0)\n        await self._write_or_buffer_request(conn_request)\n        await response_future\n        if response_future.result() is not OK:\n            raise ClosingError(response_future.result())\n\n    def _create_write_task(self, request: TRequest):\n        asyncio.create_task(self._write_or_buffer_request(request))\n\n    async def _write_or_buffer_request(self, request: TRequest):\n        self._buffered_requests.append(request)\n        if self._writer_lock.acquire(False):\n            try:\n                while len(self._buffered_requests) &gt; 0:\n                    await self._write_buffered_requests_to_socket()\n\n            finally:\n                self._writer_lock.release()\n\n    async def _write_buffered_requests_to_socket(self) -&gt; None:\n        requests = self._buffered_requests\n        self._buffered_requests = list()\n        b_arr = bytearray()\n        for request in requests:\n            ProtobufCodec.encode_delimited(b_arr, request)\n        self._writer.write(b_arr)\n        await self._writer.drain()\n\n    def _encode_arg(self, arg: TEncodable) -&gt; bytes:\n        \"\"\"\n        Converts a string argument to bytes.\n\n        Args:\n            arg (str): An encodable argument.\n\n        Returns:\n            bytes: The encoded argument as bytes.\n        \"\"\"\n        if isinstance(arg, str):\n            # TODO: Allow passing different encoding options\n            return bytes(arg, encoding=\"utf8\")\n        return arg\n\n    def _encode_and_sum_size(\n        self,\n        args_list: Optional[List[TEncodable]],\n    ) -&gt; Tuple[List[bytes], int]:\n        \"\"\"\n        Encodes the list and calculates the total memory size.\n\n        Args:\n            args_list (Optional[List[TEncodable]]): A list of strings to be converted to bytes.\n                                                           If None or empty, returns ([], 0).\n\n        Returns:\n            int: The total memory size of the encoded arguments in bytes.\n        \"\"\"\n        args_size = 0\n        encoded_args_list: List[bytes] = []\n        if not args_list:\n            return (encoded_args_list, args_size)\n        for arg in args_list:\n            encoded_arg = self._encode_arg(arg) if isinstance(arg, str) else arg\n            encoded_args_list.append(encoded_arg)\n            args_size += sys.getsizeof(encoded_arg)\n        return (encoded_args_list, args_size)\n\n    async def _execute_command(\n        self,\n        request_type: RequestType.ValueType,\n        args: List[TEncodable],\n        route: Optional[Route] = None,\n    ) -&gt; TResult:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n        request = CommandRequest()\n        request.callback_idx = self._get_callback_index()\n        request.single_command.request_type = request_type\n        request.single_command.args_array.args[:] = [\n            bytes(elem, encoding=\"utf8\") if isinstance(elem, str) else elem\n            for elem in args\n        ]\n        (encoded_args, args_size) = self._encode_and_sum_size(args)\n        if args_size &lt; MAX_REQUEST_ARGS_LEN:\n            request.single_command.args_array.args[:] = encoded_args\n        else:\n            request.single_command.args_vec_pointer = create_leaked_bytes_vec(\n                encoded_args\n            )\n        set_protobuf_route(request, route)\n        return await self._write_request_await_response(request)\n\n    async def _execute_transaction(\n        self,\n        commands: List[Tuple[RequestType.ValueType, List[TEncodable]]],\n        route: Optional[Route] = None,\n    ) -&gt; List[TResult]:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n        request = CommandRequest()\n        request.callback_idx = self._get_callback_index()\n        transaction_commands = []\n        for requst_type, args in commands:\n            command = Command()\n            command.request_type = requst_type\n            # For now, we allow the user to pass the command as array of strings\n            # we convert them here into bytes (the datatype that our rust core expects)\n            (encoded_args, args_size) = self._encode_and_sum_size(args)\n            if args_size &lt; MAX_REQUEST_ARGS_LEN:\n                command.args_array.args[:] = encoded_args\n            else:\n                command.args_vec_pointer = create_leaked_bytes_vec(encoded_args)\n            transaction_commands.append(command)\n        request.transaction.commands.extend(transaction_commands)\n        set_protobuf_route(request, route)\n        return await self._write_request_await_response(request)\n\n    async def _execute_script(\n        self,\n        hash: str,\n        keys: Optional[List[Union[str, bytes]]] = None,\n        args: Optional[List[Union[str, bytes]]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TResult:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n        request = CommandRequest()\n        request.callback_idx = self._get_callback_index()\n        (encoded_keys, keys_size) = self._encode_and_sum_size(keys)\n        (encoded_args, args_size) = self._encode_and_sum_size(args)\n        if (keys_size + args_size) &lt; MAX_REQUEST_ARGS_LEN:\n            request.script_invocation.hash = hash\n            request.script_invocation.keys[:] = encoded_keys\n            request.script_invocation.args[:] = encoded_args\n\n        else:\n            request.script_invocation_pointers.hash = hash\n            request.script_invocation_pointers.keys_pointer = create_leaked_bytes_vec(\n                encoded_keys\n            )\n            request.script_invocation_pointers.args_pointer = create_leaked_bytes_vec(\n                encoded_args\n            )\n        set_protobuf_route(request, route)\n        return await self._write_request_await_response(request)\n\n    async def get_pubsub_message(self) -&gt; CoreCommands.PubSubMsg:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n\n        if not self.config._is_pubsub_configured():\n            raise ConfigurationError(\n                \"The operation will never complete since there was no pubsub subscriptions applied to the client.\"\n            )\n\n        if self.config._get_pubsub_callback_and_context()[0] is not None:\n            raise ConfigurationError(\n                \"The operation will never complete since messages will be passed to the configured callback.\"\n            )\n\n        # locking might not be required\n        response_future: asyncio.Future = asyncio.Future()\n        try:\n            self._pubsub_lock.acquire()\n            self._pubsub_futures.append(response_future)\n            self._complete_pubsub_futures_safe()\n        finally:\n            self._pubsub_lock.release()\n        return await response_future\n\n    def try_get_pubsub_message(self) -&gt; Optional[CoreCommands.PubSubMsg]:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n\n        if not self.config._is_pubsub_configured():\n            raise ConfigurationError(\n                \"The operation will never succeed since there was no pubsbub subscriptions applied to the client.\"\n            )\n\n        if self.config._get_pubsub_callback_and_context()[0] is not None:\n            raise ConfigurationError(\n                \"The operation will never succeed since messages will be passed to the configured callback.\"\n            )\n\n        # locking might not be required\n        msg: Optional[CoreCommands.PubSubMsg] = None\n        try:\n            self._pubsub_lock.acquire()\n            self._complete_pubsub_futures_safe()\n            while len(self._pending_push_notifications) and not msg:\n                push_notification = self._pending_push_notifications.pop(0)\n                msg = self._notification_to_pubsub_message_safe(push_notification)\n        finally:\n            self._pubsub_lock.release()\n        return msg\n\n    def _cancel_pubsub_futures_with_exception_safe(self, exception: ConnectionError):\n        while len(self._pubsub_futures):\n            next_future = self._pubsub_futures.pop(0)\n            if not next_future.cancelled():\n                next_future.set_exception(exception)\n\n    def _notification_to_pubsub_message_safe(\n        self, response: Response\n    ) -&gt; Optional[CoreCommands.PubSubMsg]:\n        pubsub_message = None\n        push_notification = cast(\n            Dict[str, Any], value_from_pointer(response.resp_pointer)\n        )\n        message_kind = push_notification[\"kind\"]\n        if message_kind == \"Disconnection\":\n            ClientLogger.log(\n                LogLevel.WARN,\n                \"disconnect notification\",\n                \"Transport disconnected, messages might be lost\",\n            )\n        elif (\n            message_kind == \"Message\"\n            or message_kind == \"PMessage\"\n            or message_kind == \"SMessage\"\n        ):\n            values: List = push_notification[\"values\"]\n            if message_kind == \"PMessage\":\n                pubsub_message = BaseClient.PubSubMsg(\n                    message=values[2], channel=values[1], pattern=values[0]\n                )\n            else:\n                pubsub_message = BaseClient.PubSubMsg(\n                    message=values[1], channel=values[0], pattern=None\n                )\n        elif (\n            message_kind == \"PSubscribe\"\n            or message_kind == \"Subscribe\"\n            or message_kind == \"SSubscribe\"\n            or message_kind == \"Unsubscribe\"\n            or message_kind == \"PUnsubscribe\"\n            or message_kind == \"SUnsubscribe\"\n        ):\n            pass\n        else:\n            ClientLogger.log(\n                LogLevel.WARN,\n                \"unknown notification\",\n                f\"Unknown notification message: '{message_kind}'\",\n            )\n\n        return pubsub_message\n\n    def _complete_pubsub_futures_safe(self):\n        while len(self._pending_push_notifications) and len(self._pubsub_futures):\n            next_push_notification = self._pending_push_notifications.pop(0)\n            pubsub_message = self._notification_to_pubsub_message_safe(\n                next_push_notification\n            )\n            if pubsub_message:\n                self._pubsub_futures.pop(0).set_result(pubsub_message)\n\n    async def _write_request_await_response(self, request: CommandRequest):\n        # Create a response future for this request and add it to the available\n        # futures map\n        response_future = self._get_future(request.callback_idx)\n        self._create_write_task(request)\n        await response_future\n        return response_future.result()\n\n    def _get_callback_index(self) -&gt; int:\n        try:\n            return self._available_callback_indexes.pop()\n        except IndexError:\n            # The list is empty\n            return len(self._available_futures)\n\n    async def _process_response(self, response: Response) -&gt; None:\n        res_future = self._available_futures.pop(response.callback_idx, None)\n        if not res_future or response.HasField(\"closing_error\"):\n            err_msg = (\n                response.closing_error\n                if response.HasField(\"closing_error\")\n                else f\"Client Error - closing due to unknown error. callback index:  {response.callback_idx}\"\n            )\n            if res_future is not None:\n                res_future.set_exception(ClosingError(err_msg))\n            await self.close(err_msg)\n            raise ClosingError(err_msg)\n        else:\n            self._available_callback_indexes.append(response.callback_idx)\n            if response.HasField(\"request_error\"):\n                error_type = get_request_error_class(response.request_error.type)\n                res_future.set_exception(error_type(response.request_error.message))\n            elif response.HasField(\"resp_pointer\"):\n                res_future.set_result(value_from_pointer(response.resp_pointer))\n            elif response.HasField(\"constant_response\"):\n                res_future.set_result(OK)\n            else:\n                res_future.set_result(None)\n\n    async def _process_push(self, response: Response) -&gt; None:\n        if response.HasField(\"closing_error\") or not response.HasField(\"resp_pointer\"):\n            err_msg = (\n                response.closing_error\n                if response.HasField(\"closing_error\")\n                else \"Client Error - push notification without resp_pointer\"\n            )\n            await self.close(err_msg)\n            raise ClosingError(err_msg)\n\n        try:\n            self._pubsub_lock.acquire()\n            callback, context = self.config._get_pubsub_callback_and_context()\n            if callback:\n                pubsub_message = self._notification_to_pubsub_message_safe(response)\n                if pubsub_message:\n                    callback(pubsub_message, context)\n            else:\n                self._pending_push_notifications.append(response)\n                self._complete_pubsub_futures_safe()\n        finally:\n            self._pubsub_lock.release()\n\n    async def _reader_loop(self) -&gt; None:\n        # Socket reader loop\n        remaining_read_bytes = bytearray()\n        while True:\n            read_bytes = await self._reader.read(DEFAULT_READ_BYTES_SIZE)\n            if len(read_bytes) == 0:\n                err_msg = \"The communication layer was unexpectedly closed.\"\n                await self.close(err_msg)\n                raise ClosingError(err_msg)\n            read_bytes = remaining_read_bytes + bytearray(read_bytes)\n            read_bytes_view = memoryview(read_bytes)\n            offset = 0\n            while offset &lt;= len(read_bytes):\n                try:\n                    response, offset = ProtobufCodec.decode_delimited(\n                        read_bytes, read_bytes_view, offset, Response\n                    )\n                except PartialMessageException:\n                    # Recieved only partial response, break the inner loop\n                    remaining_read_bytes = read_bytes[offset:]\n                    break\n                response = cast(Response, response)\n                if response.is_push:\n                    await self._process_push(response=response)\n                else:\n                    await self._process_response(response=response)\n</code></pre>"},{"location":"python/base_client/#glide.glide_client.BaseClient.__init__","title":"<code>__init__(config)</code>","text":"<p>To create a new client, use the <code>create</code> classmethod</p> Source code in <code>glide/glide_client.py</code> <pre><code>def __init__(self, config: BaseClientConfiguration):\n    \"\"\"\n    To create a new client, use the `create` classmethod\n    \"\"\"\n    self.config: BaseClientConfiguration = config\n    self._available_futures: Dict[int, asyncio.Future] = {}\n    self._available_callback_indexes: List[int] = list()\n    self._buffered_requests: List[TRequest] = list()\n    self._writer_lock = threading.Lock()\n    self.socket_path: Optional[str] = None\n    self._reader_task: Optional[asyncio.Task] = None\n    self._is_closed: bool = False\n    self._pubsub_futures: List[asyncio.Future] = []\n    self._pubsub_lock = threading.Lock()\n    self._pending_push_notifications: List[Response] = list()\n</code></pre>"},{"location":"python/base_client/#glide.glide_client.BaseClient.close","title":"<code>close(err_message=None)</code>  <code>async</code>","text":"<p>Terminate the client by closing all associated resources, including the socket and any active futures. All open futures will be closed with an exception.</p> <p>Parameters:</p> Name Type Description Default <code>err_message</code> <code>Optional[str]</code> <p>If not None, this error message will be passed along with the exceptions when closing all open futures.</p> <code>None</code> Source code in <code>glide/glide_client.py</code> <pre><code>async def close(self, err_message: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Terminate the client by closing all associated resources, including the socket and any active futures.\n    All open futures will be closed with an exception.\n\n    Args:\n        err_message (Optional[str]): If not None, this error message will be passed along with the exceptions when closing all open futures.\n        Defaults to None.\n    \"\"\"\n    self._is_closed = True\n    for response_future in self._available_futures.values():\n        if not response_future.done():\n            err_message = \"\" if err_message is None else err_message\n            response_future.set_exception(ClosingError(err_message))\n    try:\n        self._pubsub_lock.acquire()\n        for pubsub_future in self._pubsub_futures:\n            if not pubsub_future.done() and not pubsub_future.cancelled():\n                pubsub_future.set_exception(ClosingError(\"\"))\n    finally:\n        self._pubsub_lock.release()\n\n    self._writer.close()\n    await self._writer.wait_closed()\n    self.__del__()\n</code></pre>"},{"location":"python/base_client/#glide.glide_client.BaseClient.create","title":"<code>create(config)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates a Glide client.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ClientConfiguration</code> <p>The client configurations. If no configuration is provided, a default client to \"localhost\":6379 will be created.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>a Glide Client instance.</p> Source code in <code>glide/glide_client.py</code> <pre><code>@classmethod\nasync def create(cls, config: BaseClientConfiguration) -&gt; Self:\n    \"\"\"Creates a Glide client.\n\n    Args:\n        config (ClientConfiguration): The client configurations.\n            If no configuration is provided, a default client to \"localhost\":6379 will be created.\n\n    Returns:\n        Self: a Glide Client instance.\n    \"\"\"\n    config = config\n    self = cls(config)\n    init_future: asyncio.Future = asyncio.Future()\n    loop = asyncio.get_event_loop()\n\n    def init_callback(socket_path: Optional[str], err: Optional[str]):\n        if err is not None:\n            raise ClosingError(err)\n        elif socket_path is None:\n            raise ClosingError(\n                \"Socket initialization error: Missing valid socket path.\"\n            )\n        else:\n            # Received socket path\n            self.socket_path = socket_path\n            loop.call_soon_threadsafe(init_future.set_result, True)\n\n    start_socket_listener_external(init_callback=init_callback)\n\n    # will log if the logger was created (wrapper or costumer) on info\n    # level or higher\n    ClientLogger.log(LogLevel.INFO, \"connection info\", \"new connection established\")\n    # Wait for the socket listener to complete its initialization\n    await init_future\n    # Create UDS connection\n    await self._create_uds_connection()\n    # Start the reader loop as a background task\n    self._reader_task = asyncio.create_task(self._reader_loop())\n    # Set the client configurations\n    await self._set_connection_configurations()\n    return self\n</code></pre>"},{"location":"python/cluster_commands/","title":"ClusterCommands","text":"<p>               Bases: <code>CoreCommands</code></p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>class ClusterCommands(CoreCommands):\n    async def custom_command(\n        self, command_args: List[TEncodable], route: Optional[Route] = None\n    ) -&gt; TClusterResponse[TResult]:\n        \"\"\"\n        Executes a single command, without checking inputs.\n        See the [Valkey GLIDE Wiki](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#custom-command)\n        for details on the restrictions and limitations of the custom command API.\n\n            @example - Return a list of all pub/sub clients from all nodes:\n\n                connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"], AllNodes())\n        Args:\n            command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.\n            Every part of the command, including the command name and subcommands, should be added as a separate value in args.\n            route (Optional[Route]): The command will be routed automatically based on the passed command's default request policy, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TClusterResponse[TResult]: The returning value depends on the executed command and the route.\n        \"\"\"\n        return cast(\n            TClusterResponse[TResult],\n            await self._execute_command(RequestType.CustomCommand, command_args, route),\n        )\n\n    async def info(\n        self,\n        sections: Optional[List[InfoSection]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[bytes]:\n        \"\"\"\n        Get information and statistics about the server.\n        See https://valkey.io/commands/info/ for details.\n\n        Args:\n            sections (Optional[List[InfoSection]]): A list of InfoSection values specifying which sections of\n            information to retrieve. When no parameter is provided, the default option is assumed.\n            route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TClusterResponse[bytes]: If a single node route is requested, returns a bytes string containing the information for\n            the required sections. Otherwise, returns a dict of bytes strings, with each key containing the address of\n            the queried node and value containing the information regarding the requested sections.\n        \"\"\"\n        args: List[TEncodable] = (\n            [section.value for section in sections] if sections else []\n        )\n        return cast(\n            TClusterResponse[bytes],\n            await self._execute_command(RequestType.Info, args, route),\n        )\n\n    async def exec(\n        self,\n        transaction: ClusterTransaction,\n        route: Optional[TSingleNodeRoute] = None,\n    ) -&gt; Optional[List[TResult]]:\n        \"\"\"\n        Execute a transaction by processing the queued commands.\n        See https://valkey.io/docs/topics/transactions/ for details on Transactions.\n\n        Args:\n            transaction (ClusterTransaction): A `ClusterTransaction` object containing a list of commands to be executed.\n            route (Optional[TSingleNodeRoute]): If `route` is not provided, the transaction will be routed to the slot owner of the\n                first key found in the transaction. If no key is found, the command will be sent to a random node.\n                If `route` is provided, the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            Optional[List[TResult]]: A list of results corresponding to the execution of each command\n                in the transaction. If a command returns a value, it will be included in the list. If a command\n                doesn't return a value, the list entry will be `None`.\n                If the transaction failed due to a WATCH command, `exec` will return `None`.\n        \"\"\"\n        commands = transaction.commands[:]\n        return await self._execute_transaction(commands, route)\n\n    async def config_resetstat(\n        self,\n        route: Optional[Route] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands.\n        See https://valkey.io/commands/config-resetstat/ for details.\n\n        Args:\n            route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            OK: Returns \"OK\" to confirm that the statistics were successfully reset.\n        \"\"\"\n        return cast(\n            TOK, await self._execute_command(RequestType.ConfigResetStat, [], route)\n        )\n\n    async def config_rewrite(\n        self,\n        route: Optional[Route] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Rewrite the configuration file with the current configuration.\n        See https://valkey.io/commands/config-rewrite/ for details.\n\n        Args:\n            route (Optional[TRoute]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            OK: OK is returned when the configuration was rewritten properly. Otherwise an error is raised.\n\n        Example:\n            &gt;&gt;&gt; await client.config_rewrite()\n                'OK'\n        \"\"\"\n        return cast(\n            TOK, await self._execute_command(RequestType.ConfigRewrite, [], route)\n        )\n\n    async def client_id(\n        self,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[int]:\n        \"\"\"\n        Returns the current connection id.\n        See https://valkey.io/commands/client-id/ for more information.\n\n        Args:\n            route (Optional[Route]): The command will be sent to a random node, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[int]: The id of the client.\n            If a single node route is requested, returns a int representing the client's id.\n            Otherwise, returns a dict of [byte , int] where each key contains the address of\n            the queried node and the value contains the client's id.\n        \"\"\"\n        return cast(\n            TClusterResponse[int],\n            await self._execute_command(RequestType.ClientId, [], route),\n        )\n\n    async def ping(\n        self, message: Optional[TEncodable] = None, route: Optional[Route] = None\n    ) -&gt; bytes:\n        \"\"\"\n        Ping the server.\n        See https://valkey.io/commands/ping/ for more details.\n\n        Args:\n            message (Optional[TEncodable]): An optional message to include in the PING command. If not provided,\n            the server will respond with b\"PONG\". If provided, the server will respond with a copy of the message.\n\n            route (Optional[Route]): The command will be sent to all primaries, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`\n\n        Returns:\n           bytes: b'PONG' if `message` is not provided, otherwise return a copy of `message`.\n\n        Examples:\n            &gt;&gt;&gt; await client.ping()\n                b\"PONG\"\n            &gt;&gt;&gt; await client.ping(\"Hello\")\n                b\"Hello\"\n        \"\"\"\n        argument = [] if message is None else [message]\n        return cast(\n            bytes, await self._execute_command(RequestType.Ping, argument, route)\n        )\n\n    async def config_get(\n        self, parameters: List[TEncodable], route: Optional[Route] = None\n    ) -&gt; TClusterResponse[Dict[bytes, bytes]]:\n        \"\"\"\n        Get the values of configuration parameters.\n        See https://valkey.io/commands/config-get/ for details.\n\n        Args:\n            parameters (List[TEncodable]): A list of configuration parameter names to retrieve values for.\n\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[Dict[bytes, bytes]]: A dictionary of values corresponding to the\n            configuration parameters.\n            When specifying a route other than a single node, response will be : {Address (bytes) : response (Dict[bytes, bytes]) , ... }\n            with type of Dict[bytes, Dict[bytes, bytes]].\n\n        Examples:\n            &gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n                {b'timeout': b'1000'}\n            &gt;&gt;&gt; await client.config_get([\"timeout\" , b\"maxmemory\"])\n                {b'timeout': b'1000', b\"maxmemory\": b\"1GB\"}\n        \"\"\"\n        return cast(\n            TClusterResponse[Dict[bytes, bytes]],\n            await self._execute_command(RequestType.ConfigGet, parameters, route),\n        )\n\n    async def config_set(\n        self,\n        parameters_map: Mapping[TEncodable, TEncodable],\n        route: Optional[Route] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Set configuration parameters to the specified values.\n        See https://valkey.io/commands/config-set/ for details.\n\n        Args:\n            parameters_map (Mapping[TEncodable, TEncodable]): A map consisting of configuration\n            parameters and their respective values to set.\n\n            route (Optional[Route]): The command will be routed to all nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            OK: Returns OK if all configurations have been successfully set. Otherwise, raises an error.\n\n        Examples:\n            &gt;&gt;&gt; await client.config_set({\"timeout\": \"1000\", b\"maxmemory\": b\"1GB\"})\n                OK\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in parameters_map.items():\n            parameters.extend(pair)\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.ConfigSet, parameters, route),\n        )\n\n    async def client_getname(\n        self, route: Optional[Route] = None\n    ) -&gt; TClusterResponse[Optional[bytes]]:\n        \"\"\"\n        Get the name of the connection to which the request is routed.\n        See https://valkey.io/commands/client-getname/ for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[Optional[bytes]]: The name of the client connection as a bytes string if a name is set,\n            or None if no name is assigned.\n            When specifying a route other than a single node, response will be:\n            {Address (bytes) : response (Optional[bytes]) , ... } with type of Dict[str, Optional[str]].\n\n        Examples:\n            &gt;&gt;&gt; await client.client_getname()\n                b'Connection Name'\n            &gt;&gt;&gt; await client.client_getname(AllNodes())\n                {b'addr': b'Connection Name', b'addr2': b'Connection Name', b'addr3': b'Connection Name'}\n        \"\"\"\n        return cast(\n            TClusterResponse[Optional[bytes]],\n            await self._execute_command(RequestType.ClientGetName, [], route),\n        )\n\n    async def dbsize(self, route: Optional[Route] = None) -&gt; int:\n        \"\"\"\n        Returns the number of keys in the database.\n        See https://valkey.io/commands/dbsize for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            int: The number of keys in the database.\n            In the case of routing the query to multiple nodes, returns the aggregated number of keys across the different nodes.\n\n        Examples:\n            &gt;&gt;&gt; await client.dbsize()\n                10  # Indicates there are 10 keys in the cluster.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.DBSize, [], route))\n\n    async def echo(\n        self, message: TEncodable, route: Optional[Route] = None\n    ) -&gt; TClusterResponse[bytes]:\n        \"\"\"\n        Echoes the provided `message` back.\n\n        See https://valkey.io/commands/echo for more details.\n\n        Args:\n            message (TEncodable): The message to be echoed back.\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[bytes]: The provided `message`.\n            When specifying a route other than a single node, response will be:\n            {Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].\n\n        Examples:\n            &gt;&gt;&gt; await client.echo(b\"Valkey GLIDE\")\n                b'Valkey GLIDE'\n            &gt;&gt;&gt; await client.echo(\"Valkey GLIDE\", AllNodes())\n                {b'addr': b'Valkey GLIDE', b'addr2': b'Valkey GLIDE', b'addr3': b'Valkey GLIDE'}\n        \"\"\"\n        return cast(\n            TClusterResponse[bytes],\n            await self._execute_command(RequestType.Echo, [message], route),\n        )\n\n    async def function_load(\n        self,\n        library_code: TEncodable,\n        replace: bool = False,\n        route: Optional[Route] = None,\n    ) -&gt; bytes:\n        \"\"\"\n        Loads a library to Valkey.\n\n        See https://valkey.io/commands/function-load/ for more details.\n\n        Args:\n            library_code (TEncodable): The source code that implements the library.\n            replace (bool): Whether the given library should overwrite a library with the same name if\n                it already exists.\n            route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            bytes: The library name that was loaded.\n\n        Examples:\n            &gt;&gt;&gt; code = \"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n            &gt;&gt;&gt; await client.function_load(code, True, RandomNode())\n                b\"mylib\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            bytes,\n            await self._execute_command(\n                RequestType.FunctionLoad,\n                [\"REPLACE\", library_code] if replace else [library_code],\n                route,\n            ),\n        )\n\n    async def function_list(\n        self,\n        library_name_pattern: Optional[TEncodable] = None,\n        with_code: bool = False,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[TFunctionListResponse]:\n        \"\"\"\n        Returns information about the functions and libraries.\n\n        See https://valkey.io/commands/function-list/ for more details.\n\n        Args:\n            library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n            with_code (bool): Specifies whether to request the library code from the server or not.\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[TFunctionListResponse]: Info\n            about all or selected libraries and their functions.\n\n        Examples:\n            &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n                [{\n                    b\"library_name\": b\"myLib5_backup\",\n                    b\"engine\": b\"LUA\",\n                    b\"functions\": [{\n                        b\"name\": b\"myfunc\",\n                        b\"description\": None,\n                        b\"flags\": {b\"no-writes\"},\n                    }],\n                    b\"library_code\": b\"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n                }]\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        args = []\n        if library_name_pattern is not None:\n            args.extend([\"LIBRARYNAME\", library_name_pattern])\n        if with_code:\n            args.append(\"WITHCODE\")\n        return cast(\n            TClusterResponse[TFunctionListResponse],\n            await self._execute_command(\n                RequestType.FunctionList,\n                args,\n                route,\n            ),\n        )\n\n    async def function_flush(\n        self, mode: Optional[FlushMode] = None, route: Optional[Route] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Deletes all function libraries.\n\n        See https://valkey.io/commands/function-flush/ for more details.\n\n        Args:\n            mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n            route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.FunctionFlush,\n                [mode.value] if mode else [],\n                route,\n            ),\n        )\n\n    async def function_delete(\n        self, library_name: TEncodable, route: Optional[Route] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Deletes a library and all its functions.\n\n        See https://valkey.io/commands/function-delete/ for more details.\n\n        Args:\n            library_code (TEncodable): The library name to delete\n            route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_delete(\"my_lib\")\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.FunctionDelete,\n                [library_name],\n                route,\n            ),\n        )\n\n    async def function_kill(self, route: Optional[Route] = None) -&gt; TOK:\n        \"\"\"\n        Kills a function that is currently executing.\n        This command only terminates read-only functions.\n\n        See https://valkey.io/commands/function-kill/ for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to all nodes, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_kill()\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.FunctionKill,\n                [],\n                route,\n            ),\n        )\n\n    async def fcall_route(\n        self,\n        function: TEncodable,\n        arguments: Optional[List[TEncodable]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[TResult]:\n        \"\"\"\n        Invokes a previously loaded function.\n        See https://valkey.io/commands/fcall/ for more details.\n\n        Args:\n            function (TEncodable): The function name.\n            arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n                should not represent names of keys.\n            route (Optional[Route]): The command will be routed to a random primary node, unless `route` is provided, in which\n                case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TClusterResponse[TResult]:\n                If a single node route is requested, returns a Optional[TResult] representing the function's return value.\n                Otherwise, returns a dict of [bytes , Optional[TResult]] where each key contains the address of\n                the queried node and the value contains the function's return value.\n\n        Example:\n            &gt;&gt;&gt; await client.fcall(\"Deep_Thought\", [\"Answer\", \"to\", \"the\", \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"], RandomNode())\n                b'new_value' # Returns the function's return value.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [function, \"0\"]\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TClusterResponse[TResult],\n            await self._execute_command(RequestType.FCall, args, route),\n        )\n\n    async def fcall_ro_route(\n        self,\n        function: TEncodable,\n        arguments: Optional[List[TEncodable]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[TResult]:\n        \"\"\"\n        Invokes a previously loaded read-only function.\n\n        See https://valkey.io/commands/fcall_ro for more details.\n\n        Args:\n            function (TEncodable): The function name.\n            arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n                represent names of keys.\n            route (Optional[Route]): Specifies the routing configuration of the command. The client\n                will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[TResult]: The return value depends on the function that was executed.\n\n        Examples:\n            &gt;&gt;&gt; await client.fcall_ro_route(\"Deep_Thought\", ALL_NODES)\n                42 # The return value on the function that was executed\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [function, \"0\"]\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TClusterResponse[TResult],\n            await self._execute_command(RequestType.FCallReadOnly, args, route),\n        )\n\n    async def function_stats(\n        self, route: Optional[Route] = None\n    ) -&gt; TClusterResponse[TFunctionStatsSingleNodeResponse]:\n        \"\"\"\n        Returns information about the function that's currently running and information about the\n        available execution engines.\n\n        See https://valkey.io/commands/function-stats/ for more details\n\n        Args:\n            route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n                case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TClusterResponse[TFunctionStatsSingleNodeResponse]: A `Mapping` with two keys:\n                - `running_script` with information about the running script.\n                - `engines` with information about available engines and their stats.\n                See example for more details.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_stats(RandomNode())\n                {\n                    'running_script': {\n                        'name': 'foo',\n                        'command': ['FCALL', 'foo', '0', 'hello'],\n                        'duration_ms': 7758\n                    },\n                    'engines': {\n                        'LUA': {\n                            'libraries_count': 1,\n                            'functions_count': 1,\n                        }\n                    }\n                }\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(\n            TClusterResponse[TFunctionStatsSingleNodeResponse],\n            await self._execute_command(RequestType.FunctionStats, [], route),\n        )\n\n    async def function_dump(\n        self, route: Optional[Route] = None\n    ) -&gt; TClusterResponse[bytes]:\n        \"\"\"\n        Returns the serialized payload of all loaded libraries.\n\n        See https://valkey.io/commands/function-dump/ for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to a random node, unless\n                `route` is provided, in which case the client will route the command to the\n                nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[bytes]: The serialized payload of all loaded libraries.\n\n        Examples:\n            &gt;&gt;&gt; payload = await client.function_dump()\n                # The serialized payload of all loaded libraries. This response can\n                # be used to restore loaded functions on any Valkey instance.\n            &gt;&gt;&gt; await client.function_restore(payload)\n                \"OK\" # The serialized dump response was used to restore the libraries.\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TClusterResponse[bytes],\n            await self._execute_command(RequestType.FunctionDump, [], route),\n        )\n\n    async def function_restore(\n        self,\n        payload: TEncodable,\n        policy: Optional[FunctionRestorePolicy] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Restores libraries from the serialized payload returned by the `function_dump` command.\n\n        See https://valkey.io/commands/function-restore/ for more details.\n\n        Args:\n            payload (bytes): The serialized data from the `function_dump` command.\n            policy (Optional[FunctionRestorePolicy]): A policy for handling existing libraries.\n            route (Optional[Route]): The command will be sent to all primaries, unless\n                `route` is provided, in which case the client will route the command to the\n                nodes defined by `route`.\n\n        Returns:\n            TOK: OK.\n\n        Examples:\n            &gt;&gt;&gt; payload = await client.function_dump()\n                # The serialized payload of all loaded libraries. This response can\n                # be used to restore loaded functions on any Valkey instance.\n            &gt;&gt;&gt; await client.function_restore(payload, AllPrimaries())\n                \"OK\" # The serialized dump response was used to restore the libraries with the specified route.\n            &gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH, AllPrimaries())\n                \"OK\" # The serialized dump response was used to restore the libraries with the specified route and policy.\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [payload]\n        if policy is not None:\n            args.append(policy.value)\n\n        return cast(\n            TOK, await self._execute_command(RequestType.FunctionRestore, args, route)\n        )\n\n    async def time(\n        self, route: Optional[Route] = None\n    ) -&gt; TClusterResponse[List[bytes]]:\n        \"\"\"\n        Returns the server time.\n\n        See https://valkey.io/commands/time/ for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[Optional[bytes]]:  The current server time as a two items `array`:\n            A Unix timestamp and the amount of microseconds already elapsed in the current second.\n            The returned `array` is in a [Unix timestamp, Microseconds already elapsed] format.\n            When specifying a route other than a single node, response will be:\n            {Address (bytes) : response (List[bytes]) , ... } with type of Dict[bytes, List[bytes]].\n\n        Examples:\n            &gt;&gt;&gt; await client.time()\n                [b'1710925775', b'913580']\n            &gt;&gt;&gt; await client.time(AllNodes())\n                {b'addr': [b'1710925775', b'913580'], b'addr2': [b'1710925775', b'913580'], b'addr3': [b'1710925775', b'913580']}\n        \"\"\"\n        return cast(\n            TClusterResponse[List[bytes]],\n            await self._execute_command(RequestType.Time, [], route),\n        )\n\n    async def lastsave(self, route: Optional[Route] = None) -&gt; TClusterResponse[int]:\n        \"\"\"\n        Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.\n\n        See https://valkey.io/commands/lastsave for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[int]: The Unix time of the last successful DB save.\n                If no route is provided, or a single node route is requested, returns an int representing the Unix time\n                of the last successful DB save. Otherwise, returns a dict of [bytes , int] where each key contains the\n                address of the queried node and the value contains the Unix time of the last successful DB save.\n\n        Examples:\n            &gt;&gt;&gt; await client.lastsave()\n                1710925775  # Unix time of the last DB save\n            &gt;&gt;&gt; await client.lastsave(AllNodes())\n                {b'addr1': 1710925775, b'addr2': 1710925775, b'addr3': 1710925775}  # Unix time of the last DB save on each node\n        \"\"\"\n        return cast(\n            TClusterResponse[int],\n            await self._execute_command(RequestType.LastSave, [], route),\n        )\n\n    async def publish(\n        self,\n        message: TEncodable,\n        channel: TEncodable,\n        sharded: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Publish a message on pubsub channel.\n        This command aggregates PUBLISH and SPUBLISH commands functionalities.\n        The mode is selected using the 'sharded' parameter.\n        For both sharded and non-sharded mode, request is routed using hashed channel as key.\n        See https://valkey.io/commands/publish and https://valkey.io/commands/spublish for more details.\n\n        Args:\n            message (TEncodable): Message to publish.\n            channel (TEncodable): Channel to publish the message on.\n            sharded (bool): Use sharded pubsub mode. Available since Valkey version 7.0.\n\n        Returns:\n            int: Number of subscriptions in that node that received the message.\n\n        Examples:\n            &gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\", False)\n                1  # Published 1 instance of \"Hi all!\" message on global-channel channel using non-sharded mode\n            &gt;&gt;&gt; await client.publish(b\"Hi to sharded channel1!\", b\"channel1\", True)\n                2  # Published 2 instances of \"Hi to sharded channel1!\" message on channel1 using sharded mode\n        \"\"\"\n        result = await self._execute_command(\n            RequestType.SPublish if sharded else RequestType.Publish, [channel, message]\n        )\n        return cast(int, result)\n\n    async def pubsub_shardchannels(\n        self, pattern: Optional[TEncodable] = None\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Lists the currently active shard channels.\n        The command is routed to all nodes, and aggregates the response to a single array.\n\n        See https://valkey.io/commands/pubsub-shardchannels for more details.\n\n        Args:\n            pattern (Optional[TEncodable]): A glob-style pattern to match active shard channels.\n                                If not provided, all active shard channels are returned.\n\n        Returns:\n            List[bytes]: A list of currently active shard channels matching the given pattern.\n                    If no pattern is specified, all active shard channels are returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_shardchannels()\n                [b'channel1', b'channel2']\n\n            &gt;&gt;&gt; await client.pubsub_shardchannels(\"channel*\")\n                [b'channel1', b'channel2']\n        \"\"\"\n        command_args = [pattern] if pattern is not None else []\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.PubSubSChannels, command_args),\n        )\n\n    async def pubsub_shardnumsub(\n        self, channels: Optional[List[TEncodable]] = None\n    ) -&gt; Mapping[bytes, int]:\n        \"\"\"\n        Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified shard channels.\n\n        Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n        The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n        See https://valkey.io/commands/pubsub-shardnumsub for more details.\n\n        Args:\n            channels (Optional[List[TEncodable]]): The list of shard channels to query for the number of subscribers.\n                                            If not provided, returns an empty map.\n\n        Returns:\n            Mapping[bytes, int]: A map where keys are the shard channel names and values are the number of subscribers.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_shardnumsub([\"channel1\", \"channel2\"])\n                {b'channel1': 3, b'channel2': 5}\n\n            &gt;&gt;&gt; await client.pubsub_shardnumsub()\n                {}\n        \"\"\"\n        return cast(\n            Mapping[bytes, int],\n            await self._execute_command(\n                RequestType.PubSubSNumSub, channels if channels else []\n            ),\n        )\n\n    async def flushall(\n        self, flush_mode: Optional[FlushMode] = None, route: Optional[Route] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Deletes all the keys of all the existing databases. This command never fails.\n\n        See https://valkey.io/commands/flushall for more details.\n\n        Args:\n            flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n                OK  # This command never fails.\n            &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC, AllNodes())\n                OK  # This command never fails.\n        \"\"\"\n        args: List[TEncodable] = []\n        if flush_mode is not None:\n            args.append(flush_mode.value)\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.FlushAll, args, route),\n        )\n\n    async def flushdb(\n        self, flush_mode: Optional[FlushMode] = None, route: Optional[Route] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Deletes all the keys of the currently selected database. This command never fails.\n\n        See https://valkey.io/commands/flushdb for more details.\n\n        Args:\n            flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.flushdb()\n                OK  # The keys of the currently selected database were deleted.\n            &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n                OK  # The keys of the currently selected database were deleted asynchronously.\n            &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC, AllNodes())\n                OK  # The keys of the currently selected database were deleted asynchronously on all nodes.\n        \"\"\"\n        args: List[TEncodable] = []\n        if flush_mode is not None:\n            args.append(flush_mode.value)\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.FlushDB, args, route),\n        )\n\n    async def copy(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        replace: Optional[bool] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Copies the value stored at the `source` to the `destination` key. When `replace` is True,\n        removes the `destination` key first if it already exists, otherwise performs no action.\n\n        See https://valkey.io/commands/copy for more details.\n\n        Note:\n            Both `source` and `destination` must map to the same hash slot.\n\n        Args:\n            source (TEncodable): The key to the source value.\n            destination (TEncodable): The key where the value should be copied to.\n            replace (Optional[bool]): If the destination key should be removed before copying the value to it.\n\n        Returns:\n            bool: True if the source was copied. Otherwise, returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n            &gt;&gt;&gt; await client.copy(b\"source\", b\"destination\")\n                True # Source was copied\n            &gt;&gt;&gt; await client.get(\"destination\")\n                b\"sheep\"\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [source, destination]\n        if replace is True:\n            args.append(\"REPLACE\")\n        return cast(\n            bool,\n            await self._execute_command(RequestType.Copy, args),\n        )\n\n    async def lolwut(\n        self,\n        version: Optional[int] = None,\n        parameters: Optional[List[int]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[bytes]:\n        \"\"\"\n        Displays a piece of generative computer art and the Valkey version.\n\n        See https://valkey.io/commands/lolwut for more details.\n\n        Args:\n            version (Optional[int]): Version of computer art to generate.\n            parameters (Optional[List[int]]): Additional set of arguments in order to change the output:\n                For version `5`, those are length of the line, number of squares per row, and number of squares per column.\n                For version `6`, those are number of columns and number of lines.\n            route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TClusterResponse[bytes]: A piece of generative computer art along with the current Valkey version.\n            When specifying a route other than a single node, response will be:\n            {Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].\n\n        Examples:\n            &gt;&gt;&gt; await client.lolwut(6, [40, 20], RandomNode());\n                b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n        \"\"\"\n        args: List[TEncodable] = []\n        if version is not None:\n            args.extend([\"VERSION\", str(version)])\n        if parameters:\n            for var in parameters:\n                args.extend(str(var))\n        return cast(\n            TClusterResponse[bytes],\n            await self._execute_command(RequestType.Lolwut, args, route),\n        )\n\n    async def random_key(self, route: Optional[Route] = None) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random existing key name.\n\n        See https://valkey.io/commands/randomkey for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            Optional[bytes]: A random existing key name.\n\n        Examples:\n            &gt;&gt;&gt; await client.random_key()\n                b\"random_key_name\"  # \"random_key_name\" is a random existing key name.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.RandomKey, [], route),\n        )\n\n    async def wait(\n        self,\n        numreplicas: int,\n        timeout: int,\n        route: Optional[Route] = None,\n    ) -&gt; int:\n        \"\"\"\n        Blocks the current client until all the previous write commands are successfully transferred\n        and acknowledged by at least `numreplicas` of replicas. If `timeout` is\n        reached, the command returns even if the specified number of replicas were not yet reached.\n\n        See https://valkey.io/commands/wait for more details.\n\n        Args:\n            numreplicas (int): The number of replicas to reach.\n            timeout (int): The timeout value specified in milliseconds. A value of 0 will block indefinitely.\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            int: The number of replicas reached by all the writes performed in the context of the current connection.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\");\n            &gt;&gt;&gt; await client.wait(1, 1000);\n            // return 1 when a replica is reached or 0 if 1000ms is reached.\n        \"\"\"\n        args: List[TEncodable] = [str(numreplicas), str(timeout)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.Wait, args, route),\n        )\n\n    async def unwatch(self, route: Optional[Route] = None) -&gt; TOK:\n        \"\"\"\n        Flushes all the previously watched keys for a transaction. Executing a transaction will\n        automatically flush all previously watched keys.\n\n        See https://valkey.io/commands/unwatch for more details.\n\n        Args:\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n                in which case the client will route the command to the nodes defined by `route`.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.unwatch()\n                'OK'\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.UnWatch, [], route),\n        )\n\n    async def scan(\n        self,\n        cursor: ClusterScanCursor,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        type: Optional[ObjectType] = None,\n    ) -&gt; List[Union[ClusterScanCursor, List[bytes]]]:\n        \"\"\"\n        Incrementally iterates over the keys in the Cluster.\n        The method returns a list containing the next cursor and a list of keys.\n\n        This command is similar to the SCAN command, but it is designed to work in a Cluster environment.\n        For each iteration the new cursor object should be used to continue the scan.\n        Using the same cursor object for multiple iterations will result in the same keys or unexpected behavior.\n        For more information about the Cluster Scan implementation,\n        see [Cluster Scan](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#cluster-scan).\n\n        As the SCAN command, the method can be used to iterate over the keys in the database,\n        to return all keys the database have from the time the scan started till the scan ends.\n        The same key can be returned in multiple scans iteration.\n\n        See https://valkey.io/commands/scan/ for more details.\n\n        Args:\n            cursor (ClusterScanCursor): The cursor object that wraps the scan state.\n              To start a new scan, create a new empty ClusterScanCursor using ClusterScanCursor().\n            match (Optional[TEncodable]): A pattern to match keys against.\n            count (Optional[int]): The number of keys to return in a single iteration.\n              The actual number returned can vary and is not guaranteed to match this count exactly.\n              This parameter serves as a hint to the server on the number of steps to perform in each iteration.\n              The default value is 10.\n            type (Optional[ObjectType]): The type of object to scan for.\n\n        Returns:\n            List[Union[ClusterScanCursor, List[TEncodable]]]: A list containing the next cursor and a list of keys,\n              formatted as [ClusterScanCursor, [key1, key2, ...]].\n\n        Examples:\n            &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster.\n                await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n                cursor = ClusterScanCursor()\n                all_keys = []\n                while not cursor.is_finished():\n                    cursor, keys = await client.scan(cursor, count=10)\n                    all_keys.extend(keys)\n                print(all_keys) # [b'key1', b'key2', b'key3']\n            &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that match the pattern \"*key*\".\n                await client.mset({b\"key1\": b\"value1\", b\"key2\": b\"value2\", b\"not_my_key\": b\"value3\", b\"something_else\": b\"value4\"})\n                cursor = ClusterScanCursor()\n                all_keys = []\n                while not cursor.is_finished():\n                    cursor, keys = await client.scan(cursor, match=b\"*key*\", count=10)\n                    all_keys.extend(keys)\n                print(all_keys) # [b'my_key1', b'my_key2', b'not_my_key']\n            &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that are of type STRING.\n                await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n                await client.sadd(b\"this_is_a_set\", [b\"value4\"])\n                cursor = ClusterScanCursor()\n                all_keys = []\n                while not cursor.is_finished():\n                    cursor, keys = await client.scan(cursor, type=ObjectType.STRING)\n                    all_keys.extend(keys)\n                print(all_keys) # [b'key1', b'key2', b'key3']\n        \"\"\"\n        return cast(\n            List[Union[ClusterScanCursor, List[bytes]]],\n            await self._cluster_scan(cursor, match, count, type),\n        )\n\n    async def script_exists(\n        self, sha1s: List[TEncodable], route: Optional[Route] = None\n    ) -&gt; TClusterResponse[List[bool]]:\n        \"\"\"\n        Check existence of scripts in the script cache by their SHA1 digest.\n\n        See https://valkey.io/commands/script-exists for more details.\n\n        Args:\n            sha1s (List[TEncodable]): List of SHA1 digests of the scripts to check.\n            route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TClusterResponse[List[bool]]: A list of boolean values indicating the existence of each script.\n\n        Examples:\n            &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n            &gt;&gt;&gt; await client.script_exists([lua_script.get_hash(), \"sha1_digest2\"])\n                [True, False]\n        \"\"\"\n        return cast(\n            TClusterResponse[List[bool]],\n            await self._execute_command(RequestType.ScriptExists, sha1s, route),\n        )\n\n    async def script_flush(\n        self, mode: Optional[FlushMode] = None, route: Optional[Route] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Flush the Lua scripts cache.\n\n        See https://valkey.io/commands/script-flush for more details.\n\n        Args:\n            mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n            route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n                case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TOK: A simple `OK` response.\n\n        Examples:\n            &gt;&gt;&gt; await client.script_flush()\n                \"OK\"\n\n            &gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n                \"OK\"\n        \"\"\"\n\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.ScriptFlush, [mode.value] if mode else [], route\n            ),\n        )\n\n    async def script_kill(self, route: Optional[Route] = None) -&gt; TOK:\n        \"\"\"\n        Kill the currently executing Lua script, assuming no write operation was yet performed by the script.\n        The command is routed to all nodes, and aggregates the response to a single array.\n\n        See https://valkey.io/commands/script-kill for more details.\n\n        Returns:\n            TOK: A simple `OK` response.\n            route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n                case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Examples:\n            &gt;&gt;&gt; await client.script_kill()\n                \"OK\"\n        \"\"\"\n        return cast(TOK, await self._execute_command(RequestType.ScriptKill, [], route))\n\n    async def invoke_script(\n        self,\n        script: Script,\n        keys: Optional[List[TEncodable]] = None,\n        args: Optional[List[TEncodable]] = None,\n    ) -&gt; TClusterResponse[TResult]:\n        \"\"\"\n        Invokes a Lua script with its keys and arguments.\n        This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script.\n        The script loading, argument preparation, and execution will all be handled internally.\n        If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n        After that, it will be invoked using the `EVALSHA` command.\n\n        When in cluster mode, `key`s must map to the same hash slot.\n\n        See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n        Args:\n            script (Script): The Lua script to execute.\n            keys (Optional[List[TEncodable]]): The keys that are used in the script. To ensure the correct execution of\n                the script, all names of keys that a script accesses must be explicitly provided as `keys`.\n            args (Optional[List[TEncodable]]): The non-key arguments for the script.\n\n        Returns:\n            TResult: a value that depends on the script that was executed.\n\n        Examples:\n            &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n            &gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n                [b\"foo\", b\"bar\"]\n        \"\"\"\n        return await self._execute_script(script.get_hash(), keys, args)\n\n    async def invoke_script_route(\n        self,\n        script: Script,\n        args: Optional[List[TEncodable]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TClusterResponse[TResult]:\n        \"\"\"\n        Invokes a Lua script with its arguments and route.\n        This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script.\n        The script loading, argument preparation, and execution will all be handled internally.\n        If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n        After that, it will be invoked using the `EVALSHA` command.\n\n        See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n        Args:\n            script (Script): The Lua script to execute.\n            args (Optional[List[TEncodable]]): The non-key arguments for the script.\n            route (Optional[Route]): The command will be routed automatically to a random node, unless `route` is provided, in which\n                case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n        Returns:\n            TResult: a value that depends on the script that was executed.\n\n        Examples:\n            &gt;&gt;&gt; lua_script = Script(\"return { ARGV[1] }\")\n            &gt;&gt;&gt; await invoke_script(lua_script, args=[\"bar\"], route=AllPrimaries());\n                [b\"bar\"]\n        \"\"\"\n        return await self._execute_script(\n            script.get_hash(), keys=None, args=args, route=route\n        )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.client_getname","title":"<code>client_getname(route=None)</code>  <code>async</code>","text":"<p>Get the name of the connection to which the request is routed. See https://valkey.io/commands/client-getname/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[Optional[bytes]]</code> <p>TClusterResponse[Optional[bytes]]: The name of the client connection as a bytes string if a name is set,</p> <code>TClusterResponse[Optional[bytes]]</code> <p>or None if no name is assigned.</p> <code>TClusterResponse[Optional[bytes]]</code> <p>When specifying a route other than a single node, response will be:</p> <code>TClusterResponse[Optional[bytes]]</code> <p>{Address (bytes) : response (Optional[bytes]) , ... } with type of Dict[str, Optional[str]].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.client_getname()\n    b'Connection Name'\n&gt;&gt;&gt; await client.client_getname(AllNodes())\n    {b'addr': b'Connection Name', b'addr2': b'Connection Name', b'addr3': b'Connection Name'}\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def client_getname(\n    self, route: Optional[Route] = None\n) -&gt; TClusterResponse[Optional[bytes]]:\n    \"\"\"\n    Get the name of the connection to which the request is routed.\n    See https://valkey.io/commands/client-getname/ for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[Optional[bytes]]: The name of the client connection as a bytes string if a name is set,\n        or None if no name is assigned.\n        When specifying a route other than a single node, response will be:\n        {Address (bytes) : response (Optional[bytes]) , ... } with type of Dict[str, Optional[str]].\n\n    Examples:\n        &gt;&gt;&gt; await client.client_getname()\n            b'Connection Name'\n        &gt;&gt;&gt; await client.client_getname(AllNodes())\n            {b'addr': b'Connection Name', b'addr2': b'Connection Name', b'addr3': b'Connection Name'}\n    \"\"\"\n    return cast(\n        TClusterResponse[Optional[bytes]],\n        await self._execute_command(RequestType.ClientGetName, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.client_id","title":"<code>client_id(route=None)</code>  <code>async</code>","text":"<p>Returns the current connection id. See https://valkey.io/commands/client-id/ for more information.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be sent to a random node, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[int]</code> <p>TClusterResponse[int]: The id of the client.</p> <code>TClusterResponse[int]</code> <p>If a single node route is requested, returns a int representing the client's id.</p> <code>TClusterResponse[int]</code> <p>Otherwise, returns a dict of [byte , int] where each key contains the address of</p> <code>TClusterResponse[int]</code> <p>the queried node and the value contains the client's id.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def client_id(\n    self,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[int]:\n    \"\"\"\n    Returns the current connection id.\n    See https://valkey.io/commands/client-id/ for more information.\n\n    Args:\n        route (Optional[Route]): The command will be sent to a random node, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[int]: The id of the client.\n        If a single node route is requested, returns a int representing the client's id.\n        Otherwise, returns a dict of [byte , int] where each key contains the address of\n        the queried node and the value contains the client's id.\n    \"\"\"\n    return cast(\n        TClusterResponse[int],\n        await self._execute_command(RequestType.ClientId, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.config_get","title":"<code>config_get(parameters, route=None)</code>  <code>async</code>","text":"<p>Get the values of configuration parameters. See https://valkey.io/commands/config-get/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>List[TEncodable]</code> <p>A list of configuration parameter names to retrieve values for.</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[Dict[bytes, bytes]]</code> <p>TClusterResponse[Dict[bytes, bytes]]: A dictionary of values corresponding to the</p> <code>TClusterResponse[Dict[bytes, bytes]]</code> <p>configuration parameters.</p> <code>TClusterResponse[Dict[bytes, bytes]]</code> <p>When specifying a route other than a single node, response will be : {Address (bytes) : response (Dict[bytes, bytes]) , ... }</p> <code>TClusterResponse[Dict[bytes, bytes]]</code> <p>with type of Dict[bytes, Dict[bytes, bytes]].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n    {b'timeout': b'1000'}\n&gt;&gt;&gt; await client.config_get([\"timeout\" , b\"maxmemory\"])\n    {b'timeout': b'1000', b\"maxmemory\": b\"1GB\"}\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def config_get(\n    self, parameters: List[TEncodable], route: Optional[Route] = None\n) -&gt; TClusterResponse[Dict[bytes, bytes]]:\n    \"\"\"\n    Get the values of configuration parameters.\n    See https://valkey.io/commands/config-get/ for details.\n\n    Args:\n        parameters (List[TEncodable]): A list of configuration parameter names to retrieve values for.\n\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[Dict[bytes, bytes]]: A dictionary of values corresponding to the\n        configuration parameters.\n        When specifying a route other than a single node, response will be : {Address (bytes) : response (Dict[bytes, bytes]) , ... }\n        with type of Dict[bytes, Dict[bytes, bytes]].\n\n    Examples:\n        &gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n            {b'timeout': b'1000'}\n        &gt;&gt;&gt; await client.config_get([\"timeout\" , b\"maxmemory\"])\n            {b'timeout': b'1000', b\"maxmemory\": b\"1GB\"}\n    \"\"\"\n    return cast(\n        TClusterResponse[Dict[bytes, bytes]],\n        await self._execute_command(RequestType.ConfigGet, parameters, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.config_resetstat","title":"<code>config_resetstat(route=None)</code>  <code>async</code>","text":"<p>Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands. See https://valkey.io/commands/config-resetstat/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed automatically to all nodes, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>Returns \"OK\" to confirm that the statistics were successfully reset.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def config_resetstat(\n    self,\n    route: Optional[Route] = None,\n) -&gt; TOK:\n    \"\"\"\n    Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands.\n    See https://valkey.io/commands/config-resetstat/ for details.\n\n    Args:\n        route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        OK: Returns \"OK\" to confirm that the statistics were successfully reset.\n    \"\"\"\n    return cast(\n        TOK, await self._execute_command(RequestType.ConfigResetStat, [], route)\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.config_rewrite","title":"<code>config_rewrite(route=None)</code>  <code>async</code>","text":"<p>Rewrite the configuration file with the current configuration. See https://valkey.io/commands/config-rewrite/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[TRoute]</code> <p>The command will be routed automatically to all nodes, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>OK is returned when the configuration was rewritten properly. Otherwise an error is raised.</p> Example <p>await client.config_rewrite()     'OK'</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def config_rewrite(\n    self,\n    route: Optional[Route] = None,\n) -&gt; TOK:\n    \"\"\"\n    Rewrite the configuration file with the current configuration.\n    See https://valkey.io/commands/config-rewrite/ for details.\n\n    Args:\n        route (Optional[TRoute]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        OK: OK is returned when the configuration was rewritten properly. Otherwise an error is raised.\n\n    Example:\n        &gt;&gt;&gt; await client.config_rewrite()\n            'OK'\n    \"\"\"\n    return cast(\n        TOK, await self._execute_command(RequestType.ConfigRewrite, [], route)\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.config_set","title":"<code>config_set(parameters_map, route=None)</code>  <code>async</code>","text":"<p>Set configuration parameters to the specified values. See https://valkey.io/commands/config-set/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>parameters_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A map consisting of configuration</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all nodes, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>Returns OK if all configurations have been successfully set. Otherwise, raises an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.config_set({\"timeout\": \"1000\", b\"maxmemory\": b\"1GB\"})\n    OK\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def config_set(\n    self,\n    parameters_map: Mapping[TEncodable, TEncodable],\n    route: Optional[Route] = None,\n) -&gt; TOK:\n    \"\"\"\n    Set configuration parameters to the specified values.\n    See https://valkey.io/commands/config-set/ for details.\n\n    Args:\n        parameters_map (Mapping[TEncodable, TEncodable]): A map consisting of configuration\n        parameters and their respective values to set.\n\n        route (Optional[Route]): The command will be routed to all nodes, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        OK: Returns OK if all configurations have been successfully set. Otherwise, raises an error.\n\n    Examples:\n        &gt;&gt;&gt; await client.config_set({\"timeout\": \"1000\", b\"maxmemory\": b\"1GB\"})\n            OK\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in parameters_map.items():\n        parameters.extend(pair)\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.ConfigSet, parameters, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.copy","title":"<code>copy(source, destination, replace=None)</code>  <code>async</code>","text":"<p>Copies the value stored at the <code>source</code> to the <code>destination</code> key. When <code>replace</code> is True, removes the <code>destination</code> key first if it already exists, otherwise performs no action.</p> <p>See https://valkey.io/commands/copy for more details.</p> Note <p>Both <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source value.</p> required <code>destination</code> <code>TEncodable</code> <p>The key where the value should be copied to.</p> required <code>replace</code> <code>Optional[bool]</code> <p>If the destination key should be removed before copying the value to it.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the source was copied. Otherwise, returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n&gt;&gt;&gt; await client.copy(b\"source\", b\"destination\")\n    True # Source was copied\n&gt;&gt;&gt; await client.get(\"destination\")\n    b\"sheep\"\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def copy(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    replace: Optional[bool] = None,\n) -&gt; bool:\n    \"\"\"\n    Copies the value stored at the `source` to the `destination` key. When `replace` is True,\n    removes the `destination` key first if it already exists, otherwise performs no action.\n\n    See https://valkey.io/commands/copy for more details.\n\n    Note:\n        Both `source` and `destination` must map to the same hash slot.\n\n    Args:\n        source (TEncodable): The key to the source value.\n        destination (TEncodable): The key where the value should be copied to.\n        replace (Optional[bool]): If the destination key should be removed before copying the value to it.\n\n    Returns:\n        bool: True if the source was copied. Otherwise, returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n        &gt;&gt;&gt; await client.copy(b\"source\", b\"destination\")\n            True # Source was copied\n        &gt;&gt;&gt; await client.get(\"destination\")\n            b\"sheep\"\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [source, destination]\n    if replace is True:\n        args.append(\"REPLACE\")\n    return cast(\n        bool,\n        await self._execute_command(RequestType.Copy, args),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.custom_command","title":"<code>custom_command(command_args, route=None)</code>  <code>async</code>","text":"<p>Executes a single command, without checking inputs. See the Valkey GLIDE Wiki for details on the restrictions and limitations of the custom command API.</p> <pre><code>@example - Return a list of all pub/sub clients from all nodes:\n\n    connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"], AllNodes())\n</code></pre> <p>Args:     command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.     Every part of the command, including the command name and subcommands, should be added as a separate value in args.     route (Optional[Route]): The command will be routed automatically based on the passed command's default request policy, unless <code>route</code> is provided, in which     case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <p>Returns:</p> Type Description <code>TClusterResponse[TResult]</code> <p>TClusterResponse[TResult]: The returning value depends on the executed command and the route.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def custom_command(\n    self, command_args: List[TEncodable], route: Optional[Route] = None\n) -&gt; TClusterResponse[TResult]:\n    \"\"\"\n    Executes a single command, without checking inputs.\n    See the [Valkey GLIDE Wiki](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#custom-command)\n    for details on the restrictions and limitations of the custom command API.\n\n        @example - Return a list of all pub/sub clients from all nodes:\n\n            connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"], AllNodes())\n    Args:\n        command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.\n        Every part of the command, including the command name and subcommands, should be added as a separate value in args.\n        route (Optional[Route]): The command will be routed automatically based on the passed command's default request policy, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TClusterResponse[TResult]: The returning value depends on the executed command and the route.\n    \"\"\"\n    return cast(\n        TClusterResponse[TResult],\n        await self._execute_command(RequestType.CustomCommand, command_args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.dbsize","title":"<code>dbsize(route=None)</code>  <code>async</code>","text":"<p>Returns the number of keys in the database. See https://valkey.io/commands/dbsize for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primaries, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys in the database.</p> <code>int</code> <p>In the case of routing the query to multiple nodes, returns the aggregated number of keys across the different nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.dbsize()\n    10  # Indicates there are 10 keys in the cluster.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def dbsize(self, route: Optional[Route] = None) -&gt; int:\n    \"\"\"\n    Returns the number of keys in the database.\n    See https://valkey.io/commands/dbsize for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        int: The number of keys in the database.\n        In the case of routing the query to multiple nodes, returns the aggregated number of keys across the different nodes.\n\n    Examples:\n        &gt;&gt;&gt; await client.dbsize()\n            10  # Indicates there are 10 keys in the cluster.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.DBSize, [], route))\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.echo","title":"<code>echo(message, route=None)</code>  <code>async</code>","text":"<p>Echoes the provided <code>message</code> back.</p> <p>See https://valkey.io/commands/echo for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>TEncodable</code> <p>The message to be echoed back.</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[bytes]</code> <p>TClusterResponse[bytes]: The provided <code>message</code>.</p> <code>TClusterResponse[bytes]</code> <p>When specifying a route other than a single node, response will be:</p> <code>TClusterResponse[bytes]</code> <p>{Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.echo(b\"Valkey GLIDE\")\n    b'Valkey GLIDE'\n&gt;&gt;&gt; await client.echo(\"Valkey GLIDE\", AllNodes())\n    {b'addr': b'Valkey GLIDE', b'addr2': b'Valkey GLIDE', b'addr3': b'Valkey GLIDE'}\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def echo(\n    self, message: TEncodable, route: Optional[Route] = None\n) -&gt; TClusterResponse[bytes]:\n    \"\"\"\n    Echoes the provided `message` back.\n\n    See https://valkey.io/commands/echo for more details.\n\n    Args:\n        message (TEncodable): The message to be echoed back.\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[bytes]: The provided `message`.\n        When specifying a route other than a single node, response will be:\n        {Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].\n\n    Examples:\n        &gt;&gt;&gt; await client.echo(b\"Valkey GLIDE\")\n            b'Valkey GLIDE'\n        &gt;&gt;&gt; await client.echo(\"Valkey GLIDE\", AllNodes())\n            {b'addr': b'Valkey GLIDE', b'addr2': b'Valkey GLIDE', b'addr3': b'Valkey GLIDE'}\n    \"\"\"\n    return cast(\n        TClusterResponse[bytes],\n        await self._execute_command(RequestType.Echo, [message], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.exec","title":"<code>exec(transaction, route=None)</code>  <code>async</code>","text":"<p>Execute a transaction by processing the queued commands. See https://valkey.io/docs/topics/transactions/ for details on Transactions.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>ClusterTransaction</code> <p>A <code>ClusterTransaction</code> object containing a list of commands to be executed.</p> required <code>route</code> <code>Optional[TSingleNodeRoute]</code> <p>If <code>route</code> is not provided, the transaction will be routed to the slot owner of the first key found in the transaction. If no key is found, the command will be sent to a random node. If <code>route</code> is provided, the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[TResult]]</code> <p>Optional[List[TResult]]: A list of results corresponding to the execution of each command in the transaction. If a command returns a value, it will be included in the list. If a command doesn't return a value, the list entry will be <code>None</code>. If the transaction failed due to a WATCH command, <code>exec</code> will return <code>None</code>.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def exec(\n    self,\n    transaction: ClusterTransaction,\n    route: Optional[TSingleNodeRoute] = None,\n) -&gt; Optional[List[TResult]]:\n    \"\"\"\n    Execute a transaction by processing the queued commands.\n    See https://valkey.io/docs/topics/transactions/ for details on Transactions.\n\n    Args:\n        transaction (ClusterTransaction): A `ClusterTransaction` object containing a list of commands to be executed.\n        route (Optional[TSingleNodeRoute]): If `route` is not provided, the transaction will be routed to the slot owner of the\n            first key found in the transaction. If no key is found, the command will be sent to a random node.\n            If `route` is provided, the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        Optional[List[TResult]]: A list of results corresponding to the execution of each command\n            in the transaction. If a command returns a value, it will be included in the list. If a command\n            doesn't return a value, the list entry will be `None`.\n            If the transaction failed due to a WATCH command, `exec` will return `None`.\n    \"\"\"\n    commands = transaction.commands[:]\n    return await self._execute_transaction(commands, route)\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.fcall_ro_route","title":"<code>fcall_ro_route(function, arguments=None, route=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded read-only function.</p> <p>See https://valkey.io/commands/fcall_ro for more details.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>TEncodable</code> <p>The function name.</p> required <code>arguments</code> <code>List[TEncodable]</code> <p>An <code>array</code> of <code>function</code> arguments. <code>arguments</code> should not represent names of keys.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>Specifies the routing configuration of the command. The client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[TResult]</code> <p>TClusterResponse[TResult]: The return value depends on the function that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.fcall_ro_route(\"Deep_Thought\", ALL_NODES)\n    42 # The return value on the function that was executed\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def fcall_ro_route(\n    self,\n    function: TEncodable,\n    arguments: Optional[List[TEncodable]] = None,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[TResult]:\n    \"\"\"\n    Invokes a previously loaded read-only function.\n\n    See https://valkey.io/commands/fcall_ro for more details.\n\n    Args:\n        function (TEncodable): The function name.\n        arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n            represent names of keys.\n        route (Optional[Route]): Specifies the routing configuration of the command. The client\n            will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[TResult]: The return value depends on the function that was executed.\n\n    Examples:\n        &gt;&gt;&gt; await client.fcall_ro_route(\"Deep_Thought\", ALL_NODES)\n            42 # The return value on the function that was executed\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [function, \"0\"]\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TClusterResponse[TResult],\n        await self._execute_command(RequestType.FCallReadOnly, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.fcall_route","title":"<code>fcall_route(function, arguments=None, route=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded function. See https://valkey.io/commands/fcall/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>TEncodable</code> <p>The function name.</p> required <code>arguments</code> <code>Optional[List[TEncodable]]</code> <p>A list of <code>function</code> arguments. <code>Arguments</code> should not represent names of keys.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random primary node, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[TResult]</code> <p>TClusterResponse[TResult]: If a single node route is requested, returns a Optional[TResult] representing the function's return value. Otherwise, returns a dict of [bytes , Optional[TResult]] where each key contains the address of the queried node and the value contains the function's return value.</p> Example <p>await client.fcall(\"Deep_Thought\", [\"Answer\", \"to\", \"the\", \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"], RandomNode())     b'new_value' # Returns the function's return value.</p> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def fcall_route(\n    self,\n    function: TEncodable,\n    arguments: Optional[List[TEncodable]] = None,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[TResult]:\n    \"\"\"\n    Invokes a previously loaded function.\n    See https://valkey.io/commands/fcall/ for more details.\n\n    Args:\n        function (TEncodable): The function name.\n        arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n            should not represent names of keys.\n        route (Optional[Route]): The command will be routed to a random primary node, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TClusterResponse[TResult]:\n            If a single node route is requested, returns a Optional[TResult] representing the function's return value.\n            Otherwise, returns a dict of [bytes , Optional[TResult]] where each key contains the address of\n            the queried node and the value contains the function's return value.\n\n    Example:\n        &gt;&gt;&gt; await client.fcall(\"Deep_Thought\", [\"Answer\", \"to\", \"the\", \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"], RandomNode())\n            b'new_value' # Returns the function's return value.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [function, \"0\"]\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TClusterResponse[TResult],\n        await self._execute_command(RequestType.FCall, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.flushall","title":"<code>flushall(flush_mode=None, route=None)</code>  <code>async</code>","text":"<p>Deletes all the keys of all the existing databases. This command never fails.</p> <p>See https://valkey.io/commands/flushall for more details.</p> <p>Parameters:</p> Name Type Description Default <code>flush_mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n    OK  # This command never fails.\n&gt;&gt;&gt; await client.flushall(FlushMode.ASYNC, AllNodes())\n    OK  # This command never fails.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def flushall(\n    self, flush_mode: Optional[FlushMode] = None, route: Optional[Route] = None\n) -&gt; TOK:\n    \"\"\"\n    Deletes all the keys of all the existing databases. This command never fails.\n\n    See https://valkey.io/commands/flushall for more details.\n\n    Args:\n        flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n            OK  # This command never fails.\n        &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC, AllNodes())\n            OK  # This command never fails.\n    \"\"\"\n    args: List[TEncodable] = []\n    if flush_mode is not None:\n        args.append(flush_mode.value)\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.FlushAll, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.flushdb","title":"<code>flushdb(flush_mode=None, route=None)</code>  <code>async</code>","text":"<p>Deletes all the keys of the currently selected database. This command never fails.</p> <p>See https://valkey.io/commands/flushdb for more details.</p> <p>Parameters:</p> Name Type Description Default <code>flush_mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.flushdb()\n    OK  # The keys of the currently selected database were deleted.\n&gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n    OK  # The keys of the currently selected database were deleted asynchronously.\n&gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC, AllNodes())\n    OK  # The keys of the currently selected database were deleted asynchronously on all nodes.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def flushdb(\n    self, flush_mode: Optional[FlushMode] = None, route: Optional[Route] = None\n) -&gt; TOK:\n    \"\"\"\n    Deletes all the keys of the currently selected database. This command never fails.\n\n    See https://valkey.io/commands/flushdb for more details.\n\n    Args:\n        flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.flushdb()\n            OK  # The keys of the currently selected database were deleted.\n        &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n            OK  # The keys of the currently selected database were deleted asynchronously.\n        &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC, AllNodes())\n            OK  # The keys of the currently selected database were deleted asynchronously on all nodes.\n    \"\"\"\n    args: List[TEncodable] = []\n    if flush_mode is not None:\n        args.append(flush_mode.value)\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.FlushDB, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_delete","title":"<code>function_delete(library_name, route=None)</code>  <code>async</code>","text":"<p>Deletes a library and all its functions.</p> <p>See https://valkey.io/commands/function-delete/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>library_code</code> <code>TEncodable</code> <p>The library name to delete</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primaries, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_delete(\"my_lib\")\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_delete(\n    self, library_name: TEncodable, route: Optional[Route] = None\n) -&gt; TOK:\n    \"\"\"\n    Deletes a library and all its functions.\n\n    See https://valkey.io/commands/function-delete/ for more details.\n\n    Args:\n        library_code (TEncodable): The library name to delete\n        route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_delete(\"my_lib\")\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.FunctionDelete,\n            [library_name],\n            route,\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_dump","title":"<code>function_dump(route=None)</code>  <code>async</code>","text":"<p>Returns the serialized payload of all loaded libraries.</p> <p>See https://valkey.io/commands/function-dump/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[bytes]</code> <p>TClusterResponse[bytes]: The serialized payload of all loaded libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payload = await client.function_dump()\n    # The serialized payload of all loaded libraries. This response can\n    # be used to restore loaded functions on any Valkey instance.\n&gt;&gt;&gt; await client.function_restore(payload)\n    \"OK\" # The serialized dump response was used to restore the libraries.\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_dump(\n    self, route: Optional[Route] = None\n) -&gt; TClusterResponse[bytes]:\n    \"\"\"\n    Returns the serialized payload of all loaded libraries.\n\n    See https://valkey.io/commands/function-dump/ for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to a random node, unless\n            `route` is provided, in which case the client will route the command to the\n            nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[bytes]: The serialized payload of all loaded libraries.\n\n    Examples:\n        &gt;&gt;&gt; payload = await client.function_dump()\n            # The serialized payload of all loaded libraries. This response can\n            # be used to restore loaded functions on any Valkey instance.\n        &gt;&gt;&gt; await client.function_restore(payload)\n            \"OK\" # The serialized dump response was used to restore the libraries.\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TClusterResponse[bytes],\n        await self._execute_command(RequestType.FunctionDump, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_flush","title":"<code>function_flush(mode=None, route=None)</code>  <code>async</code>","text":"<p>Deletes all function libraries.</p> <p>See https://valkey.io/commands/function-flush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primaries, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_flush(\n    self, mode: Optional[FlushMode] = None, route: Optional[Route] = None\n) -&gt; TOK:\n    \"\"\"\n    Deletes all function libraries.\n\n    See https://valkey.io/commands/function-flush/ for more details.\n\n    Args:\n        mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n        route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.FunctionFlush,\n            [mode.value] if mode else [],\n            route,\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_kill","title":"<code>function_kill(route=None)</code>  <code>async</code>","text":"<p>Kills a function that is currently executing. This command only terminates read-only functions.</p> <p>See https://valkey.io/commands/function-kill/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_kill()\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_kill(self, route: Optional[Route] = None) -&gt; TOK:\n    \"\"\"\n    Kills a function that is currently executing.\n    This command only terminates read-only functions.\n\n    See https://valkey.io/commands/function-kill/ for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to all nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_kill()\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.FunctionKill,\n            [],\n            route,\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_list","title":"<code>function_list(library_name_pattern=None, with_code=False, route=None)</code>  <code>async</code>","text":"<pre><code>   Returns information about the functions and libraries.\n\n   See https://valkey.io/commands/function-list/ for more details.\n\n   Args:\n       library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n       with_code (bool): Specifies whether to request the library code from the server or not.\n       route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n           in which case the client will route the command to the nodes defined by `route`.\n\n   Returns:\n       TClusterResponse[TFunctionListResponse]: Info\n       about all or selected libraries and their functions.\n\n   Examples:\n       &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n           [{\n               b\"library_name\": b\"myLib5_backup\",\n               b\"engine\": b\"LUA\",\n               b\"functions\": [{\n                   b\"name\": b\"myfunc\",\n                   b\"description\": None,\n                   b\"flags\": {b\"no-writes\"},\n               }],\n               b\"library_code\": b\"#!lua name=mylib\n</code></pre> <p>redis.register_function('myfunc', function(keys, args) return args[1] end)\"                }]</p> <pre><code>   Since: Valkey 7.0.0.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_list(\n    self,\n    library_name_pattern: Optional[TEncodable] = None,\n    with_code: bool = False,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[TFunctionListResponse]:\n    \"\"\"\n    Returns information about the functions and libraries.\n\n    See https://valkey.io/commands/function-list/ for more details.\n\n    Args:\n        library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n        with_code (bool): Specifies whether to request the library code from the server or not.\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[TFunctionListResponse]: Info\n        about all or selected libraries and their functions.\n\n    Examples:\n        &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n            [{\n                b\"library_name\": b\"myLib5_backup\",\n                b\"engine\": b\"LUA\",\n                b\"functions\": [{\n                    b\"name\": b\"myfunc\",\n                    b\"description\": None,\n                    b\"flags\": {b\"no-writes\"},\n                }],\n                b\"library_code\": b\"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n            }]\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    args = []\n    if library_name_pattern is not None:\n        args.extend([\"LIBRARYNAME\", library_name_pattern])\n    if with_code:\n        args.append(\"WITHCODE\")\n    return cast(\n        TClusterResponse[TFunctionListResponse],\n        await self._execute_command(\n            RequestType.FunctionList,\n            args,\n            route,\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_load","title":"<code>function_load(library_code, replace=False, route=None)</code>  <code>async</code>","text":"<pre><code>   Loads a library to Valkey.\n\n   See https://valkey.io/commands/function-load/ for more details.\n\n   Args:\n       library_code (TEncodable): The source code that implements the library.\n       replace (bool): Whether the given library should overwrite a library with the same name if\n           it already exists.\n       route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n           in which case the client will route the command to the nodes defined by `route`.\n\n   Returns:\n       bytes: The library name that was loaded.\n\n   Examples:\n       &gt;&gt;&gt; code = \"#!lua name=mylib\n</code></pre> <p>redis.register_function('myfunc', function(keys, args) return args[1] end)\"            &gt;&gt;&gt; await client.function_load(code, True, RandomNode())                b\"mylib\"</p> <pre><code>   Since: Valkey 7.0.0.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_load(\n    self,\n    library_code: TEncodable,\n    replace: bool = False,\n    route: Optional[Route] = None,\n) -&gt; bytes:\n    \"\"\"\n    Loads a library to Valkey.\n\n    See https://valkey.io/commands/function-load/ for more details.\n\n    Args:\n        library_code (TEncodable): The source code that implements the library.\n        replace (bool): Whether the given library should overwrite a library with the same name if\n            it already exists.\n        route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        bytes: The library name that was loaded.\n\n    Examples:\n        &gt;&gt;&gt; code = \"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n        &gt;&gt;&gt; await client.function_load(code, True, RandomNode())\n            b\"mylib\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        bytes,\n        await self._execute_command(\n            RequestType.FunctionLoad,\n            [\"REPLACE\", library_code] if replace else [library_code],\n            route,\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_restore","title":"<code>function_restore(payload, policy=None, route=None)</code>  <code>async</code>","text":"<p>Restores libraries from the serialized payload returned by the <code>function_dump</code> command.</p> <p>See https://valkey.io/commands/function-restore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>The serialized data from the <code>function_dump</code> command.</p> required <code>policy</code> <code>Optional[FunctionRestorePolicy]</code> <p>A policy for handling existing libraries.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be sent to all primaries, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>OK.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payload = await client.function_dump()\n    # The serialized payload of all loaded libraries. This response can\n    # be used to restore loaded functions on any Valkey instance.\n&gt;&gt;&gt; await client.function_restore(payload, AllPrimaries())\n    \"OK\" # The serialized dump response was used to restore the libraries with the specified route.\n&gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH, AllPrimaries())\n    \"OK\" # The serialized dump response was used to restore the libraries with the specified route and policy.\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_restore(\n    self,\n    payload: TEncodable,\n    policy: Optional[FunctionRestorePolicy] = None,\n    route: Optional[Route] = None,\n) -&gt; TOK:\n    \"\"\"\n    Restores libraries from the serialized payload returned by the `function_dump` command.\n\n    See https://valkey.io/commands/function-restore/ for more details.\n\n    Args:\n        payload (bytes): The serialized data from the `function_dump` command.\n        policy (Optional[FunctionRestorePolicy]): A policy for handling existing libraries.\n        route (Optional[Route]): The command will be sent to all primaries, unless\n            `route` is provided, in which case the client will route the command to the\n            nodes defined by `route`.\n\n    Returns:\n        TOK: OK.\n\n    Examples:\n        &gt;&gt;&gt; payload = await client.function_dump()\n            # The serialized payload of all loaded libraries. This response can\n            # be used to restore loaded functions on any Valkey instance.\n        &gt;&gt;&gt; await client.function_restore(payload, AllPrimaries())\n            \"OK\" # The serialized dump response was used to restore the libraries with the specified route.\n        &gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH, AllPrimaries())\n            \"OK\" # The serialized dump response was used to restore the libraries with the specified route and policy.\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [payload]\n    if policy is not None:\n        args.append(policy.value)\n\n    return cast(\n        TOK, await self._execute_command(RequestType.FunctionRestore, args, route)\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.function_stats","title":"<code>function_stats(route=None)</code>  <code>async</code>","text":"<p>Returns information about the function that's currently running and information about the available execution engines.</p> <p>See https://valkey.io/commands/function-stats/ for more details</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed automatically to all nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[TFunctionStatsSingleNodeResponse]</code> <p>TClusterResponse[TFunctionStatsSingleNodeResponse]: A <code>Mapping</code> with two keys: - <code>running_script</code> with information about the running script. - <code>engines</code> with information about available engines and their stats. See example for more details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_stats(RandomNode())\n    {\n        'running_script': {\n            'name': 'foo',\n            'command': ['FCALL', 'foo', '0', 'hello'],\n            'duration_ms': 7758\n        },\n        'engines': {\n            'LUA': {\n                'libraries_count': 1,\n                'functions_count': 1,\n            }\n        }\n    }\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def function_stats(\n    self, route: Optional[Route] = None\n) -&gt; TClusterResponse[TFunctionStatsSingleNodeResponse]:\n    \"\"\"\n    Returns information about the function that's currently running and information about the\n    available execution engines.\n\n    See https://valkey.io/commands/function-stats/ for more details\n\n    Args:\n        route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TClusterResponse[TFunctionStatsSingleNodeResponse]: A `Mapping` with two keys:\n            - `running_script` with information about the running script.\n            - `engines` with information about available engines and their stats.\n            See example for more details.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_stats(RandomNode())\n            {\n                'running_script': {\n                    'name': 'foo',\n                    'command': ['FCALL', 'foo', '0', 'hello'],\n                    'duration_ms': 7758\n                },\n                'engines': {\n                    'LUA': {\n                        'libraries_count': 1,\n                        'functions_count': 1,\n                    }\n                }\n            }\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(\n        TClusterResponse[TFunctionStatsSingleNodeResponse],\n        await self._execute_command(RequestType.FunctionStats, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.info","title":"<code>info(sections=None, route=None)</code>  <code>async</code>","text":"<p>Get information and statistics about the server. See https://valkey.io/commands/info/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>Optional[List[InfoSection]]</code> <p>A list of InfoSection values specifying which sections of</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primaries, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[bytes]</code> <p>TClusterResponse[bytes]: If a single node route is requested, returns a bytes string containing the information for</p> <code>TClusterResponse[bytes]</code> <p>the required sections. Otherwise, returns a dict of bytes strings, with each key containing the address of</p> <code>TClusterResponse[bytes]</code> <p>the queried node and value containing the information regarding the requested sections.</p> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def info(\n    self,\n    sections: Optional[List[InfoSection]] = None,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[bytes]:\n    \"\"\"\n    Get information and statistics about the server.\n    See https://valkey.io/commands/info/ for details.\n\n    Args:\n        sections (Optional[List[InfoSection]]): A list of InfoSection values specifying which sections of\n        information to retrieve. When no parameter is provided, the default option is assumed.\n        route (Optional[Route]): The command will be routed to all primaries, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TClusterResponse[bytes]: If a single node route is requested, returns a bytes string containing the information for\n        the required sections. Otherwise, returns a dict of bytes strings, with each key containing the address of\n        the queried node and value containing the information regarding the requested sections.\n    \"\"\"\n    args: List[TEncodable] = (\n        [section.value for section in sections] if sections else []\n    )\n    return cast(\n        TClusterResponse[bytes],\n        await self._execute_command(RequestType.Info, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.invoke_script","title":"<code>invoke_script(script, keys=None, args=None)</code>  <code>async</code>","text":"<p>Invokes a Lua script with its keys and arguments. This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script. The script loading, argument preparation, and execution will all be handled internally. If the script has not already been loaded, it will be loaded automatically using the <code>SCRIPT LOAD</code> command. After that, it will be invoked using the <code>EVALSHA</code> command.</p> <p>When in cluster mode, <code>key</code>s must map to the same hash slot.</p> <p>See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>Script</code> <p>The Lua script to execute.</p> required <code>keys</code> <code>Optional[List[TEncodable]]</code> <p>The keys that are used in the script. To ensure the correct execution of the script, all names of keys that a script accesses must be explicitly provided as <code>keys</code>.</p> <code>None</code> <code>args</code> <code>Optional[List[TEncodable]]</code> <p>The non-key arguments for the script.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TClusterResponse[TResult]</code> <p>a value that depends on the script that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n&gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n    [b\"foo\", b\"bar\"]\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def invoke_script(\n    self,\n    script: Script,\n    keys: Optional[List[TEncodable]] = None,\n    args: Optional[List[TEncodable]] = None,\n) -&gt; TClusterResponse[TResult]:\n    \"\"\"\n    Invokes a Lua script with its keys and arguments.\n    This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script.\n    The script loading, argument preparation, and execution will all be handled internally.\n    If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n    After that, it will be invoked using the `EVALSHA` command.\n\n    When in cluster mode, `key`s must map to the same hash slot.\n\n    See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n    Args:\n        script (Script): The Lua script to execute.\n        keys (Optional[List[TEncodable]]): The keys that are used in the script. To ensure the correct execution of\n            the script, all names of keys that a script accesses must be explicitly provided as `keys`.\n        args (Optional[List[TEncodable]]): The non-key arguments for the script.\n\n    Returns:\n        TResult: a value that depends on the script that was executed.\n\n    Examples:\n        &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n        &gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n            [b\"foo\", b\"bar\"]\n    \"\"\"\n    return await self._execute_script(script.get_hash(), keys, args)\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.invoke_script_route","title":"<code>invoke_script_route(script, args=None, route=None)</code>  <code>async</code>","text":"<p>Invokes a Lua script with its arguments and route. This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script. The script loading, argument preparation, and execution will all be handled internally. If the script has not already been loaded, it will be loaded automatically using the <code>SCRIPT LOAD</code> command. After that, it will be invoked using the <code>EVALSHA</code> command.</p> <p>See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>Script</code> <p>The Lua script to execute.</p> required <code>args</code> <code>Optional[List[TEncodable]]</code> <p>The non-key arguments for the script.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed automatically to a random node, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TClusterResponse[TResult]</code> <p>a value that depends on the script that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lua_script = Script(\"return { ARGV[1] }\")\n&gt;&gt;&gt; await invoke_script(lua_script, args=[\"bar\"], route=AllPrimaries());\n    [b\"bar\"]\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def invoke_script_route(\n    self,\n    script: Script,\n    args: Optional[List[TEncodable]] = None,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[TResult]:\n    \"\"\"\n    Invokes a Lua script with its arguments and route.\n    This method simplifies the process of invoking scripts on a server by using an object that represents a Lua script.\n    The script loading, argument preparation, and execution will all be handled internally.\n    If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n    After that, it will be invoked using the `EVALSHA` command.\n\n    See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n    Args:\n        script (Script): The Lua script to execute.\n        args (Optional[List[TEncodable]]): The non-key arguments for the script.\n        route (Optional[Route]): The command will be routed automatically to a random node, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TResult: a value that depends on the script that was executed.\n\n    Examples:\n        &gt;&gt;&gt; lua_script = Script(\"return { ARGV[1] }\")\n        &gt;&gt;&gt; await invoke_script(lua_script, args=[\"bar\"], route=AllPrimaries());\n            [b\"bar\"]\n    \"\"\"\n    return await self._execute_script(\n        script.get_hash(), keys=None, args=args, route=route\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.lastsave","title":"<code>lastsave(route=None)</code>  <code>async</code>","text":"<p>Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.</p> <p>See https://valkey.io/commands/lastsave for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[int]</code> <p>TClusterResponse[int]: The Unix time of the last successful DB save. If no route is provided, or a single node route is requested, returns an int representing the Unix time of the last successful DB save. Otherwise, returns a dict of [bytes , int] where each key contains the address of the queried node and the value contains the Unix time of the last successful DB save.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lastsave()\n    1710925775  # Unix time of the last DB save\n&gt;&gt;&gt; await client.lastsave(AllNodes())\n    {b'addr1': 1710925775, b'addr2': 1710925775, b'addr3': 1710925775}  # Unix time of the last DB save on each node\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def lastsave(self, route: Optional[Route] = None) -&gt; TClusterResponse[int]:\n    \"\"\"\n    Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.\n\n    See https://valkey.io/commands/lastsave for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[int]: The Unix time of the last successful DB save.\n            If no route is provided, or a single node route is requested, returns an int representing the Unix time\n            of the last successful DB save. Otherwise, returns a dict of [bytes , int] where each key contains the\n            address of the queried node and the value contains the Unix time of the last successful DB save.\n\n    Examples:\n        &gt;&gt;&gt; await client.lastsave()\n            1710925775  # Unix time of the last DB save\n        &gt;&gt;&gt; await client.lastsave(AllNodes())\n            {b'addr1': 1710925775, b'addr2': 1710925775, b'addr3': 1710925775}  # Unix time of the last DB save on each node\n    \"\"\"\n    return cast(\n        TClusterResponse[int],\n        await self._execute_command(RequestType.LastSave, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.lolwut","title":"<code>lolwut(version=None, parameters=None, route=None)</code>  <code>async</code>","text":"<p>Displays a piece of generative computer art and the Valkey version.</p> <p>See https://valkey.io/commands/lolwut for more details.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Optional[int]</code> <p>Version of computer art to generate.</p> <code>None</code> <code>parameters</code> <code>Optional[List[int]]</code> <p>Additional set of arguments in order to change the output: For version <code>5</code>, those are length of the line, number of squares per row, and number of squares per column. For version <code>6</code>, those are number of columns and number of lines.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[bytes]</code> <p>TClusterResponse[bytes]: A piece of generative computer art along with the current Valkey version.</p> <code>TClusterResponse[bytes]</code> <p>When specifying a route other than a single node, response will be:</p> <code>TClusterResponse[bytes]</code> <p>{Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lolwut(6, [40, 20], RandomNode());\n    b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def lolwut(\n    self,\n    version: Optional[int] = None,\n    parameters: Optional[List[int]] = None,\n    route: Optional[Route] = None,\n) -&gt; TClusterResponse[bytes]:\n    \"\"\"\n    Displays a piece of generative computer art and the Valkey version.\n\n    See https://valkey.io/commands/lolwut for more details.\n\n    Args:\n        version (Optional[int]): Version of computer art to generate.\n        parameters (Optional[List[int]]): Additional set of arguments in order to change the output:\n            For version `5`, those are length of the line, number of squares per row, and number of squares per column.\n            For version `6`, those are number of columns and number of lines.\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[bytes]: A piece of generative computer art along with the current Valkey version.\n        When specifying a route other than a single node, response will be:\n        {Address (bytes) : response (bytes) , ... } with type of Dict[bytes, bytes].\n\n    Examples:\n        &gt;&gt;&gt; await client.lolwut(6, [40, 20], RandomNode());\n            b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n    \"\"\"\n    args: List[TEncodable] = []\n    if version is not None:\n        args.extend([\"VERSION\", str(version)])\n    if parameters:\n        for var in parameters:\n            args.extend(str(var))\n    return cast(\n        TClusterResponse[bytes],\n        await self._execute_command(RequestType.Lolwut, args, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.ping","title":"<code>ping(message=None, route=None)</code>  <code>async</code>","text":"<p>Ping the server. See https://valkey.io/commands/ping/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[TEncodable]</code> <p>An optional message to include in the PING command. If not provided,</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be sent to all primaries, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>b'PONG' if <code>message</code> is not provided, otherwise return a copy of <code>message</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ping()\n    b\"PONG\"\n&gt;&gt;&gt; await client.ping(\"Hello\")\n    b\"Hello\"\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def ping(\n    self, message: Optional[TEncodable] = None, route: Optional[Route] = None\n) -&gt; bytes:\n    \"\"\"\n    Ping the server.\n    See https://valkey.io/commands/ping/ for more details.\n\n    Args:\n        message (Optional[TEncodable]): An optional message to include in the PING command. If not provided,\n        the server will respond with b\"PONG\". If provided, the server will respond with a copy of the message.\n\n        route (Optional[Route]): The command will be sent to all primaries, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`\n\n    Returns:\n       bytes: b'PONG' if `message` is not provided, otherwise return a copy of `message`.\n\n    Examples:\n        &gt;&gt;&gt; await client.ping()\n            b\"PONG\"\n        &gt;&gt;&gt; await client.ping(\"Hello\")\n            b\"Hello\"\n    \"\"\"\n    argument = [] if message is None else [message]\n    return cast(\n        bytes, await self._execute_command(RequestType.Ping, argument, route)\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.publish","title":"<code>publish(message, channel, sharded=False)</code>  <code>async</code>","text":"<p>Publish a message on pubsub channel. This command aggregates PUBLISH and SPUBLISH commands functionalities. The mode is selected using the 'sharded' parameter. For both sharded and non-sharded mode, request is routed using hashed channel as key. See https://valkey.io/commands/publish and https://valkey.io/commands/spublish for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>TEncodable</code> <p>Message to publish.</p> required <code>channel</code> <code>TEncodable</code> <p>Channel to publish the message on.</p> required <code>sharded</code> <code>bool</code> <p>Use sharded pubsub mode. Available since Valkey version 7.0.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of subscriptions in that node that received the message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\", False)\n    1  # Published 1 instance of \"Hi all!\" message on global-channel channel using non-sharded mode\n&gt;&gt;&gt; await client.publish(b\"Hi to sharded channel1!\", b\"channel1\", True)\n    2  # Published 2 instances of \"Hi to sharded channel1!\" message on channel1 using sharded mode\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def publish(\n    self,\n    message: TEncodable,\n    channel: TEncodable,\n    sharded: bool = False,\n) -&gt; int:\n    \"\"\"\n    Publish a message on pubsub channel.\n    This command aggregates PUBLISH and SPUBLISH commands functionalities.\n    The mode is selected using the 'sharded' parameter.\n    For both sharded and non-sharded mode, request is routed using hashed channel as key.\n    See https://valkey.io/commands/publish and https://valkey.io/commands/spublish for more details.\n\n    Args:\n        message (TEncodable): Message to publish.\n        channel (TEncodable): Channel to publish the message on.\n        sharded (bool): Use sharded pubsub mode. Available since Valkey version 7.0.\n\n    Returns:\n        int: Number of subscriptions in that node that received the message.\n\n    Examples:\n        &gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\", False)\n            1  # Published 1 instance of \"Hi all!\" message on global-channel channel using non-sharded mode\n        &gt;&gt;&gt; await client.publish(b\"Hi to sharded channel1!\", b\"channel1\", True)\n            2  # Published 2 instances of \"Hi to sharded channel1!\" message on channel1 using sharded mode\n    \"\"\"\n    result = await self._execute_command(\n        RequestType.SPublish if sharded else RequestType.Publish, [channel, message]\n    )\n    return cast(int, result)\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.pubsub_shardchannels","title":"<code>pubsub_shardchannels(pattern=None)</code>  <code>async</code>","text":"<p>Lists the currently active shard channels. The command is routed to all nodes, and aggregates the response to a single array.</p> <p>See https://valkey.io/commands/pubsub-shardchannels for more details.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>Optional[TEncodable]</code> <p>A glob-style pattern to match active shard channels.                 If not provided, all active shard channels are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of currently active shard channels matching the given pattern.     If no pattern is specified, all active shard channels are returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_shardchannels()\n    [b'channel1', b'channel2']\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_shardchannels(\"channel*\")\n    [b'channel1', b'channel2']\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def pubsub_shardchannels(\n    self, pattern: Optional[TEncodable] = None\n) -&gt; List[bytes]:\n    \"\"\"\n    Lists the currently active shard channels.\n    The command is routed to all nodes, and aggregates the response to a single array.\n\n    See https://valkey.io/commands/pubsub-shardchannels for more details.\n\n    Args:\n        pattern (Optional[TEncodable]): A glob-style pattern to match active shard channels.\n                            If not provided, all active shard channels are returned.\n\n    Returns:\n        List[bytes]: A list of currently active shard channels matching the given pattern.\n                If no pattern is specified, all active shard channels are returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_shardchannels()\n            [b'channel1', b'channel2']\n\n        &gt;&gt;&gt; await client.pubsub_shardchannels(\"channel*\")\n            [b'channel1', b'channel2']\n    \"\"\"\n    command_args = [pattern] if pattern is not None else []\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.PubSubSChannels, command_args),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.pubsub_shardnumsub","title":"<code>pubsub_shardnumsub(channels=None)</code>  <code>async</code>","text":"<p>Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified shard channels.</p> <p>Note that it is valid to call this command without channels. In this case, it will just return an empty map. The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.</p> <p>See https://valkey.io/commands/pubsub-shardnumsub for more details.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[List[TEncodable]]</code> <p>The list of shard channels to query for the number of subscribers.                             If not provided, returns an empty map.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, int]</code> <p>Mapping[bytes, int]: A map where keys are the shard channel names and values are the number of subscribers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_shardnumsub([\"channel1\", \"channel2\"])\n    {b'channel1': 3, b'channel2': 5}\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_shardnumsub()\n    {}\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def pubsub_shardnumsub(\n    self, channels: Optional[List[TEncodable]] = None\n) -&gt; Mapping[bytes, int]:\n    \"\"\"\n    Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified shard channels.\n\n    Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n    The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n    See https://valkey.io/commands/pubsub-shardnumsub for more details.\n\n    Args:\n        channels (Optional[List[TEncodable]]): The list of shard channels to query for the number of subscribers.\n                                        If not provided, returns an empty map.\n\n    Returns:\n        Mapping[bytes, int]: A map where keys are the shard channel names and values are the number of subscribers.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_shardnumsub([\"channel1\", \"channel2\"])\n            {b'channel1': 3, b'channel2': 5}\n\n        &gt;&gt;&gt; await client.pubsub_shardnumsub()\n            {}\n    \"\"\"\n    return cast(\n        Mapping[bytes, int],\n        await self._execute_command(\n            RequestType.PubSubSNumSub, channels if channels else []\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.random_key","title":"<code>random_key(route=None)</code>  <code>async</code>","text":"<p>Returns a random existing key name.</p> <p>See https://valkey.io/commands/randomkey for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random existing key name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.random_key()\n    b\"random_key_name\"  # \"random_key_name\" is a random existing key name.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def random_key(self, route: Optional[Route] = None) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random existing key name.\n\n    See https://valkey.io/commands/randomkey for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        Optional[bytes]: A random existing key name.\n\n    Examples:\n        &gt;&gt;&gt; await client.random_key()\n            b\"random_key_name\"  # \"random_key_name\" is a random existing key name.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.RandomKey, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.scan","title":"<code>scan(cursor, match=None, count=None, type=None)</code>  <code>async</code>","text":"<p>Incrementally iterates over the keys in the Cluster. The method returns a list containing the next cursor and a list of keys.</p> <p>This command is similar to the SCAN command, but it is designed to work in a Cluster environment. For each iteration the new cursor object should be used to continue the scan. Using the same cursor object for multiple iterations will result in the same keys or unexpected behavior. For more information about the Cluster Scan implementation, see Cluster Scan.</p> <p>As the SCAN command, the method can be used to iterate over the keys in the database, to return all keys the database have from the time the scan started till the scan ends. The same key can be returned in multiple scans iteration.</p> <p>See https://valkey.io/commands/scan/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>ClusterScanCursor</code> <p>The cursor object that wraps the scan state. To start a new scan, create a new empty ClusterScanCursor using ClusterScanCursor().</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>A pattern to match keys against.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>The number of keys to return in a single iteration. The actual number returned can vary and is not guaranteed to match this count exactly. This parameter serves as a hint to the server on the number of steps to perform in each iteration. The default value is 10.</p> <code>None</code> <code>type</code> <code>Optional[ObjectType]</code> <p>The type of object to scan for.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[ClusterScanCursor, List[bytes]]]</code> <p>List[Union[ClusterScanCursor, List[TEncodable]]]: A list containing the next cursor and a list of keys, formatted as [ClusterScanCursor, [key1, key2, ...]].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster.\n    await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n    cursor = ClusterScanCursor()\n    all_keys = []\n    while not cursor.is_finished():\n        cursor, keys = await client.scan(cursor, count=10)\n        all_keys.extend(keys)\n    print(all_keys) # [b'key1', b'key2', b'key3']\n&gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that match the pattern \"*key*\".\n    await client.mset({b\"key1\": b\"value1\", b\"key2\": b\"value2\", b\"not_my_key\": b\"value3\", b\"something_else\": b\"value4\"})\n    cursor = ClusterScanCursor()\n    all_keys = []\n    while not cursor.is_finished():\n        cursor, keys = await client.scan(cursor, match=b\"*key*\", count=10)\n        all_keys.extend(keys)\n    print(all_keys) # [b'my_key1', b'my_key2', b'not_my_key']\n&gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that are of type STRING.\n    await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n    await client.sadd(b\"this_is_a_set\", [b\"value4\"])\n    cursor = ClusterScanCursor()\n    all_keys = []\n    while not cursor.is_finished():\n        cursor, keys = await client.scan(cursor, type=ObjectType.STRING)\n        all_keys.extend(keys)\n    print(all_keys) # [b'key1', b'key2', b'key3']\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def scan(\n    self,\n    cursor: ClusterScanCursor,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    type: Optional[ObjectType] = None,\n) -&gt; List[Union[ClusterScanCursor, List[bytes]]]:\n    \"\"\"\n    Incrementally iterates over the keys in the Cluster.\n    The method returns a list containing the next cursor and a list of keys.\n\n    This command is similar to the SCAN command, but it is designed to work in a Cluster environment.\n    For each iteration the new cursor object should be used to continue the scan.\n    Using the same cursor object for multiple iterations will result in the same keys or unexpected behavior.\n    For more information about the Cluster Scan implementation,\n    see [Cluster Scan](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#cluster-scan).\n\n    As the SCAN command, the method can be used to iterate over the keys in the database,\n    to return all keys the database have from the time the scan started till the scan ends.\n    The same key can be returned in multiple scans iteration.\n\n    See https://valkey.io/commands/scan/ for more details.\n\n    Args:\n        cursor (ClusterScanCursor): The cursor object that wraps the scan state.\n          To start a new scan, create a new empty ClusterScanCursor using ClusterScanCursor().\n        match (Optional[TEncodable]): A pattern to match keys against.\n        count (Optional[int]): The number of keys to return in a single iteration.\n          The actual number returned can vary and is not guaranteed to match this count exactly.\n          This parameter serves as a hint to the server on the number of steps to perform in each iteration.\n          The default value is 10.\n        type (Optional[ObjectType]): The type of object to scan for.\n\n    Returns:\n        List[Union[ClusterScanCursor, List[TEncodable]]]: A list containing the next cursor and a list of keys,\n          formatted as [ClusterScanCursor, [key1, key2, ...]].\n\n    Examples:\n        &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster.\n            await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n            cursor = ClusterScanCursor()\n            all_keys = []\n            while not cursor.is_finished():\n                cursor, keys = await client.scan(cursor, count=10)\n                all_keys.extend(keys)\n            print(all_keys) # [b'key1', b'key2', b'key3']\n        &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that match the pattern \"*key*\".\n            await client.mset({b\"key1\": b\"value1\", b\"key2\": b\"value2\", b\"not_my_key\": b\"value3\", b\"something_else\": b\"value4\"})\n            cursor = ClusterScanCursor()\n            all_keys = []\n            while not cursor.is_finished():\n                cursor, keys = await client.scan(cursor, match=b\"*key*\", count=10)\n                all_keys.extend(keys)\n            print(all_keys) # [b'my_key1', b'my_key2', b'not_my_key']\n        &gt;&gt;&gt; # In the following example, we will iterate over the keys in the cluster that are of type STRING.\n            await client.mset({b'key1': b'value1', b'key2': b'value2', b'key3': b'value3'})\n            await client.sadd(b\"this_is_a_set\", [b\"value4\"])\n            cursor = ClusterScanCursor()\n            all_keys = []\n            while not cursor.is_finished():\n                cursor, keys = await client.scan(cursor, type=ObjectType.STRING)\n                all_keys.extend(keys)\n            print(all_keys) # [b'key1', b'key2', b'key3']\n    \"\"\"\n    return cast(\n        List[Union[ClusterScanCursor, List[bytes]]],\n        await self._cluster_scan(cursor, match, count, type),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.script_exists","title":"<code>script_exists(sha1s, route=None)</code>  <code>async</code>","text":"<p>Check existence of scripts in the script cache by their SHA1 digest.</p> <p>See https://valkey.io/commands/script-exists for more details.</p> <p>Parameters:</p> Name Type Description Default <code>sha1s</code> <code>List[TEncodable]</code> <p>List of SHA1 digests of the scripts to check.</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided, in which</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[List[bool]]</code> <p>TClusterResponse[List[bool]]: A list of boolean values indicating the existence of each script.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n&gt;&gt;&gt; await client.script_exists([lua_script.get_hash(), \"sha1_digest2\"])\n    [True, False]\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def script_exists(\n    self, sha1s: List[TEncodable], route: Optional[Route] = None\n) -&gt; TClusterResponse[List[bool]]:\n    \"\"\"\n    Check existence of scripts in the script cache by their SHA1 digest.\n\n    See https://valkey.io/commands/script-exists for more details.\n\n    Args:\n        sha1s (List[TEncodable]): List of SHA1 digests of the scripts to check.\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided, in which\n        case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TClusterResponse[List[bool]]: A list of boolean values indicating the existence of each script.\n\n    Examples:\n        &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n        &gt;&gt;&gt; await client.script_exists([lua_script.get_hash(), \"sha1_digest2\"])\n            [True, False]\n    \"\"\"\n    return cast(\n        TClusterResponse[List[bool]],\n        await self._execute_command(RequestType.ScriptExists, sha1s, route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.script_flush","title":"<code>script_flush(mode=None, route=None)</code>  <code>async</code>","text":"<p>Flush the Lua scripts cache.</p> <p>See https://valkey.io/commands/script-flush for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed automatically to all nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.script_flush()\n    \"OK\"\n</code></pre> <pre><code>&gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n    \"OK\"\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def script_flush(\n    self, mode: Optional[FlushMode] = None, route: Optional[Route] = None\n) -&gt; TOK:\n    \"\"\"\n    Flush the Lua scripts cache.\n\n    See https://valkey.io/commands/script-flush for more details.\n\n    Args:\n        mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n        route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Returns:\n        TOK: A simple `OK` response.\n\n    Examples:\n        &gt;&gt;&gt; await client.script_flush()\n            \"OK\"\n\n        &gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n            \"OK\"\n    \"\"\"\n\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.ScriptFlush, [mode.value] if mode else [], route\n        ),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.script_kill","title":"<code>script_kill(route=None)</code>  <code>async</code>","text":"<p>Kill the currently executing Lua script, assuming no write operation was yet performed by the script. The command is routed to all nodes, and aggregates the response to a single array.</p> <p>See https://valkey.io/commands/script-kill for more details.</p> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <code>route</code> <code>Optional[Route]</code> <p>The command will be routed automatically to all nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>. Defaults to None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.script_kill()\n    \"OK\"\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def script_kill(self, route: Optional[Route] = None) -&gt; TOK:\n    \"\"\"\n    Kill the currently executing Lua script, assuming no write operation was yet performed by the script.\n    The command is routed to all nodes, and aggregates the response to a single array.\n\n    See https://valkey.io/commands/script-kill for more details.\n\n    Returns:\n        TOK: A simple `OK` response.\n        route (Optional[Route]): The command will be routed automatically to all nodes, unless `route` is provided, in which\n            case the client will route the command to the nodes defined by `route`. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; await client.script_kill()\n            \"OK\"\n    \"\"\"\n    return cast(TOK, await self._execute_command(RequestType.ScriptKill, [], route))\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.time","title":"<code>time(route=None)</code>  <code>async</code>","text":"<p>Returns the server time.</p> <p>See https://valkey.io/commands/time/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to a random node, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Type Description <code>TClusterResponse[List[bytes]]</code> <p>TClusterResponse[Optional[bytes]]:  The current server time as a two items <code>array</code>:</p> <code>TClusterResponse[List[bytes]]</code> <p>A Unix timestamp and the amount of microseconds already elapsed in the current second.</p> <code>TClusterResponse[List[bytes]]</code> <p>The returned <code>array</code> is in a [Unix timestamp, Microseconds already elapsed] format.</p> <code>TClusterResponse[List[bytes]]</code> <p>When specifying a route other than a single node, response will be:</p> <code>TClusterResponse[List[bytes]]</code> <p>{Address (bytes) : response (List[bytes]) , ... } with type of Dict[bytes, List[bytes]].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.time()\n    [b'1710925775', b'913580']\n&gt;&gt;&gt; await client.time(AllNodes())\n    {b'addr': [b'1710925775', b'913580'], b'addr2': [b'1710925775', b'913580'], b'addr3': [b'1710925775', b'913580']}\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def time(\n    self, route: Optional[Route] = None\n) -&gt; TClusterResponse[List[bytes]]:\n    \"\"\"\n    Returns the server time.\n\n    See https://valkey.io/commands/time/ for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to a random node, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TClusterResponse[Optional[bytes]]:  The current server time as a two items `array`:\n        A Unix timestamp and the amount of microseconds already elapsed in the current second.\n        The returned `array` is in a [Unix timestamp, Microseconds already elapsed] format.\n        When specifying a route other than a single node, response will be:\n        {Address (bytes) : response (List[bytes]) , ... } with type of Dict[bytes, List[bytes]].\n\n    Examples:\n        &gt;&gt;&gt; await client.time()\n            [b'1710925775', b'913580']\n        &gt;&gt;&gt; await client.time(AllNodes())\n            {b'addr': [b'1710925775', b'913580'], b'addr2': [b'1710925775', b'913580'], b'addr3': [b'1710925775', b'913580']}\n    \"\"\"\n    return cast(\n        TClusterResponse[List[bytes]],\n        await self._execute_command(RequestType.Time, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.unwatch","title":"<code>unwatch(route=None)</code>  <code>async</code>","text":"<p>Flushes all the previously watched keys for a transaction. Executing a transaction will automatically flush all previously watched keys.</p> <p>See https://valkey.io/commands/unwatch for more details.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided, in which case the client will route the command to the nodes defined by <code>route</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.unwatch()\n    'OK'\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def unwatch(self, route: Optional[Route] = None) -&gt; TOK:\n    \"\"\"\n    Flushes all the previously watched keys for a transaction. Executing a transaction will\n    automatically flush all previously watched keys.\n\n    See https://valkey.io/commands/unwatch for more details.\n\n    Args:\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n            in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.unwatch()\n            'OK'\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.UnWatch, [], route),\n    )\n</code></pre>"},{"location":"python/cluster_commands/#glide.async_commands.cluster_commands.ClusterCommands.wait","title":"<code>wait(numreplicas, timeout, route=None)</code>  <code>async</code>","text":"<p>Blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least <code>numreplicas</code> of replicas. If <code>timeout</code> is reached, the command returns even if the specified number of replicas were not yet reached.</p> <p>See https://valkey.io/commands/wait for more details.</p> <p>Parameters:</p> Name Type Description Default <code>numreplicas</code> <code>int</code> <p>The number of replicas to reach.</p> required <code>timeout</code> <code>int</code> <p>The timeout value specified in milliseconds. A value of 0 will block indefinitely.</p> required <code>route</code> <code>Optional[Route]</code> <p>The command will be routed to all primary nodes, unless <code>route</code> is provided,</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of replicas reached by all the writes performed in the context of the current connection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\");\n&gt;&gt;&gt; await client.wait(1, 1000);\n// return 1 when a replica is reached or 0 if 1000ms is reached.\n</code></pre> Source code in <code>glide/async_commands/cluster_commands.py</code> <pre><code>async def wait(\n    self,\n    numreplicas: int,\n    timeout: int,\n    route: Optional[Route] = None,\n) -&gt; int:\n    \"\"\"\n    Blocks the current client until all the previous write commands are successfully transferred\n    and acknowledged by at least `numreplicas` of replicas. If `timeout` is\n    reached, the command returns even if the specified number of replicas were not yet reached.\n\n    See https://valkey.io/commands/wait for more details.\n\n    Args:\n        numreplicas (int): The number of replicas to reach.\n        timeout (int): The timeout value specified in milliseconds. A value of 0 will block indefinitely.\n        route (Optional[Route]): The command will be routed to all primary nodes, unless `route` is provided,\n        in which case the client will route the command to the nodes defined by `route`.\n\n    Returns:\n        int: The number of replicas reached by all the writes performed in the context of the current connection.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\");\n        &gt;&gt;&gt; await client.wait(1, 1000);\n        // return 1 when a replica is reached or 0 if 1000ms is reached.\n    \"\"\"\n    args: List[TEncodable] = [str(numreplicas), str(timeout)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.Wait, args, route),\n    )\n</code></pre>"},{"location":"python/core/","title":"CoreCommands","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class CoreCommands(Protocol):\n    async def _execute_command(\n        self,\n        request_type: RequestType.ValueType,\n        args: List[TEncodable],\n        route: Optional[Route] = ...,\n    ) -&gt; TResult: ...\n\n    async def _execute_transaction(\n        self,\n        commands: List[Tuple[RequestType.ValueType, List[TEncodable]]],\n        route: Optional[Route] = None,\n    ) -&gt; List[TResult]: ...\n\n    async def _execute_script(\n        self,\n        hash: str,\n        keys: Optional[List[TEncodable]] = None,\n        args: Optional[List[TEncodable]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TResult: ...\n\n    async def _cluster_scan(\n        self,\n        cursor: ClusterScanCursor,\n        match: Optional[TEncodable] = ...,\n        count: Optional[int] = ...,\n        type: Optional[ObjectType] = ...,\n    ) -&gt; TResult: ...\n\n    async def set(\n        self,\n        key: TEncodable,\n        value: TEncodable,\n        conditional_set: Optional[ConditionalChange] = None,\n        expiry: Optional[ExpirySet] = None,\n        return_old_value: bool = False,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Set the given key with the given value. Return value is dependent on the passed options.\n        See https://valkey.io/commands/set/ for more details.\n\n        Args:\n            key (TEncodable): the key to store.\n            value (TEncodable): the value to store with the given key.\n            conditional_set (Optional[ConditionalChange], optional): set the key only if the given condition is met.\n                Equivalent to [`XX` | `NX`] in the Valkey API. Defaults to None.\n            expiry (Optional[ExpirySet], optional): set expiriation to the given key.\n                Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `KEEPTTL`] in the Valkey API. Defaults to None.\n            return_old_value (bool, optional): Return the old value stored at key, or None if key did not exist.\n                An error is returned and SET aborted if the value stored at key is not a string.\n                Equivalent to `GET` in the Valkey API. Defaults to False.\n\n        Returns:\n            Optional[bytes]:\n                If the value is successfully set, return OK.\n                If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None.\n                If return_old_value is set, return the old value as a bytes string.\n\n        Example:\n            &gt;&gt;&gt; await client.set(b\"key\", b\"value\")\n                'OK'\n            &gt;&gt;&gt; await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))\n                'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds.\n            &gt;&gt;&gt; await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)\n                b'new_value' # Returns the old value of \"key\".\n            &gt;&gt;&gt; await client.get(\"key\")\n                b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.\n        \"\"\"\n        args = [key, value]\n        if conditional_set:\n            args.append(conditional_set.value)\n        if return_old_value:\n            args.append(\"GET\")\n        if expiry is not None:\n            args.extend(expiry.get_cmd_args())\n        return cast(Optional[bytes], await self._execute_command(RequestType.Set, args))\n\n    async def get(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Get the value associated with the given key, or null if no such value exists.\n        See https://valkey.io/commands/get/ for details.\n\n        Args:\n            key (TEncodable): The key to retrieve from the database.\n\n        Returns:\n            Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.\n\n        Example:\n            &gt;&gt;&gt; await client.get(\"key\")\n                b'value'\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(Optional[bytes], await self._execute_command(RequestType.Get, args))\n\n    async def getdel(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Gets a value associated with the given string `key` and deletes the key.\n\n        See https://valkey.io/commands/getdel for more details.\n\n        Args:\n            key (TEncodable): The `key` to retrieve from the database.\n\n        Returns:\n            Optional[bytes]: If `key` exists, returns the `value` of `key`. Otherwise, returns `None`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.getdel(\"key\")\n                b'value'\n            &gt;&gt;&gt; await client.getdel(\"key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.GetDel, [key])\n        )\n\n    async def getrange(self, key: TEncodable, start: int, end: int) -&gt; bytes:\n        \"\"\"\n        Returns the substring of the value stored at `key`, determined by the offsets `start` and `end` (both are inclusive).\n        Negative offsets can be used in order to provide an offset starting from the end of the value.\n        So `-1` means the last character, `-2` the penultimate and so forth.\n\n        If `key` does not exist, an empty byte string is returned. If `start` or `end`\n        are out of range, returns the substring within the valid range of the value.\n\n        See https://valkey.io/commands/getrange/ for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            start (int): The starting offset.\n            end (int): The ending offset.\n\n        Returns:\n            bytes: A substring extracted from the value stored at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n            &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n                b\"This\"\n            &gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n                b\"ing\"  # extracted last 3 characters of a string\n            &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n                b\"This is a string\"\n            &gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n                b\"\"\n        \"\"\"\n        return cast(\n            bytes,\n            await self._execute_command(\n                RequestType.GetRange, [key, str(start), str(end)]\n            ),\n        )\n\n    async def append(self, key: TEncodable, value: TEncodable) -&gt; int:\n        \"\"\"\n        Appends a value to a key.\n        If `key` does not exist it is created and set as an empty string, so `APPEND` will be similar to `SET` in this special case.\n\n        See https://valkey.io/commands/append for more details.\n\n        Args:\n            key (TEncodable): The key to which the value will be appended.\n            value (TEncodable): The value to append.\n\n        Returns:\n            int: The length of the stored value after appending `value`.\n\n        Examples:\n            &gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n                5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n            &gt;&gt;&gt; await client.append(\"key\", \" world\")\n                11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n            &gt;&gt;&gt; await client.get(\"key\")\n                b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Append, [key, value]))\n\n    async def strlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Get the length of the string value stored at `key`.\n        See https://valkey.io/commands/strlen/ for more details.\n\n        Args:\n            key (TEncodable): The key to return its length.\n\n        Returns:\n            int: The length of the string value stored at `key`.\n                If `key` does not exist, it is treated as an empty string and 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n            &gt;&gt;&gt; await client.strlen(\"key\")\n                5  # Indicates that the length of the string value stored at `key` is 5.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(int, await self._execute_command(RequestType.Strlen, args))\n\n    async def rename(self, key: TEncodable, new_key: TEncodable) -&gt; TOK:\n        \"\"\"\n        Renames `key` to `new_key`.\n        If `newkey` already exists it is overwritten.\n        See https://valkey.io/commands/rename/ for more details.\n\n        Note:\n            When in cluster mode, both `key` and `newkey` must map to the same hash slot.\n\n        Args:\n            key (TEncodable) : The key to rename.\n            new_key (TEncodable) : The new name of the key.\n\n        Returns:\n            OK: If the `key` was successfully renamed, return \"OK\". If `key` does not exist, an error is thrown.\n        \"\"\"\n        return cast(\n            TOK, await self._execute_command(RequestType.Rename, [key, new_key])\n        )\n\n    async def renamenx(self, key: TEncodable, new_key: TEncodable) -&gt; bool:\n        \"\"\"\n        Renames `key` to `new_key` if `new_key` does not yet exist.\n\n        See https://valkey.io/commands/renamenx for more details.\n\n        Note:\n            When in cluster mode, both `key` and `new_key` must map to the same hash slot.\n\n        Args:\n            key (TEncodable): The key to rename.\n            new_key (TEncodable): The new key name.\n\n        Returns:\n            bool: True if `key` was renamed to `new_key`, or False if `new_key` already exists.\n\n        Examples:\n            &gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n                True  # \"old_key\" was renamed to \"new_key\"\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.RenameNX, [key, new_key]),\n        )\n\n    async def delete(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Delete one or more keys from the database. A key is ignored if it does not exist.\n        See https://valkey.io/commands/del/ for details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): A list of keys to be deleted from the database.\n\n        Returns:\n            int: The number of keys that were deleted.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.delete([\"key\"])\n                1 # Indicates that the key was successfully deleted.\n            &gt;&gt;&gt; await client.delete([\"key\"])\n                0 # No keys we're deleted since \"key\" doesn't exist.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Del, keys))\n\n    async def incr(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Increments the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n        operation.\n        See https://valkey.io/commands/incr/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n\n        Returns:\n            int: The value of `key` after the increment.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incr(\"key\")\n                11\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Incr, [key]))\n\n    async def incrby(self, key: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Increments the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n        the operation. See https://valkey.io/commands/incrby/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n          amount (int) : The amount to increment.\n\n        Returns:\n            int: The value of key after the increment.\n\n        Example:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incrby(\"key\" , 5)\n                15\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.IncrBy, [key, str(amount)])\n        )\n\n    async def incrbyfloat(self, key: TEncodable, amount: float) -&gt; float:\n        \"\"\"\n        Increment the string representing a floating point number stored at `key` by `amount`.\n        By using a negative increment value, the value stored at the `key` is decremented.\n        If the key does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/incrbyfloat/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n          amount (float) : The amount to increment.\n\n        Returns:\n            float: The value of key after the increment.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n                15.55\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(RequestType.IncrByFloat, [key, str(amount)]),\n        )\n\n    async def setrange(self, key: TEncodable, offset: int, value: TEncodable) -&gt; int:\n        \"\"\"\n        Overwrites part of the string stored at `key`, starting at the specified\n        `offset`, for the entire length of `value`.\n        If the `offset` is larger than the current length of the string at `key`,\n        the string is padded with zero bytes to make `offset` fit. Creates the `key`\n        if it doesn't exist.\n\n        See https://valkey.io/commands/setrange for more details.\n\n        Args:\n            key (TEncodable): The key of the string to update.\n            offset (int): The position in the string where `value` should be written.\n            value (TEncodable): The value written with `offset`.\n\n        Returns:\n            int: The length of the string stored at `key` after it was modified.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n            &gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n                11  # The length of the string stored at `key` after it was modified.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.SetRange, [key, str(offset), value]\n            ),\n        )\n\n    async def mset(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n        \"\"\"\n        Set multiple keys to multiple values in a single atomic operation.\n        See https://valkey.io/commands/mset/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when keys in `key_value_map` map to different hash slots.\n\n        Args:\n            key_value_map (Mapping[TEncodable, TEncodable]): A map of key value pairs.\n\n        Returns:\n            OK: a simple OK response.\n\n        Example:\n            &gt;&gt;&gt; await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})\n                'OK'\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in key_value_map.items():\n            parameters.extend(pair)\n        return cast(TOK, await self._execute_command(RequestType.MSet, parameters))\n\n    async def msetnx(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; bool:\n        \"\"\"\n        Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or\n        more keys already exist, the entire operation fails.\n\n        Note:\n            When in cluster mode, all keys in `key_value_map` must map to the same hash slot.\n\n        See https://valkey.io/commands/msetnx/ for more details.\n\n        Args:\n            key_value_map (Mapping[TEncodable, TEncodable]): A key-value map consisting of keys and their respective values to set.\n\n        Returns:\n            bool: True if all keys were set. False if no key was set.\n\n        Examples:\n            &gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n                True\n            &gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n                False\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in key_value_map.items():\n            parameters.extend(pair)\n        return cast(\n            bool,\n            await self._execute_command(RequestType.MSetNX, parameters),\n        )\n\n    async def mget(self, keys: List[TEncodable]) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Retrieve the values of multiple keys.\n        See https://valkey.io/commands/mget/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): A list of keys to retrieve values for.\n\n        Returns:\n            List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,\n            its corresponding value in the list will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n            &gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n            &gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n                [b'value1' , b'value2']\n        \"\"\"\n        return cast(\n            List[Optional[bytes]], await self._execute_command(RequestType.MGet, keys)\n        )\n\n    async def decr(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Decrement the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n        operation.\n        See https://valkey.io/commands/decr/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n\n        Returns:\n            int: The value of key after the decrement.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.decr(\"key\")\n                9\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Decr, [key]))\n\n    async def decrby(self, key: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Decrements the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n        the operation.\n        See https://valkey.io/commands/decrby/ for more details.\n\n        Args:\n          key (TEncodable): The key to decrement its value.\n          amount (int) : The amount to decrement.\n\n        Returns:\n            int: The value of key after the decrement.\n\n        Example:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.decrby(\"key\" , 5)\n                5\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.DecrBy, [key, str(amount)])\n        )\n\n    async def touch(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Updates the last access time of specified keys.\n\n        See https://valkey.io/commands/touch/ for details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The keys to update last access time.\n\n        Returns:\n            int: The number of keys that were updated, a key is ignored if it doesn't exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n            &gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n            &gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n                2  # Last access time of 2 keys has been updated.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Touch, keys))\n\n    async def hset(\n        self,\n        key: TEncodable,\n        field_value_map: Mapping[TEncodable, TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Sets the specified fields to their respective values in the hash stored at `key`.\n        See https://valkey.io/commands/hset/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field_value_map (Mapping[TEncodable, TEncodable]): A field-value map consisting of fields and their corresponding values\n            to be set in the hash stored at the specified key.\n\n        Returns:\n            int: The number of fields that were added to the hash.\n\n        Example:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})\n                2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".\n        \"\"\"\n        field_value_list: List[TEncodable] = [key]\n        for pair in field_value_map.items():\n            field_value_list.extend(pair)\n        return cast(\n            int,\n            await self._execute_command(RequestType.HSet, field_value_list),\n        )\n\n    async def hget(self, key: TEncodable, field: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Retrieves the value associated with `field` in the hash stored at `key`.\n        See https://valkey.io/commands/hget/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field whose value should be retrieved.\n\n        Returns:\n            Optional[bytes]: The value associated `field` in the hash.\n            Returns None if `field` is not presented in the hash or `key` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n            &gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n                b\"value\"\n            &gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.HGet, [key, field]),\n        )\n\n    async def hsetnx(\n        self,\n        key: TEncodable,\n        field: TEncodable,\n        value: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Sets `field` in the hash stored at `key` to `value`, only if `field` does not yet exist.\n        If `key` does not exist, a new key holding a hash is created.\n        If `field` already exists, this operation has no effect.\n        See https://valkey.io/commands/hsetnx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field to set the value for.\n            value (TEncodable): The value to set.\n\n        Returns:\n            bool: True if the field was set, False if the field already existed and was not set.\n\n        Examples:\n            &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n                True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n            &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n                False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.HSetNX, [key, field, value]),\n        )\n\n    async def hincrby(self, key: TEncodable, field: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Increment or decrement the value of a `field` in the hash stored at `key` by the specified amount.\n        By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n        If `field` or `key` does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/hincrby/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n            amount (int): The amount by which to increment or decrement the field's value.\n                Use a negative value to decrement.\n\n        Returns:\n            int: The value of the specified field in the hash stored at `key` after the increment or decrement.\n\n        Examples:\n            &gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n                5\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.HIncrBy, [key, field, str(amount)]),\n        )\n\n    async def hincrbyfloat(\n        self, key: TEncodable, field: TEncodable, amount: float\n    ) -&gt; float:\n        \"\"\"\n        Increment or decrement the floating-point value stored at `field` in the hash stored at `key` by the specified\n        amount.\n        By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n        If `field` or `key` does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/hincrbyfloat/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n            amount (float): The amount by which to increment or decrement the field's value.\n                Use a negative value to decrement.\n\n        Returns:\n            float: The value of the specified field in the hash stored at `key` after the increment as a string.\n\n        Examples:\n            &gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n                \"2.5\"\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(\n                RequestType.HIncrByFloat, [key, field, str(amount)]\n            ),\n        )\n\n    async def hexists(self, key: TEncodable, field: TEncodable) -&gt; bool:\n        \"\"\"\n        Check if a field exists in the hash stored at `key`.\n        See https://valkey.io/commands/hexists/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field to check in the hash stored at `key`.\n\n        Returns:\n            bool: Returns 'True' if the hash contains the specified field. If the hash does not contain the field,\n                or if the key does not exist, it returns 'False'.\n\n        Examples:\n            &gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n                True\n            &gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n                False\n        \"\"\"\n        return cast(\n            bool, await self._execute_command(RequestType.HExists, [key, field])\n        )\n\n    async def hgetall(self, key: TEncodable) -&gt; Dict[bytes, bytes]:\n        \"\"\"\n        Returns all fields and values of the hash stored at `key`.\n        See https://valkey.io/commands/hgetall/ for details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by\n            its value.\n            If `key` does not exist, it returns an empty dictionary.\n\n        Examples:\n            &gt;&gt;&gt; await client.hgetall(\"my_hash\")\n                {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n        \"\"\"\n        return cast(\n            Dict[bytes, bytes], await self._execute_command(RequestType.HGetAll, [key])\n        )\n\n    async def hmget(\n        self, key: TEncodable, fields: List[TEncodable]\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Retrieve the values associated with specified fields in the hash stored at `key`.\n        See https://valkey.io/commands/hmget/ for details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            fields (List[TEncodable]): The list of fields in the hash stored at `key` to retrieve from the database.\n\n        Returns:\n            List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.\n            For every field that does not exist in the hash, a null value is returned.\n            If `key` does not exist, it is treated as an empty hash, and the function returns a list of null values.\n\n        Examples:\n            &gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n                [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n        \"\"\"\n        return cast(\n            List[Optional[bytes]],\n            await self._execute_command(RequestType.HMGet, [key] + fields),\n        )\n\n    async def hdel(self, key: TEncodable, fields: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Remove specified fields from the hash stored at `key`.\n        See https://valkey.io/commands/hdel/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            fields (List[TEncodable]): The list of fields to remove from the hash stored at `key`.\n\n        Returns:\n            int: The number of fields that were removed from the hash, excluding specified but non-existing fields.\n            If `key` does not exist, it is treated as an empty hash, and the function returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n                2  # Indicates that two fields were successfully removed from the hash.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.HDel, [key] + fields))\n\n    async def hlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the number of fields contained in the hash stored at `key`.\n\n        See https://valkey.io/commands/hlen/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            int: The number of fields in the hash, or 0 when the key does not exist.\n            If `key` holds a value that is not a hash, an error is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.hlen(\"my_hash\")\n                3\n            &gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n                0\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.HLen, [key]))\n\n    async def hvals(self, key: TEncodable) -&gt; List[bytes]:\n        \"\"\"\n        Returns all values in the hash stored at `key`.\n\n        See https://valkey.io/commands/hvals/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            List[bytes]: A list of values in the hash, or an empty list when the key does not exist.\n\n        Examples:\n           &gt;&gt;&gt; await client.hvals(\"my_hash\")\n               [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(List[bytes], await self._execute_command(RequestType.HVals, [key]))\n\n    async def hkeys(self, key: TEncodable) -&gt; List[bytes]:\n        \"\"\"\n        Returns all field names in the hash stored at `key`.\n\n        See https://valkey.io/commands/hkeys/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hkeys(\"my_hash\")\n                [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(List[bytes], await self._execute_command(RequestType.HKeys, [key]))\n\n    async def hrandfield(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random field name from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            Optional[bytes]: A random field name from the hash stored at `key`.\n            If the hash does not exist or is empty, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n                b\"field1\"  # A random field name stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.HRandField, [key])\n        )\n\n    async def hrandfield_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieves up to `count` random field names from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            count (int): The number of field names to return.\n                If `count` is positive, returns unique elements.\n                If `count` is negative, allows for duplicates elements.\n\n        Returns:\n            List[bytes]: A list of random field names from the hash.\n            If the hash does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n                [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n            &gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n                []  # Empty list\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.HRandField, [key, str(count)]),\n        )\n\n    async def hrandfield_withvalues(\n        self, key: TEncodable, count: int\n    ) -&gt; List[List[bytes]]:\n        \"\"\"\n        Retrieves up to `count` random field names along with their values from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            count (int): The number of field names to return.\n                If `count` is positive, returns unique elements.\n                If `count` is negative, allows for duplicates elements.\n\n        Returns:\n            List[List[bytes]]: A list of `[field_name, value]` lists, where `field_name` is a random field name from the\n            hash and `value` is the associated value of the field name.\n            If the hash does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n                [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n        \"\"\"\n        return cast(\n            List[List[bytes]],\n            await self._execute_command(\n                RequestType.HRandField, [key, str(count), \"WITHVALUES\"]\n            ),\n        )\n\n    async def hstrlen(self, key: TEncodable, field: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the string length of the value associated with `field` in the hash stored at `key`.\n\n        See https://valkey.io/commands/hstrlen/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash.\n\n        Returns:\n            int: The string length or 0 if `field` or `key` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n            &gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n                5\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.HStrlen, [key, field]),\n        )\n\n    async def lpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Insert all the specified values at the head of the list stored at `key`.\n        `elements` are inserted one after the other to the head of the list, from the leftmost element\n        to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n        See https://valkey.io/commands/lpush/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operations.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n                3 # Indicates that the new length of the list is 3 after the push operation.\n            &gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n                1\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.LPush, [key] + elements)\n        )\n\n    async def lpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the head of the list stored at `key`, only if `key` exists and holds a list.\n        If `key` is not a list, this performs no operation.\n\n        See https://valkey.io/commands/lpushx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operation.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n                3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n            &gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n                0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.LPushX, [key] + elements)\n        )\n\n    async def lpop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Remove and return the first elements of the list stored at `key`.\n        The command pops a single element from the beginning of the list.\n        See https://valkey.io/commands/lpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            Optional[bytes]: The value of the first element.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpop(\"my_list\")\n                b\"value1\"\n            &gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.LPop, [key]),\n        )\n\n    async def lpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Remove and return up to `count` elements from the list stored at `key`, depending on the list's length.\n        See https://valkey.io/commands/lpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of elements to pop from the list.\n\n        Returns:\n            Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n                [b\"value1\", b\"value2\"]\n            &gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n                None\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.LPop, [key, str(count)]),\n        )\n\n    async def blpop(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Pops an element from the head of the first list that is non-empty, with the given keys being checked in the\n        order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n        See https://valkey.io/commands/blpop for details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BLPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the lists to pop from.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n                popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n                [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.BLPop, keys + [str(timeout)]),\n        )\n\n    async def lmpop(\n        self,\n        keys: List[TEncodable],\n        direction: ListDirection,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n        \"\"\"\n        Pops one or more elements from the first non-empty list from the provided `keys`.\n\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/lmpop/ for details.\n\n        Args:\n            keys (List[TEncodable]): An array of keys of lists.\n            direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n        Returns:\n            Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n            &gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n               {b\"testKey\": [b\"three\", b\"two\"]}\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(len(keys)), *keys, direction.value]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[Mapping[bytes, List[bytes]]],\n            await self._execute_command(RequestType.LMPop, args),\n        )\n\n    async def blmpop(\n        self,\n        keys: List[TEncodable],\n        direction: ListDirection,\n        timeout: float,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n        \"\"\"\n        Blocks the connection until it pops one or more elements from the first non-empty list from the provided `keys`.\n\n        `BLMPOP` is the blocking variant of `LMPOP`.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BLMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/blmpop/ for details.\n\n        Args:\n            keys (List[TEncodable]): An array of keys of lists.\n            direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n            count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n        Returns:\n            Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n            &gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n               {b\"testKey\": [b\"three\", b\"two\"]}\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(timeout), str(len(keys)), *keys, direction.value]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[Mapping[bytes, List[bytes]]],\n            await self._execute_command(RequestType.BLMPop, args),\n        )\n\n    async def lrange(self, key: TEncodable, start: int, end: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieve the specified elements of the list stored at `key` within the given range.\n        The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n        element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list,\n        with -1 being the last element of the list, -2 being the penultimate, and so on.\n        See https://valkey.io/commands/lrange/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            List[bytes]: A list of elements within the specified range.\n            If `start` exceeds the `end` of the list, or if `start` is greater than `end`, an empty list will be returned.\n            If `end` exceeds the actual end of the list, the range will stop at the actual end of the list.\n            If `key` does not exist an empty list will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n                [b\"value1\", b\"value2\", b\"value3\"]\n            &gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n                [b\"value2\", b\"value3\"]\n            &gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n                []\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(\n                RequestType.LRange, [key, str(start), str(end)]\n            ),\n        )\n\n    async def lindex(\n        self,\n        key: TEncodable,\n        index: int,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns the element at `index` in the list stored at `key`.\n\n        The index is zero-based, so 0 means the first element, 1 the second element and so on.\n        Negative indices can be used to designate elements starting at the tail of the list.\n        Here, -1 means the last element, -2 means the penultimate and so forth.\n\n        See https://valkey.io/commands/lindex/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            index (int): The index of the element in the list to retrieve.\n\n        Returns:\n            Optional[bytes]: The element at `index` in the list stored at `key`.\n                If `index` is out of range or if `key` does not exist, None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n                b'value1'  # Returns the first element in the list stored at 'my_list'.\n            &gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n                b'value3'  # Returns the last element in the list stored at 'my_list'.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.LIndex, [key, str(index)]),\n        )\n\n    async def lset(self, key: TEncodable, index: int, element: TEncodable) -&gt; TOK:\n        \"\"\"\n        Sets the list element at `index` to `element`.\n\n        The index is zero-based, so `0` means the first element, `1` the second element and so on.\n        Negative indices can be used to designate elements starting at the tail of the list.\n        Here, `-1` means the last element, `-2` means the penultimate and so forth.\n\n        See https://valkey.io/commands/lset/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            index (int): The index of the element in the list to be set.\n            element (TEncodable): The new element to set at the specified index.\n\n        Returns:\n            TOK: A simple `OK` response.\n\n        Examples:\n            &gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n                OK\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.LSet, [key, str(index), element]),\n        )\n\n    async def rpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the tail of the list stored at `key`.\n        `elements` are inserted one after the other to the tail of the list, from the leftmost element\n        to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n        See https://valkey.io/commands/rpush/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operations.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n                3 # Indicates that the new length of the list is 3 after the push operation.\n            &gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n                1\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.RPush, [key] + elements)\n        )\n\n    async def rpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the tail of the list stored at `key`, only if `key` exists and holds a list.\n        If `key` is not a list, this performs no operation.\n\n        See https://valkey.io/commands/rpushx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operation.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n                3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n            &gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n                0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.RPushX, [key] + elements)\n        )\n\n    async def rpop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Removes and returns the last elements of the list stored at `key`.\n        The command pops a single element from the end of the list.\n        See https://valkey.io/commands/rpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            Optional[bytes]: The value of the last element.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpop(\"my_list\")\n                b\"value1\"\n            &gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.RPop, [key]),\n        )\n\n    async def rpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Removes and returns up to `count` elements from the list stored at `key`, depending on the list's length.\n        See https://valkey.io/commands/rpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of elements to pop from the list.\n\n        Returns:\n            Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n                [b\"value1\", b\"value2\"]\n            &gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n                None\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.RPop, [key, str(count)]),\n        )\n\n    async def brpop(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the\n        order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n        See https://valkey.io/commands/brpop for details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BRPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the lists to pop from.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n                popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n                [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.BRPop, keys + [str(timeout)]),\n        )\n\n    async def linsert(\n        self,\n        key: TEncodable,\n        position: InsertPosition,\n        pivot: TEncodable,\n        element: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Inserts `element` in the list at `key` either before or after the `pivot`.\n\n        See https://valkey.io/commands/linsert/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            position (InsertPosition): The relative position to insert into - either `InsertPosition.BEFORE` or\n                `InsertPosition.AFTER` the `pivot`.\n            pivot (TEncodable): An element of the list.\n            element (TEncodable): The new element to insert.\n\n        Returns:\n            int: The list length after a successful insert operation.\n                If the `key` doesn't exist returns `-1`.\n                If the `pivot` wasn't found, returns `0`.\n\n        Examples:\n            &gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n                3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.LInsert, [key, position.value, pivot, element]\n            ),\n        )\n\n    async def lmove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        where_from: ListDirection,\n        where_to: ListDirection,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Atomically pops and removes the left/right-most element to the list stored at `source`\n        depending on `where_from`, and pushes the element at the first/last element of the list\n        stored at `destination` depending on `where_to`.\n\n        When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n        See https://valkey.io/commands/lmove/ for details.\n\n        Args:\n            source (TEncodable): The key to the source list.\n            destination (TEncodable): The key to the destination list.\n            where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n\n        Returns:\n            Optional[bytes]: The popped element, or None if `source` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n            &gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n            &gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n                b\"one\"\n            &gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n                [b\"two\"]\n            &gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n                [b\"one\", b\"three\", b\"four\"]\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(\n                RequestType.LMove,\n                [source, destination, where_from.value, where_to.value],\n            ),\n        )\n\n    async def blmove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        where_from: ListDirection,\n        where_to: ListDirection,\n        timeout: float,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Blocks the connection until it pops atomically and removes the left/right-most element to the\n        list stored at `source` depending on `where_from`, and pushes the element at the first/last element\n        of the list stored at `destination` depending on `where_to`.\n        `BLMOVE` is the blocking variant of `LMOVE`.\n\n        Notes:\n            1. When in cluster mode, both `source` and `destination` must map to the same hash slot.\n            2. `BLMOVE` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/blmove/ for details.\n\n        Args:\n            source (TEncodable): The key to the source list.\n            destination (TEncodable): The key to the destination list.\n            where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n\n        Returns:\n            Optional[bytes]: The popped element, or None if `source` does not exist or if the operation timed-out.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n            &gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n            &gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n                b\"one\"\n            &gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n                [b\"two\"]\n            &gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n                [b\"one\", b\"three\", bb\"four\"]\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(\n                RequestType.BLMove,\n                [source, destination, where_from.value, where_to.value, str(timeout)],\n            ),\n        )\n\n    async def sadd(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Add specified members to the set stored at `key`.\n        Specified members that are already a member of this set are ignored.\n        If `key` does not exist, a new set is created before adding `members`.\n        See https://valkey.io/commands/sadd/ for more details.\n\n        Args:\n            key (TEncodable): The key where members will be added to its set.\n            members (List[TEncodable]): A list of members to add to the set stored at `key`.\n\n        Returns:\n            int: The number of members that were added to the set, excluding members already present.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n                2\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SAdd, [key] + members))\n\n    async def srem(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Remove specified members from the set stored at `key`.\n        Specified members that are not a member of this set are ignored.\n        See https://valkey.io/commands/srem/ for details.\n\n        Args:\n            key (TEncodable): The key from which members will be removed.\n            members (List[TEncodable]): A list of members to remove from the set stored at `key`.\n\n        Returns:\n            int: The number of members that were removed from the set, excluding non-existing members.\n                If `key` does not exist, it is treated as an empty set and this command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n                2\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SRem, [key] + members))\n\n    async def smembers(self, key: TEncodable) -&gt; Set[bytes]:\n        \"\"\"\n        Retrieve all the members of the set value stored at `key`.\n        See https://valkey.io/commands/smembers/ for details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the set members.\n\n        Returns:\n            Set[bytes]: A set of all members of the set.\n                If `key` does not exist an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.smembers(\"my_set\")\n                {b\"member1\", b\"member2\", b\"member3\"}\n        \"\"\"\n        return cast(\n            Set[bytes], await self._execute_command(RequestType.SMembers, [key])\n        )\n\n    async def scard(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Retrieve the set cardinality (number of elements) of the set stored at `key`.\n        See https://valkey.io/commands/scard/ for details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the number of set members.\n\n        Returns:\n            int: The cardinality (number of elements) of the set, or 0 if the key does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.scard(\"my_set\")\n                3\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SCard, [key]))\n\n    async def spop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Removes and returns one random member from the set stored at `key`.\n\n        See https://valkey-io.github.io/commands/spop/ for more details.\n        To pop multiple members, see `spop_count`.\n\n        Args:\n            key (TEncodable): The key of the set.\n\n        Returns:\n            Optional[bytes]: The value of the popped member.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.spop(\"my_set\")\n                b\"value1\" # Removes and returns a random member from the set \"my_set\".\n            &gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.SPop, [key])\n        )\n\n    async def spop_count(self, key: TEncodable, count: int) -&gt; Set[bytes]:\n        \"\"\"\n        Removes and returns up to `count` random members from the set stored at `key`, depending on the set's length.\n\n        See https://valkey-io.github.io/commands/spop/ for more details.\n        To pop a single member, see `spop`.\n\n        Args:\n            key (TEncodable): The key of the set.\n            count (int): The count of the elements to pop from the set.\n\n        Returns:\n            Set[bytes]: A set of popped elements will be returned depending on the set's length.\n                If `key` does not exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n                {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n            &gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n                Set()\n        \"\"\"\n        return cast(\n            Set[bytes], await self._execute_command(RequestType.SPop, [key, str(count)])\n        )\n\n    async def sismember(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Returns if `member` is a member of the set stored at `key`.\n\n        See https://valkey.io/commands/sismember/ for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            member (TEncodable): The member to check for existence in the set.\n\n        Returns:\n            bool: True if the member exists in the set, False otherwise.\n            If `key` doesn't exist, it is treated as an empty set and the command returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n                True  # Indicates that \"member1\" exists in the set \"my_set\".\n            &gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n                False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.SIsMember, [key, member]),\n        )\n\n    async def smove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        member: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Moves `member` from the set at `source` to the set at `destination`, removing it from the source set. Creates a\n        new destination set if needed. The operation is atomic.\n\n        See https://valkey.io/commands/smove for more details.\n\n        Note:\n            When in cluster mode, `source` and `destination` must map to the same hash slot.\n\n        Args:\n            source (TEncodable): The key of the set to remove the element from.\n            destination (TEncodable): The key of the set to add the element to.\n            member (TEncodable): The set element to move.\n\n        Returns:\n            bool: True on success, or False if the `source` set does not exist or the element is not a member of the source set.\n\n        Examples:\n            &gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n                True  # \"member1\" was moved from \"set1\" to \"set2\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(\n                RequestType.SMove, [source, destination, member]\n            ),\n        )\n\n    async def sunion(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Gets the union of all the given sets.\n\n        See https://valkey.io/commands/sunion for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets.\n\n        Returns:\n            Set[bytes]: A set of members which are present in at least one of the given sets.\n                If none of the sets exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n                {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n            &gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n                {b\"member1\", b\"member2\"}\n        \"\"\"\n        return cast(Set[bytes], await self._execute_command(RequestType.SUnion, keys))\n\n    async def sunionstore(\n        self,\n        destination: TEncodable,\n        keys: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Stores the members of the union of all given sets specified by `keys` into a new set at `destination`.\n\n        See https://valkey.io/commands/sunionstore for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n            &gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n                2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SUnionStore, [destination] + keys),\n        )\n\n    async def sdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Stores the difference between the first set and all the successive sets in `keys` into a new set at\n        `destination`.\n\n        See https://valkey.io/commands/sdiffstore for more details.\n\n        Note:\n            When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys of the sets to diff.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n            &gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n                1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SDiffStore, [destination] + keys),\n        )\n\n    async def sinter(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Gets the intersection of all the given sets.\n\n        See https://valkey.io/commands/sinter for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets.\n\n        Returns:\n            Set[bytes]: A set of members which are present in all given sets.\n                If one or more sets do no exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n                 {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n            &gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n                None\n        \"\"\"\n        return cast(Set[bytes], await self._execute_command(RequestType.SInter, keys))\n\n    async def sinterstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Stores the members of the intersection of all given sets specified by `keys` into a new set at `destination`.\n\n        See https://valkey.io/commands/sinterstore for more details.\n\n        Note:\n            When in Cluster mode, all `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n                1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SInterStore, [destination] + keys),\n        )\n\n    async def sintercard(\n        self, keys: List[TEncodable], limit: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Gets the cardinality of the intersection of all the given sets.\n        Optionally, a `limit` can be specified to stop the computation early if the intersection cardinality reaches the specified limit.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/sintercard for more details.\n\n        Args:\n            keys (List[TEncodable]): A list of keys representing the sets to intersect.\n            limit (Optional[int]): An optional limit to the maximum number of intersecting elements to count.\n                If specified, the computation stops as soon as the cardinality reaches this limit.\n\n        Returns:\n            int: The number of elements in the resulting set of the intersection.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n            &gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n            &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n            2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n\n            &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n            1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        if limit is not None:\n            args += [\"LIMIT\", str(limit)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.SInterCard, args),\n        )\n\n    async def sdiff(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Computes the difference between the first set and all the successive sets in `keys`.\n\n        See https://valkey.io/commands/sdiff for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets to diff\n\n        Returns:\n            Set[bytes]: A set of elements representing the difference between the sets.\n                If any of the keys in `keys` do not exist, they are treated as empty sets.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n            &gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n                {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n        \"\"\"\n        return cast(\n            Set[bytes],\n            await self._execute_command(RequestType.SDiff, keys),\n        )\n\n    async def smismember(\n        self, key: TEncodable, members: List[TEncodable]\n    ) -&gt; List[bool]:\n        \"\"\"\n        Checks whether each member is contained in the members of the set stored at `key`.\n\n        See https://valkey.io/commands/smismember for more details.\n\n        Args:\n            key (TEncodable): The key of the set to check.\n            members (List[TEncodable]): A list of members to check for existence in the set.\n\n        Returns:\n            List[bool]: A list of bool values, each indicating if the respective member exists in the set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n            &gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n                [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n        \"\"\"\n        return cast(\n            List[bool],\n            await self._execute_command(RequestType.SMIsMember, [key] + members),\n        )\n\n    async def ltrim(self, key: TEncodable, start: int, end: int) -&gt; TOK:\n        \"\"\"\n        Trim an existing list so that it will contain only the specified range of elements specified.\n        The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n        element and so on.\n        These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last\n        element of the list, -2 being the penultimate, and so on.\n        See https://valkey.io/commands/ltrim/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n                If `start` exceeds the end of the list, or if `start` is greater than `end`, the result will be an empty list\n                (which causes `key` to be removed).\n                If `end` exceeds the actual end of the list, it will be treated like the last element of the list.\n                If `key` does not exist, \"OK\" will be returned without changes to the database.\n\n        Examples:\n            &gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n                \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.LTrim, [key, str(start), str(end)]),\n        )\n\n    async def lrem(self, key: TEncodable, count: int, element: TEncodable) -&gt; int:\n        \"\"\"\n        Removes the first `count` occurrences of elements equal to `element` from the list stored at `key`.\n        If `count` is positive, it removes elements equal to `element` moving from head to tail.\n        If `count` is negative, it removes elements equal to `element` moving from tail to head.\n        If `count` is 0 or greater than the occurrences of elements equal to `element`, it removes all elements\n        equal to `element`.\n        See https://valkey.io/commands/lrem/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of occurrences of elements equal to `element` to remove.\n            element (TEncodable): The element to remove from the list.\n\n        Returns:\n            int: The number of removed elements.\n                If `key` does not exist, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n                2  # Removes the first 2 occurrences of \"value\" in the list.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.LRem, [key, str(count), element]),\n        )\n\n    async def llen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Get the length of the list stored at `key`.\n        See https://valkey.io/commands/llen/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            int: The length of the list at the specified key.\n                If `key` does not exist, it is interpreted as an empty list and 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.llen(\"my_list\")\n                3  # Indicates that there are 3 elements in the list.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.LLen, [key]))\n\n    async def exists(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Returns the number of keys in `keys` that exist in the database.\n        See https://valkey.io/commands/exists/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The list of keys to check.\n\n        Returns:\n            int: The number of keys that exist. If the same existing key is mentioned in `keys` multiple times,\n                it will be counted multiple times.\n\n        Examples:\n            &gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n                3  # Indicates that all three keys exist in the database.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Exists, keys))\n\n    async def unlink(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Unlink (delete) multiple keys from the database.\n        A key is ignored if it does not exist.\n        This command, similar to DEL, removes specified keys and ignores non-existent ones.\n        However, this command does not block the server, while [DEL](https://valkey.io/commands/del) does.\n        See https://valkey.io/commands/unlink/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The list of keys to unlink.\n\n        Returns:\n            int: The number of keys that were unlinked.\n\n        Examples:\n            &gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n                3  # Indicates that all three keys were unlinked from the database.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Unlink, keys))\n\n    async def expire(\n        self,\n        key: TEncodable,\n        seconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` in seconds. After the timeout has expired, the key will automatically be deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        If `seconds` is a non-positive number, the key will be deleted rather than expired.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/expire/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            seconds (int): The timeout in seconds.\n            option (ExpireOptions, optional): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n                True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n        \"\"\"\n        args: List[TEncodable] = (\n            [key, str(seconds)] if option is None else [key, str(seconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.Expire, args))\n\n    async def expireat(\n        self,\n        key: TEncodable,\n        unix_seconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the\n        number of seconds.\n        A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n        deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/expireat/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            unix_seconds (int): The timeout in an absolute Unix timestamp.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n                True\n        \"\"\"\n        args = (\n            [key, str(unix_seconds)]\n            if option is None\n            else [key, str(unix_seconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.ExpireAt, args))\n\n    async def pexpire(\n        self,\n        key: TEncodable,\n        milliseconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` in milliseconds. After the timeout has expired, the key will automatically be deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        If `milliseconds` is a non-positive number, the key will be deleted rather than expired.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/pexpire/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            milliseconds (int): The timeout in milliseconds.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n                True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n        \"\"\"\n        args = (\n            [key, str(milliseconds)]\n            if option is None\n            else [key, str(milliseconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.PExpire, args))\n\n    async def pexpireat(\n        self,\n        key: TEncodable,\n        unix_milliseconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead\n        of specifying the number of milliseconds.\n        A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n        deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/pexpireat/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            unix_milliseconds (int): The timeout in an absolute Unix timestamp in milliseconds.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n                True\n        \"\"\"\n        args = (\n            [key, str(unix_milliseconds)]\n            if option is None\n            else [key, str(unix_milliseconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.PExpireAt, args))\n\n    async def expiretime(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the absolute Unix timestamp (since January 1, 1970) at which\n        the given `key` will expire, in seconds.\n        To get the expiration with millisecond precision, use `pexpiretime`.\n\n        See https://valkey.io/commands/expiretime/ for details.\n\n        Args:\n            key (TEncodable): The `key` to determine the expiration value of.\n\n        Returns:\n            int: The expiration Unix timestamp in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                -2 # 'my_key' doesn't exist.\n            &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                -1 # 'my_key' has no associate expiration.\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                1718614954\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.ExpireTime, [key]))\n\n    async def pexpiretime(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the absolute Unix timestamp (since January 1, 1970) at which\n        the given `key` will expire, in milliseconds.\n\n        See https://valkey.io/commands/pexpiretime/ for details.\n\n        Args:\n            key (TEncodable): The `key` to determine the expiration value of.\n\n        Returns:\n            int: The expiration Unix timestamp in milliseconds, -2 if `key` does not exist, or -1 if `key` exists but has no associated expiration.\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                -2 # 'my_key' doesn't exist.\n            &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                -1 # 'my_key' has no associate expiration.\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                1718615446670\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.PExpireTime, [key]))\n\n    async def ttl(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the remaining time to live of `key` that has a timeout.\n        See https://valkey.io/commands/ttl/ for more details.\n\n        Args:\n            key (TEncodable): The key to return its timeout.\n\n        Returns:\n            int: TTL in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.ttl(\"my_key\")\n                3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n            &gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n                -2  # Returns -2 for a non-existing key.\n            &gt;&gt;&gt; await client.ttl(\"key\")\n                -1  # Indicates that \"key: has no has no associated expire.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.TTL, [key]))\n\n    async def pttl(\n        self,\n        key: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Returns the remaining time to live of `key` that has a timeout, in milliseconds.\n        See https://valkey.io/commands/pttl for more details.\n\n        Args:\n            key (TEncodable): The key to return its timeout.\n\n        Returns:\n            int: TTL in milliseconds. -2 if `key` does not exist, -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.pttl(\"my_key\")\n                5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n            &gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n                -2  # Indicates that the key \"non_existing_key\" does not exist.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PTTL, [key]),\n        )\n\n    async def persist(\n        self,\n        key: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Remove the existing timeout on `key`, turning the key from volatile (a key with an expire set) to\n        persistent (a key that will never expire as no timeout is associated).\n\n        See https://valkey.io/commands/persist/ for more details.\n\n        Args:\n            key (TEncodable): The key to remove the existing timeout on.\n\n        Returns:\n            bool: False if `key` does not exist or does not have an associated timeout, True if the timeout has been removed.\n\n        Examples:\n            &gt;&gt;&gt; await client.persist(\"my_key\")\n                True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.Persist, [key]),\n        )\n\n    async def type(self, key: TEncodable) -&gt; bytes:\n        \"\"\"\n        Returns the bytes string representation of the type of the value stored at `key`.\n\n        See https://valkey.io/commands/type/ for more details.\n\n        Args:\n            key (TEncodable): The key to check its data type.\n\n        Returns:\n            bytes: If the key exists, the type of the stored value is returned.\n            Otherwise, a b\"none\" bytes string is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.type(\"key\")\n                b'string'\n            &gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n            &gt;&gt;&gt; await client.type(\"key\")\n                b'list'\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.Type, [key]))\n\n    async def xadd(\n        self,\n        key: TEncodable,\n        values: List[Tuple[TEncodable, TEncodable]],\n        options: Optional[StreamAddOptions] = None,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Adds an entry to the specified stream stored at `key`. If the `key` doesn't exist, the stream is created.\n\n        See https://valkey.io/commands/xadd for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            values (List[Tuple[TEncodable, TEncodable]]): Field-value pairs to be added to the entry.\n            options (Optional[StreamAddOptions]): Additional options for adding entries to the stream. Default to None. See `StreamAddOptions`.\n\n        Returns:\n            bytes: The id of the added entry, or None if `options.make_stream` is set to False and no stream with the matching `key` exists.\n\n        Example:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])\n                b\"1615957011958-0\"  # Example stream entry ID.\n            &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))\n                None  # The key doesn't exist, therefore, None is returned.\n            &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))\n                b\"0-1\"  # Returns the stream id.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        if options:\n            args.extend(options.to_args())\n        else:\n            args.append(\"*\")\n        args.extend([field for pair in values for field in pair])\n\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.XAdd, args)\n        )\n\n    async def xdel(self, key: TEncodable, ids: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Removes the specified entries by id from a stream, and returns the number of entries deleted.\n\n        See https://valkey.io/commands/xdel for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            ids (List[TEncodable]): An array of entry ids.\n\n        Returns:\n            int: The number of entries removed from the stream. This number may be less than the number of entries in\n                `ids`, if the specified `ids` don't exist in the stream.\n\n        Examples:\n            &gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n                2  # Stream marked 2 entries as deleted.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        args.extend(ids)\n        return cast(\n            int,\n            await self._execute_command(RequestType.XDel, [key] + ids),\n        )\n\n    async def xtrim(\n        self,\n        key: TEncodable,\n        options: StreamTrimOptions,\n    ) -&gt; int:\n        \"\"\"\n        Trims the stream stored at `key` by evicting older entries.\n\n        See https://valkey.io/commands/xtrim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            options (StreamTrimOptions): Options detailing how to trim the stream. See `StreamTrimOptions`.\n\n        Returns:\n            int: TThe number of entries deleted from the stream. If `key` doesn't exist, 0 is returned.\n\n        Example:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))\n                1 # One entry was deleted from the stream.\n        \"\"\"\n        args = [key]\n        if options:\n            args.extend(options.to_args())\n\n        return cast(int, await self._execute_command(RequestType.XTrim, args))\n\n    async def xlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the number of entries in the stream stored at `key`.\n\n        See https://valkey.io/commands/xlen for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            int: The number of entries in the stream. If `key` does not exist, returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n            &gt;&gt;&gt; await client.xlen(\"mystream\")\n                2  # There are 2 entries in \"mystream\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.XLen, [key]),\n        )\n\n    async def xrange(\n        self,\n        key: TEncodable,\n        start: StreamRangeBound,\n        end: StreamRangeBound,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n        \"\"\"\n        Returns stream entries matching a given range of IDs.\n\n        See https://valkey.io/commands/xrange for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n                If `count` is not provided, all stream entries in the range will be returned.\n\n        Returns:\n            Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n                list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n                arguments are not applicable.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n                {\n                    b\"0-1\": [[b\"field1\", b\"value1\"]],\n                    b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n        \"\"\"\n        args: List[TEncodable] = [key, start.to_arg(), end.to_arg()]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[Mapping[bytes, List[List[bytes]]]],\n            await self._execute_command(RequestType.XRange, args),\n        )\n\n    async def xrevrange(\n        self,\n        key: TEncodable,\n        end: StreamRangeBound,\n        start: StreamRangeBound,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n        \"\"\"\n        Returns stream entries matching a given range of IDs in reverse order. Equivalent to `XRANGE` but returns the\n        entries in reverse order.\n\n        See https://valkey.io/commands/xrevrange for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n                If `count` is not provided, all stream entries in the range will be returned.\n\n        Returns:\n            Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n                list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n                arguments are not applicable.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n                {\n                    \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n                    \"0-1\": [[\"field1\", \"value1\"]],\n                }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n        \"\"\"\n        args: List[TEncodable] = [key, end.to_arg(), start.to_arg()]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[Mapping[bytes, List[List[bytes]]]],\n            await self._execute_command(RequestType.XRevRange, args),\n        )\n\n    async def xread(\n        self,\n        keys_and_ids: Mapping[TEncodable, TEncodable],\n        options: Optional[StreamReadOptions] = None,\n    ) -&gt; Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]:\n        \"\"\"\n        Reads entries from the given streams.\n\n        See https://valkey.io/commands/xread for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n        Args:\n            keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of keys and entry IDs to read from.\n            options (Optional[StreamReadOptions]): Options detailing how to read the stream.\n\n        Returns:\n            Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs,\n                to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n                None will be returned under the following conditions:\n                - All key-ID pairs in `keys_and_ids` have either a non-existing key or a non-existing ID, or there are no entries after the given ID.\n                - The `BLOCK` option is specified and the timeout is hit.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n                {\n                    b\"mystream\": {\n                        b\"0-1\": [[b\"field1\", b\"value1\"]],\n                        b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                    }\n                }\n                # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n                # 1000ms if there is no stream data.\n        \"\"\"\n        args: List[TEncodable] = [] if options is None else options.to_args()\n        args.append(\"STREAMS\")\n        args.extend([key for key in keys_and_ids.keys()])\n        args.extend([value for value in keys_and_ids.values()])\n\n        return cast(\n            Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]],\n            await self._execute_command(RequestType.XRead, args),\n        )\n\n    async def xgroup_create(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        group_id: TEncodable,\n        options: Optional[StreamGroupOptions] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Creates a new consumer group uniquely identified by `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-create for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The newly created consumer group name.\n            group_id (TEncodable): The stream entry ID that specifies the last delivered entry in the stream from the new\n                group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.\n            options (Optional[StreamGroupOptions]): Options for creating the stream group.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n                OK\n                # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n                # the most recent entry. The stream was created with length 0 if it did not already exist.\n        \"\"\"\n        args: List[TEncodable] = [key, group_name, group_id]\n        if options is not None:\n            args.extend(options.to_args())\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.XGroupCreate, args),\n        )\n\n    async def xgroup_destroy(self, key: TEncodable, group_name: TEncodable) -&gt; bool:\n        \"\"\"\n        Destroys the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-destroy for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name to delete.\n\n        Returns:\n            bool: True if the consumer group was destroyed. Otherwise, returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n                True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.XGroupDestroy, [key, group_name]),\n        )\n\n    async def xgroup_create_consumer(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Creates a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-createconsumer for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The newly created consumer.\n\n        Returns:\n            bool: True if the consumer is created. Otherwise, returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n                True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(\n                RequestType.XGroupCreateConsumer, [key, group_name, consumer_name]\n            ),\n        )\n\n    async def xgroup_del_consumer(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Deletes a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-delconsumer for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer to delete.\n\n        Returns:\n            int: The number of pending messages the `consumer` had before it was deleted.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n                5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.XGroupDelConsumer, [key, group_name, consumer_name]\n            ),\n        )\n\n    async def xgroup_set_id(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        stream_id: TEncodable,\n        entries_read: Optional[int] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Set the last delivered ID for a consumer group.\n\n        See https://valkey.io/commands/xgroup-setid for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            stream_id (TEncodable): The stream entry ID that should be set as the last delivered ID for the consumer group.\n            entries_read: (Optional[int]): A value representing the number of stream entries already read by the\n                group. This option can only be specified if you are using Valkey version 7.0.0 or above.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n                OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n        \"\"\"\n        args: List[TEncodable] = [key, group_name, stream_id]\n        if entries_read is not None:\n            args.extend([\"ENTRIESREAD\", str(entries_read)])\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.XGroupSetId, args),\n        )\n\n    async def xreadgroup(\n        self,\n        keys_and_ids: Mapping[TEncodable, TEncodable],\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        options: Optional[StreamReadGroupOptions] = None,\n    ) -&gt; Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]:\n        \"\"\"\n        Reads entries from the given streams owned by a consumer group.\n\n        See https://valkey.io/commands/xreadgroup for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n        Args:\n            keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of stream keys to stream entry IDs to read from.\n                Use the special entry ID of `\"&gt;\"` to receive only new messages.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name. The consumer will be auto-created if it does not already exist.\n            options (Optional[StreamReadGroupOptions]): Options detailing how to read the stream.\n\n        Returns:\n            Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of\n                stream IDs, to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n                Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n        \"\"\"\n        args: List[TEncodable] = [\"GROUP\", group_name, consumer_name]\n        if options is not None:\n            args.extend(options.to_args())\n\n        args.append(\"STREAMS\")\n        args.extend([key for key in keys_and_ids.keys()])\n        args.extend([value for value in keys_and_ids.values()])\n\n        return cast(\n            Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]],\n            await self._execute_command(RequestType.XReadGroup, args),\n        )\n\n    async def xack(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        ids: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group.\n        This command should be called on pending messages so that such messages do not get processed again by the\n        consumer group.\n\n        See https://valkey.io/commands/xack for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            ids (List[TEncodable]): The stream entry IDs to acknowledge and consume for the given consumer group.\n\n        Returns:\n            int: The number of messages that were successfully acknowledged.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n                {\n                    \"mystream\": {\n                        \"1-0\": [[\"field1\", \"value1\"]],\n                    }\n                }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n            &gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n                1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n        \"\"\"\n        args: List[TEncodable] = [key, group_name]\n        args.extend(ids)\n        return cast(\n            int,\n            await self._execute_command(RequestType.XAck, [key, group_name] + ids),\n        )\n\n    async def xpending(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n    ) -&gt; List[Union[int, bytes, List[List[bytes]], None]]:\n        \"\"\"\n        Returns stream message summary information for pending messages for the given consumer group.\n\n        See https://valkey.io/commands/xpending for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n\n        Returns:\n            List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the\n                format `[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]`, where:\n                - `num_group_messages`: The total number of pending messages for this consumer group.\n                - `start_id`: The smallest ID among the pending messages.\n                - `end_id`: The greatest ID among the pending messages.\n                - `[[consumer_name, num_consumer_messages]]`: A 2D list of every consumer in the consumer group with at\n                least one pending message, and the number of pending messages it has.\n\n                If there are no pending messages for the given consumer group, `[0, None, None, None]` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n                [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n        \"\"\"\n        return cast(\n            List[Union[int, bytes, List[List[bytes]], None]],\n            await self._execute_command(RequestType.XPending, [key, group_name]),\n        )\n\n    async def xpending_range(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        start: StreamRangeBound,\n        end: StreamRangeBound,\n        count: int,\n        options: Optional[StreamPendingOptions] = None,\n    ) -&gt; List[List[Union[bytes, int]]]:\n        \"\"\"\n        Returns an extended form of stream message information for pending messages matching a given range of IDs.\n\n        See https://valkey.io/commands/xpending for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            count (int): Limits the number of messages returned.\n            options (Optional[StreamPendingOptions]): The stream pending options.\n\n        Returns:\n            List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended\n                message information with the format `[[id, consumer_name, time_elapsed, num_delivered]]`, where:\n                - `id`: The ID of the message.\n                - `consumer_name`: The name of the consumer that fetched the message and has still to acknowledge it. We\n                call it the current owner of the message.\n                - `time_elapsed`: The number of milliseconds that elapsed since the last time this message was delivered\n                to this consumer.\n                - `num_delivered`: The number of times this message was delivered.\n\n        Examples:\n            &gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n                [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n                # Extended stream entry information for the pending entries associated with \"my_consumer\".\n        \"\"\"\n        args = _create_xpending_range_args(key, group_name, start, end, count, options)\n        return cast(\n            List[List[Union[bytes, int]]],\n            await self._execute_command(RequestType.XPending, args),\n        )\n\n    async def xclaim(\n        self,\n        key: TEncodable,\n        group: TEncodable,\n        consumer: TEncodable,\n        min_idle_time_ms: int,\n        ids: List[TEncodable],\n        options: Optional[StreamClaimOptions] = None,\n    ) -&gt; Mapping[bytes, List[List[bytes]]]:\n        \"\"\"\n        Changes the ownership of a pending message.\n\n        See https://valkey.io/commands/xclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group (TEncodable): The consumer group name.\n            consumer (TEncodable): The group consumer.\n            min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n            ids (List[TEncodable]): A array of entry ids.\n            options (Optional[StreamClaimOptions]): Stream claim options.\n\n        Returns:\n            Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format\n                {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.\n\n        Examples:\n            # read messages from streamId for consumer1\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }\n                # \"1-0\" is now read, and we can assign the pending messages to consumer2\n            &gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n                {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n        \"\"\"\n\n        args = [key, group, consumer, str(min_idle_time_ms), *ids]\n\n        if options:\n            args.extend(options.to_args())\n\n        return cast(\n            Mapping[bytes, List[List[bytes]]],\n            await self._execute_command(RequestType.XClaim, args),\n        )\n\n    async def xclaim_just_id(\n        self,\n        key: TEncodable,\n        group: TEncodable,\n        consumer: TEncodable,\n        min_idle_time_ms: int,\n        ids: List[TEncodable],\n        options: Optional[StreamClaimOptions] = None,\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Changes the ownership of a pending message. This function returns a List with\n        only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.\n\n        See https://valkey.io/commands/xclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group (TEncodable): The consumer group name.\n            consumer (TEncodable): The group consumer.\n            min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n            ids (List[TEncodable]): A array of entry ids.\n            options (Optional[StreamClaimOptions]): Stream claim options.\n\n        Returns:\n            List[bytes]: A List of message ids claimed by the consumer.\n\n        Examples:\n            # read messages from streamId for consumer1\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }\n                # \"1-0\" is now read, and we can assign the pending messages to consumer2\n            &gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n                [b\"1-0\"]\n        \"\"\"\n\n        args = [\n            key,\n            group,\n            consumer,\n            str(min_idle_time_ms),\n            *ids,\n            StreamClaimOptions.JUST_ID_VALKEY_API,\n        ]\n\n        if options:\n            args.extend(options.to_args())\n\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.XClaim, args),\n        )\n\n    async def xautoclaim(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        min_idle_time_ms: int,\n        start: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]:\n        \"\"\"\n        Transfers ownership of pending stream entries that match the specified criteria.\n\n        See https://valkey.io/commands/xautoclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name.\n            min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n                value.\n            start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n            count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n        Returns:\n            List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements:\n                - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n                to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n                scanned.\n                - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a\n                2D list of the field-value pairs in the format `[[field1, value1], [field2, value2], ...]`.\n                - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n                message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n                deleted from the Pending Entries List.\n\n        Examples:\n            # Valkey version &lt; 7.0.0:\n            &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [\n                    b\"0-0\",\n                    {\n                        b\"1-1\": [\n                            [b\"field1\", b\"value1\"],\n                            [b\"field2\", b\"value2\"],\n                        ]\n                    }\n                ]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned.\n\n            # Valkey version 7.0.0 and above:\n            &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [\n                    b\"0-0\",\n                    {\n                        b\"1-1\": [\n                            [b\"field1\", b\"value1\"],\n                            [b\"field2\", b\"value2\"],\n                        ]\n                    },\n                    [b\"1-2\"]\n                ]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n                # exists in the stream.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [\n            key,\n            group_name,\n            consumer_name,\n            str(min_idle_time_ms),\n            start,\n        ]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]],\n            await self._execute_command(RequestType.XAutoClaim, args),\n        )\n\n    async def xautoclaim_just_id(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        min_idle_time_ms: int,\n        start: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID\n        argument to further specify that the return value should contain a list of claimed IDs without their\n        field-value info.\n\n        See https://valkey.io/commands/xautoclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name.\n            min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n                value.\n            start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n            count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: A list containing the following elements:\n                - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n                to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n                scanned.\n                - A list of the IDs for the claimed entries.\n                - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n                message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n                deleted from the Pending Entries List.\n\n        Examples:\n            # Valkey version &lt; 7.0.0:\n            &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [b\"0-0\", [b\"1-1\"]]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned.\n\n            # Valkey version 7.0.0 and above:\n            &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n                # exists in the stream.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [\n            key,\n            group_name,\n            consumer_name,\n            str(min_idle_time_ms),\n            start,\n        ]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        args.append(\"JUSTID\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.XAutoClaim, args),\n        )\n\n    async def xinfo_groups(\n        self,\n        key: TEncodable,\n    ) -&gt; List[Mapping[bytes, Union[bytes, int, None]]]:\n        \"\"\"\n        Returns the list of all consumer groups and their attributes for the stream stored at `key`.\n\n        See https://valkey.io/commands/xinfo-groups for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the\n                attributes of a consumer group for the stream at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n                [\n                    {\n                        b\"name\": b\"mygroup\",\n                        b\"consumers\": 2,\n                        b\"pending\": 2,\n                        b\"last-delivered-id\": b\"1638126030001-0\",\n                        b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n                        b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n                    },\n                    {\n                        b\"name\": b\"some-other-group\",\n                        b\"consumers\": 1,\n                        b\"pending\": 0,\n                        b\"last-delivered-id\": b\"1638126028070-0\",\n                        b\"entries-read\": 1,\n                        b\"lag\": 1,\n                    }\n                ]\n                # The list of consumer groups and their attributes for stream \"my_stream\".\n        \"\"\"\n        return cast(\n            List[Mapping[bytes, Union[bytes, int, None]]],\n            await self._execute_command(RequestType.XInfoGroups, [key]),\n        )\n\n    async def xinfo_consumers(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n    ) -&gt; List[Mapping[bytes, Union[bytes, int]]]:\n        \"\"\"\n        Returns the list of all consumers and their attributes for the given consumer group of the stream stored at\n        `key`.\n\n        See https://valkey.io/commands/xinfo-consumers for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n\n        Returns:\n            List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a\n                consumer for the given consumer group of the stream at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n                [\n                    {\n                        b\"name\": b\"Alice\",\n                        b\"pending\": 1,\n                        b\"idle\": 9104628,\n                        b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n                    },\n                    {\n                        b\"name\": b\"Bob\",\n                        b\"pending\": 1,\n                        b\"idle\": 83841983,\n                        b\"inactive\": 993841998,\n                    }\n                ]\n                # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n        \"\"\"\n        return cast(\n            List[Mapping[bytes, Union[bytes, int]]],\n            await self._execute_command(RequestType.XInfoConsumers, [key, group_name]),\n        )\n\n    async def xinfo_stream(\n        self,\n        key: TEncodable,\n    ) -&gt; TXInfoStreamResponse:\n        \"\"\"\n        Returns information about the stream stored at `key`. To get more detailed information, use `xinfo_stream_full`.\n\n        See https://valkey.io/commands/xinfo-stream for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            TXInfoStreamResponse: A mapping of stream information for the given `key`. See the example for a sample\n                response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n                {\n                    b\"length\": 4,\n                    b\"radix-tree-keys\": 1L,\n                    b\"radix-tree-nodes\": 2L,\n                    b\"last-generated-id\": b\"1719877599564-0\",\n                    b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                    b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"groups\": 1L,\n                    b\"first-entry\": [\n                        b\"1719710679916-0\",\n                        [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                    ],\n                    b\"last-entry\": [\n                        b\"1719877599564-0\",\n                        [b\"field1\", b\"value1\"],\n                    ],\n                }\n                # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n                # the stream is empty.\n        \"\"\"\n        return cast(\n            TXInfoStreamResponse,\n            await self._execute_command(RequestType.XInfoStream, [key]),\n        )\n\n    async def xinfo_stream_full(\n        self,\n        key: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; TXInfoStreamFullResponse:\n        \"\"\"\n        Returns verbose information about the stream stored at `key`.\n\n        See https://valkey.io/commands/xinfo-stream for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            count (Optional[int]): The number of stream and PEL entries that are returned. A value of `0` means that all\n                entries will be returned. If not provided, defaults to `10`.\n\n        Returns:\n            TXInfoStreamFullResponse: A mapping of detailed stream information for the given `key`. See the example for\n                a sample response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n                {\n                    b\"length\": 4,\n                    b\"radix-tree-keys\": 1L,\n                    b\"radix-tree-nodes\": 2L,\n                    b\"last-generated-id\": b\"1719877599564-0\",\n                    b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                    b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries\": [\n                        [\n                            b\"1719710679916-0\",\n                            [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                        ],\n                        [\n                            b\"1719877599564-0\":\n                            [b\"field1\", b\"value1\"],\n                        ]\n                    ],\n                    b\"groups\": [\n                        {\n                            b\"name\": b\"mygroup\",\n                            b\"last-delivered-id\": b\"1719710688676-0\",\n                            b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                            b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                            b\"pel-count\": 2,\n                            b\"pending\": [\n                                [\n                                    b\"1719710679916-0\",\n                                    b\"Alice\",\n                                    1719710707260,\n                                    1,\n                                ],\n                                [\n                                    b\"1719710688676-0\",\n                                    b\"Alice\",\n                                    1719710718373,\n                                    1,\n                                ],\n                            ],\n                            b\"consumers\": [\n                                {\n                                    b\"name\": b\"Alice\",\n                                    b\"seen-time\": 1719710718373,\n                                    b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                                    b\"pel-count\": 2,\n                                    b\"pending\": [\n                                        [\n                                            b\"1719710679916-0\",\n                                            1719710707260,\n                                            1\n                                        ],\n                                        [\n                                            b\"1719710688676-0\",\n                                            1719710718373,\n                                            1\n                                        ]\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                }\n                # Detailed stream information for \"my_stream\".\n\n        Since: Valkey version 6.0.0.\n        \"\"\"\n        args = [key, \"FULL\"]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            TXInfoStreamFullResponse,\n            await self._execute_command(RequestType.XInfoStream, args),\n        )\n\n    async def geoadd(\n        self,\n        key: TEncodable,\n        members_geospatialdata: Mapping[TEncodable, GeospatialData],\n        existing_options: Optional[ConditionalChange] = None,\n        changed: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Adds geospatial members with their positions to the specified sorted set stored at `key`.\n        If a member is already a part of the sorted set, its position is updated.\n\n        See https://valkey.io/commands/geoadd for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members_geospatialdata (Mapping[TEncodable, GeospatialData]): A mapping of member names to their corresponding positions. See `GeospatialData`.\n            The command will report an error when the user attempts to index coordinates outside the specified ranges.\n            existing_options (Optional[ConditionalChange]): Options for handling existing members.\n                - NX: Only add new elements.\n                - XX: Only update existing elements.\n            changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n        Returns:\n            int: The number of elements added to the sorted set.\n            If `changed` is set, returns the number of elements updated in the sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n                2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n                1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if changed:\n            args.append(\"CH\")\n\n        members_geospatialdata_list = [\n            coord\n            for member, position in members_geospatialdata.items()\n            for coord in [str(position.longitude), str(position.latitude), member]\n        ]\n        args += members_geospatialdata_list\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.GeoAdd, args),\n        )\n\n    async def geodist(\n        self,\n        key: TEncodable,\n        member1: TEncodable,\n        member2: TEncodable,\n        unit: Optional[GeoUnit] = None,\n    ) -&gt; Optional[float]:\n        \"\"\"\n        Returns the distance between two members in the geospatial index stored at `key`.\n\n        See https://valkey.io/commands/geodist for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member1 (TEncodable): The name of the first member.\n            member2 (TEncodable): The name of the second member.\n            unit (Optional[GeoUnit]): The unit of distance measurement. See `GeoUnit`.\n                If not specified, the default unit is `METERS`.\n\n        Returns:\n            Optional[float]: The distance between `member1` and `member2`.\n            If one or both members do not exist, or if the key does not exist, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n                166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n                166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n                None  # Returns None for non-existing member.\n        \"\"\"\n        args = [key, member1, member2]\n        if unit:\n            args.append(unit.value)\n\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.GeoDist, args),\n        )\n\n    async def geohash(\n        self, key: TEncodable, members: List[TEncodable]\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at\n        `key`.\n\n        See https://valkey.io/commands/geohash for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): The list of members whose GeoHash bytes strings are to be retrieved.\n\n        Returns:\n            List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at `key`.\n            If a member does not exist in the sorted set, a None value is returned for that member.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n                [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n        \"\"\"\n        return cast(\n            List[Optional[bytes]],\n            await self._execute_command(RequestType.GeoHash, [key] + members),\n        )\n\n    async def geopos(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; List[Optional[List[float]]]:\n        \"\"\"\n        Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at\n        `key`.\n\n        See https://valkey.io/commands/geopos for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): The members for which to get the positions.\n\n        Returns:\n            List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.\n            If a member does not exist, its position will be None.\n\n        Example:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])\n                [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]\n        \"\"\"\n        return cast(\n            List[Optional[List[float]]],\n            await self._execute_command(RequestType.GeoPos, [key] + members),\n        )\n\n    async def geosearch(\n        self,\n        key: TEncodable,\n        search_from: Union[str, bytes, GeospatialData],\n        search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n        order_by: Optional[OrderBy] = None,\n        count: Optional[GeoSearchCount] = None,\n        with_coord: bool = False,\n        with_dist: bool = False,\n        with_hash: bool = False,\n    ) -&gt; List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]:\n        \"\"\"\n        Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area.\n\n        See https://valkey.io/commands/geosearch/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set representing geospatial data.\n            search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                from the sorted set or as a geospatial data (see `GeospatialData`).\n            search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                For circular area search, see `GeoSearchByRadius`.\n                For rectangular area search, see `GeoSearchByBox`.\n            order_by (Optional[OrderBy]): Specifies the order in which the results should be returned.\n                    - `ASC`: Sorts items from the nearest to the farthest, relative to the center point.\n                    - `DESC`: Sorts items from the farthest to the nearest, relative to the center point.\n                If not specified, the results would be unsorted.\n            count (Optional[GeoSearchCount]): Specifies the maximum number of results to return. See `GeoSearchCount`.\n                If not specified, return all results.\n            with_coord (bool): Whether to include coordinates of the returned items. Defaults to False.\n            with_dist (bool): Whether to include distance from the center in the returned items.\n                The distance is returned in the same unit as specified for the `search_by` arguments. Defaults to False.\n            with_hash (bool): Whether to include geohash of the returned items. Defaults to False.\n\n        Returns:\n            List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.\n            If any of `with_coord`, `with_dist` or `with_hash` are True, returns an array of arrays, we're each sub array represents a single item in the following order:\n                (bytes): The member (location) name.\n                (float): The distance from the center as a floating point number, in the same unit specified in the radius, if `with_dist` is set to True.\n                (int): The Geohash integer, if `with_hash` is set to True.\n                List[float]: The coordinates as a two item [longitude,latitude] array, if `with_coord` is set to True.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n                ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n            &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n                [\n                    [\n                        b\"Catania\",\n                        [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n                    ],\n                    [\n                        b\"Palermo\",\n                        [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n                    ],\n                    [\n                        b\"edge2\",\n                        [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n                    ],\n                    [\n                        b\"edge1\",\n                        [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n                    ],\n                ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = _create_geosearch_args(\n            [key],\n            search_from,\n            search_by,\n            order_by,\n            count,\n            with_coord,\n            with_dist,\n            with_hash,\n        )\n\n        return cast(\n            List[Union[bytes, List[Union[bytes, float, int, List[float]]]]],\n            await self._execute_command(RequestType.GeoSearch, args),\n        )\n\n    async def geosearchstore(\n        self,\n        destination: TEncodable,\n        source: TEncodable,\n        search_from: Union[str, bytes, GeospatialData],\n        search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n        count: Optional[GeoSearchCount] = None,\n        store_dist: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n\n        To get the result directly, see `geosearch`.\n\n        Note:\n            When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n            Args:\n                destination (TEncodable): The key to store the search results.\n                source (TEncodable): The key of the sorted set representing geospatial data to search from.\n                search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                    from the sorted set or as a geospatial data (see `GeospatialData`).\n                search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                    For circular area search, see `GeoSearchByRadius`.\n                    For rectangular area search, see `GeoSearchByBox`.\n                count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See `GeoSearchCount`.\n                    If not specified, stores all results.\n                store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.\n                    - If set to False, the geohash of the location will be stored as the sorted set score.\n                    - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.\n                        The distance is represented as a floating-point number in the same unit specified for that shape.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n                2 # Number of elements stored in \"my_dest_sorted_set\".\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n                {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n            &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n                2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n                {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = _create_geosearch_args(\n            [destination, source],\n            search_from,\n            search_by,\n            None,\n            count,\n            False,\n            False,\n            False,\n            store_dist,\n        )\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.GeoSearchStore, args),\n        )\n\n    async def zadd(\n        self,\n        key: TEncodable,\n        members_scores: Mapping[TEncodable, float],\n        existing_options: Optional[ConditionalChange] = None,\n        update_condition: Optional[UpdateOptions] = None,\n        changed: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Adds members with their scores to the sorted set stored at `key`.\n        If a member is already a part of the sorted set, its score is updated.\n\n        See https://valkey.io/commands/zadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members_scores (Mapping[TEncodable, float]): A mapping of members to their corresponding scores.\n            existing_options (Optional[ConditionalChange]): Options for handling existing members.\n                - NX: Only add new elements.\n                - XX: Only update existing elements.\n            update_condition (Optional[UpdateOptions]): Options for updating scores.\n                - GT: Only update scores greater than the current values.\n                - LT: Only update scores less than the current values.\n            changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n        Returns:\n            int: The number of elements added to the sorted set.\n            If `changed` is set, returns the number of elements updated in the sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n                2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n            &gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n                2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if update_condition:\n            args.append(update_condition.value)\n\n        if changed:\n            args.append(\"CH\")\n\n        if existing_options and update_condition:\n            if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n                raise ValueError(\n                    \"The GT, LT and NX options are mutually exclusive. \"\n                    f\"Cannot choose both {update_condition.value} and NX.\"\n                )\n\n        members_scores_list = [\n            str(item) for pair in members_scores.items() for item in pair[::-1]\n        ]\n        args += members_scores_list\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZAdd, args),\n        )\n\n    async def zadd_incr(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n        increment: float,\n        existing_options: Optional[ConditionalChange] = None,\n        update_condition: Optional[UpdateOptions] = None,\n    ) -&gt; Optional[float]:\n        \"\"\"\n        Increments the score of member in the sorted set stored at `key` by `increment`.\n        If `member` does not exist in the sorted set, it is added with `increment` as its score (as if its previous score was 0.0).\n        If `key` does not exist, a new sorted set with the specified member as its sole member is created.\n\n        See https://valkey.io/commands/zadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): A member in the sorted set to increment.\n            increment (float): The score to increment the member.\n            existing_options (Optional[ConditionalChange]): Options for handling the member's existence.\n                - NX: Only increment a member that doesn't exist.\n                - XX: Only increment an existing member.\n            update_condition (Optional[UpdateOptions]): Options for updating the score.\n                - GT: Only increment the score of the member if the new score will be greater than the current score.\n                - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.\n\n        Returns:\n            Optional[float]: The score of the member.\n            If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n                5.0\n            &gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n                None\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if update_condition:\n            args.append(update_condition.value)\n\n        args.append(\"INCR\")\n\n        if existing_options and update_condition:\n            if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n                raise ValueError(\n                    \"The GT, LT and NX options are mutually exclusive. \"\n                    f\"Cannot choose both {update_condition.value} and NX.\"\n                )\n\n        args += [str(increment), member]\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.ZAdd, args),\n        )\n\n    async def zcard(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the cardinality (number of elements) of the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zcard/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n\n        Returns:\n            int: The number of elements in the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n                3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n                0\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.ZCard, [key]))\n\n    async def zcount(\n        self,\n        key: TEncodable,\n        min_score: Union[InfBound, ScoreBoundary],\n        max_score: Union[InfBound, ScoreBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Returns the number of members in the sorted set stored at `key` with scores between `min_score` and `max_score`.\n\n        See https://valkey.io/commands/zcount/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_score (Union[InfBound, ScoreBoundary]): The minimum score to count from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n            max_score (Union[InfBound, ScoreBoundary]): The maximum score to count up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n\n        Returns:\n            int: The number of members in the specified score range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n            If `max_score` &lt; `min_score`, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n                2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n                1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n        \"\"\"\n        score_min = (\n            min_score.value[\"score_arg\"]\n            if type(min_score) == InfBound\n            else min_score.value\n        )\n        score_max = (\n            max_score.value[\"score_arg\"]\n            if type(max_score) == InfBound\n            else max_score.value\n        )\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZCount, [key, score_min, score_max]\n            ),\n        )\n\n    async def zincrby(\n        self, key: TEncodable, increment: float, member: TEncodable\n    ) -&gt; float:\n        \"\"\"\n        Increments the score of `member` in the sorted set stored at `key` by `increment`.\n        If `member` does not exist in the sorted set, it is added with `increment` as its score.\n        If `key` does not exist, a new sorted set is created with the specified member as its sole member.\n\n        See https://valkey.io/commands/zincrby/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            increment (float): The score increment.\n            member (TEncodable): A member of the sorted set.\n\n        Returns:\n            float: The new score of `member`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n                11.7  # The member existed in the set before score was altered, the new score is 11.7.\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n                10.0 # Negative increment, decrements the score.\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n                5.5  # A new member is added to the sorted set with the score being 5.5.\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(\n                RequestType.ZIncrBy, [key, str(increment), member]\n            ),\n        )\n\n    async def zpopmax(\n        self, key: TEncodable, count: Optional[int] = None\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Removes and returns the members with the highest scores from the sorted set stored at `key`.\n        If `count` is provided, up to `count` members with the highest scores are removed and returned.\n        Otherwise, only one member with the highest score is removed and returned.\n\n        See https://valkey.io/commands/zpopmax for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n            If `count` is higher than the sorted set's cardinality, returns all members and their scores, ordered from highest to lowest.\n\n        Returns:\n            Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.\n            If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n                {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n            &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n                {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n        \"\"\"\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(\n                RequestType.ZPopMax, [key, str(count)] if count else [key]\n            ),\n        )\n\n    async def bzpopmax(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[Union[bytes, float]]]:\n        \"\"\"\n        Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in\n        the order that they are given. Blocks the connection when there are no members to remove from any of the given\n        sorted sets.\n\n        When in cluster mode, all keys must map to the same hash slot.\n\n        `BZPOPMAX` is the blocking variant of `ZPOPMAX`.\n\n        `BZPOPMAX` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/bzpopmax for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            timeout (float): The number of seconds to wait for a blocking operation to complete.\n                A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n                and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n                2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n            &gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n                [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n        \"\"\"\n        return cast(\n            Optional[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.BZPopMax, keys + [str(timeout)]),\n        )\n\n    async def zpopmin(\n        self, key: TEncodable, count: Optional[int] = None\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Removes and returns the members with the lowest scores from the sorted set stored at `key`.\n        If `count` is provided, up to `count` members with the lowest scores are removed and returned.\n        Otherwise, only one member with the lowest score is removed and returned.\n\n        See https://valkey.io/commands/zpopmin for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n            If `count` is higher than the sorted set's cardinality, returns all members and their scores.\n\n        Returns:\n            Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.\n            If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n                {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n            &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n                {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count)] if count else [key]\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZPopMin, args),\n        )\n\n    async def bzpopmin(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[Union[bytes, float]]]:\n        \"\"\"\n        Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in\n        the order that they are given. Blocks the connection when there are no members to remove from any of the given\n        sorted sets.\n\n        When in cluster mode, all keys must map to the same hash slot.\n\n        `BZPOPMIN` is the blocking variant of `ZPOPMIN`.\n\n        `BZPOPMIN` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/bzpopmin for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            timeout (float): The number of seconds to wait for a blocking operation to complete.\n                A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n                and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n                2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n            &gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n                [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n        \"\"\"\n        args: List[TEncodable] = keys + [str(timeout)]\n        return cast(\n            Optional[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.BZPopMin, args),\n        )\n\n    async def zrange(\n        self,\n        key: TEncodable,\n        range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Returns the specified range of elements in the sorted set stored at `key`.\n\n        ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.\n\n        See https://valkey.io/commands/zrange/ for more details.\n\n        To get the elements with their scores, see zrange_withscores.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by lexicographical order, use RangeByLex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            List[bytes]: A list of elements within the specified range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty array.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n                [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n        \"\"\"\n        args = _create_zrange_args(key, range_query, reverse, with_scores=False)\n\n        return cast(List[bytes], await self._execute_command(RequestType.ZRange, args))\n\n    async def zrange_withscores(\n        self,\n        key: TEncodable,\n        range_query: Union[RangeByIndex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Returns the specified range of elements with their scores in the sorted set stored at `key`.\n        Similar to ZRANGE but with a WITHSCORE flag.\n\n        See https://valkey.io/commands/zrange/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            range_query (Union[RangeByIndex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            Mapping[bytes , float]: A map of elements and their scores within the specified range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n                {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n           &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.\n        \"\"\"\n        args = _create_zrange_args(key, range_query, reverse, with_scores=True)\n\n        return cast(\n            Mapping[bytes, float], await self._execute_command(RequestType.ZRange, args)\n        )\n\n    async def zrangestore(\n        self,\n        destination: TEncodable,\n        source: TEncodable,\n        range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Stores a specified range of elements from the sorted set at `source`, into a new sorted set at `destination`. If\n        `destination` doesn't exist, a new sorted set is created; if it exists, it's overwritten.\n\n        ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical\n        order.\n\n        See https://valkey.io/commands/zrangestore for more details.\n\n        Note:\n            When in Cluster mode, `source` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key for the destination sorted set.\n            source (TEncodable): The key of the source sorted set.\n            range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by lexicographical order, use RangeByLex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            int: The number of elements in the resulting sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n                3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n            &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n        \"\"\"\n        args = _create_zrange_args(source, range_query, reverse, False, destination)\n\n        return cast(int, await self._execute_command(RequestType.ZRangeStore, args))\n\n    async def zrank(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key`, with scores ordered from low to high.\n\n        See https://valkey.io/commands/zrank for more details.\n\n        To get the rank of `member` with its score, see `zrank_withscore`.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[int]: The rank of `member` in the sorted set.\n            If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n            Examples:\n            &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"member2\")\n                1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"non_existing_member\")\n                None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n        \"\"\"\n        return cast(\n            Optional[int], await self._execute_command(RequestType.ZRank, [key, member])\n        )\n\n    async def zrank_withscore(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; Optional[List[Union[int, float]]]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the lowest to highest.\n\n        See https://valkey.io/commands/zrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[List[Union[int, float]]]: A list containing the rank and score of `member` in the sorted set.\n            If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n                [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n                None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n\n        Since: Valkey version 7.2.0.\n        \"\"\"\n        return cast(\n            Optional[List[Union[int, float]]],\n            await self._execute_command(RequestType.ZRank, [key, member, \"WITHSCORE\"]),\n        )\n\n    async def zrevrank(self, key: TEncodable, member: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key`, where scores are ordered from the highest to\n        lowest, starting from `0`.\n\n        To get the rank of `member` with its score, see `zrevrank_withscore`.\n\n        See https://valkey.io/commands/zrevrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[int]: The rank of `member` in the sorted set, where ranks are ordered from high to low based on scores.\n                If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n                2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ZRevRank, [key, member]),\n        )\n\n    async def zrevrank_withscore(\n        self, key: TEncodable, member: TEncodable\n    ) -&gt; Optional[List[Union[int, float]]]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the\n        highest to lowest, starting from `0`.\n\n        See https://valkey.io/commands/zrevrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[List[Union[int, float]]]: A list containing the rank (as `int`) and score (as `float`) of `member`\n                in the sorted set, where ranks are ordered from high to low based on scores.\n                If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n                [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n\n        Since: Valkey version 7.2.0.\n        \"\"\"\n        return cast(\n            Optional[List[Union[int, float]]],\n            await self._execute_command(\n                RequestType.ZRevRank, [key, member, \"WITHSCORE\"]\n            ),\n        )\n\n    async def zrem(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Removes the specified members from the sorted set stored at `key`.\n        Specified members that are not a member of this set are ignored.\n\n        See https://valkey.io/commands/zrem/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): A list of members to remove from the sorted set.\n\n        Returns:\n            int: The number of members that were removed from the sorted set, not including non-existing members.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n                2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n            &gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZRem, [key] + members),\n        )\n\n    async def zremrangebyscore(\n        self,\n        key: TEncodable,\n        min_score: Union[InfBound, ScoreBoundary],\n        max_score: Union[InfBound, ScoreBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with a score between `min_score` and `max_score`.\n\n        See https://valkey.io/commands/zremrangebyscore/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_score (Union[InfBound, ScoreBoundary]): The minimum score to remove from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n            max_score (Union[InfBound, ScoreBoundary]): The maximum score to remove up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n        Returns:\n            int: The number of members that were removed from the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n            If `min_score` is greater than `max_score`, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n                2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        score_min = (\n            min_score.value[\"score_arg\"]\n            if type(min_score) == InfBound\n            else min_score.value\n        )\n        score_max = (\n            max_score.value[\"score_arg\"]\n            if type(max_score) == InfBound\n            else max_score.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByScore, [key, score_min, score_max]\n            ),\n        )\n\n    async def zremrangebylex(\n        self,\n        key: TEncodable,\n        min_lex: Union[InfBound, LexBoundary],\n        max_lex: Union[InfBound, LexBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with a lexicographical order between `min_lex` and\n        `max_lex`.\n\n        See https://valkey.io/commands/zremrangebylex/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_lex (Union[InfBound, LexBoundary]): The minimum bound of the lexicographical range.\n                Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n                representing a specific lex and inclusivity.\n            max_lex (Union[InfBound, LexBoundary]): The maximum bound of the lexicographical range.\n                Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n                representing a specific lex and inclusivity.\n\n        Returns:\n            int: The number of members that were removed from the sorted set.\n                If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n                If `min_lex` is greater than `max_lex`, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n                4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        min_lex_arg = (\n            min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n        )\n        max_lex_arg = (\n            max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByLex, [key, min_lex_arg, max_lex_arg]\n            ),\n        )\n\n    async def zremrangebyrank(\n        self,\n        key: TEncodable,\n        start: int,\n        end: int,\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with rank between `start` and `end`.\n        Both `start` and `end` are zero-based indexes with 0 being the element with the lowest score.\n        These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.\n\n        See https://valkey.io/commands/zremrangebyrank/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            int: The number of elements that were removed.\n                If `start` exceeds the end of the sorted set, or if `start` is greater than `end`, `0` is returned.\n                If `end` exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set.\n                If `key` does not exist, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n                5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n                0  # Indicates that nothing was removed.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByRank, [key, str(start), str(end)]\n            ),\n        )\n\n    async def zlexcount(\n        self,\n        key: TEncodable,\n        min_lex: Union[InfBound, LexBoundary],\n        max_lex: Union[InfBound, LexBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Returns the number of members in the sorted set stored at `key` with lexicographical values between `min_lex` and `max_lex`.\n\n        See https://valkey.io/commands/zlexcount/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_lex (Union[InfBound, LexBoundary]): The minimum lexicographical value to count from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or LexBoundary representing a specific lexicographical value and inclusivity.\n            max_lex (Union[InfBound, LexBoundary]): The maximum lexicographical to count up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or LexBoundary representing a specific lexicographical value and inclusivity.\n\n        Returns:\n            int: The number of members in the specified lexicographical range.\n                If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n                If `max_lex &lt; min_lex`, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n                2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n                1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n        \"\"\"\n        min_lex_arg = (\n            min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n        )\n        max_lex_arg = (\n            max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZLexCount, [key, min_lex_arg, max_lex_arg]\n            ),\n        )\n\n    async def zscore(self, key: TEncodable, member: TEncodable) -&gt; Optional[float]:\n        \"\"\"\n        Returns the score of `member` in the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zscore/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose score is to be retrieved.\n\n        Returns:\n            Optional[float]: The score of the member.\n            If `member` does not exist in the sorted set, None is returned.\n            If `key` does not exist,  None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n                10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n            &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n                None\n        \"\"\"\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.ZScore, [key, member]),\n        )\n\n    async def zmscore(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; List[Optional[float]]:\n        \"\"\"\n        Returns the scores associated with the specified `members` in the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zmscore for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): A list of members in the sorted set.\n\n        Returns:\n            List[Optional[float]]: A list of scores corresponding to `members`.\n                If a member does not exist in the sorted set, the corresponding value in the list will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n                [1.0, None, 3.0]\n        \"\"\"\n        return cast(\n            List[Optional[float]],\n            await self._execute_command(RequestType.ZMScore, [key] + members),\n        )\n\n    async def zdiff(self, keys: List[TEncodable]) -&gt; List[bytes]:\n        \"\"\"\n        Returns the difference between the first sorted set and all the successive sorted sets.\n        To get the elements with their scores, see `zdiff_withscores`.\n\n        When in Cluster mode, all keys must map to the same hash slot.\n\n        See https://valkey.io/commands/zdiff for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: A list of elements representing the difference between the sorted sets.\n                If the first key does not exist, it is treated as an empty sorted set, and the command returns an\n                empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n            &gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n                [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZDiff, args),\n        )\n\n    async def zdiff_withscores(self, keys: List[TEncodable]) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores.\n        When in Cluster mode, all keys must map to the same hash slot.\n\n        See https://valkey.io/commands/zdiff for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted\n                sets.\n                If the first `key` does not exist, it is treated as an empty sorted set, and the command returns an\n                empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n            &gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n                {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n        \"\"\"\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(\n                RequestType.ZDiff, [str(len(keys))] + keys + [\"WITHSCORES\"]\n            ),\n        )\n\n    async def zdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Calculates the difference between the first sorted set and all the successive sorted sets at `keys` and stores\n        the difference as a sorted set to `destination`, overwriting it if it already exists. Non-existent keys are\n        treated as empty sets.\n        See https://valkey.io/commands/zdiffstore for more details.\n\n        Note:\n            When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key for the resulting sorted set.\n            keys (List[TEncodable]): The keys of the sorted sets to compare.\n\n        Returns:\n            int: The number of members in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n                2  # Indicates that two elements have been added to the sorted set at \"key1\".\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n                1  # Indicates that one element has been added to the sorted set at \"key2\".\n            &gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n                ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZDiffStore, [destination, str(len(keys))] + keys\n            ),\n        )\n\n    async def zinter(\n        self,\n        keys: List[TEncodable],\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and returns a list of intersecting elements.\n        To get the scores as well, see `zinter_withscores`.\n        To store the result in a key as a sorted set, see `zinterstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinter/ for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: The resulting array of intersecting elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n                [b'member1']\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZInter, args),\n        )\n\n    async def zinter_withscores(\n        self,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and returns a sorted set of intersecting elements with scores.\n        To get the elements only, see `zinter`.\n        To store the result in a key as a sorted set, see `zinterstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinter/ for more details.\n\n        Args:\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            Mapping[bytes, float]: The resulting sorted set with scores.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n                {b'member1': 20}  # \"member1\" with score of 20 is the result\n            &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n                {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n        args.append(\"WITHSCORES\")\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZInter, args),\n        )\n\n    async def zinterstore(\n        self,\n        destination: TEncodable,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n        To get the result directly, see `zinter_withscores`.\n\n        When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinterstore/ for more details.\n\n        Args:\n            destination (TEncodable): The key of the destination sorted set.\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n            &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n                1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZInterStore, args),\n        )\n\n    async def zunion(\n        self,\n        keys: List[TEncodable],\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and returns a list of union elements.\n        To get the scores as well, see `zunion_withscores`.\n        To store the result in a key as a sorted set, see `zunionstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunion/ for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: The resulting array of union elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n                [b'member1', b'member2']\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZUnion, args),\n        )\n\n    async def zunion_withscores(\n        self,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and returns a sorted set of union elements with scores.\n        To get the elements only, see `zunion`.\n        To store the result in a key as a sorted set, see `zunionstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunion/ for more details.\n\n        Args:\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            Mapping[bytes, float]: The resulting sorted set with scores.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n                {b'member1': 20, b'member2': 8.2}\n            &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n                {b'member1': 10.5, b'member2': 8.2}\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n        args.append(\"WITHSCORES\")\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZUnion, args),\n        )\n\n    async def zunionstore(\n        self,\n        destination: TEncodable,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n        To get the result directly, see `zunion_withscores`.\n\n        When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunionstore/ for more details.\n\n        Args:\n            destination (TEncodable): The key of the destination sorted set.\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 20, b'member2': 8.2}\n            &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n                2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 10.5, b'member2': 8.2}\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZUnionStore, args),\n        )\n\n    async def zrandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random member from the sorted set stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n\n        Returns:\n            Optional[bytes]: A random member from the sorted set.\n                If the sorted set does not exist or is empty, the response will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n                b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n                None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.ZRandMember, [key]),\n        )\n\n    async def zrandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieves up to the absolute value of `count` random members from the sorted set stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[bytes]: A list of members from the sorted set.\n                If the sorted set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n                [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n                []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count)]\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZRandMember, args),\n        )\n\n    async def zrandmember_withscores(\n        self, key: TEncodable, count: int\n    ) -&gt; List[List[Union[bytes, float]]]:\n        \"\"\"\n        Retrieves up to the absolute value of `count` random members along with their scores from the sorted set\n        stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[List[Union[bytes, float]]]: A list of `[member, score]` lists, where `member` is a random member from\n                the sorted set and `score` is the associated score.\n                If the sorted set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n                [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n            &gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n                []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count), \"WITHSCORES\"]\n        return cast(\n            List[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.ZRandMember, args),\n        )\n\n    async def zmpop(\n        self,\n        keys: List[TEncodable],\n        filter: ScoreFilter,\n        count: Optional[int] = None,\n    ) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n        \"\"\"\n        Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n        that they are given.\n\n        The optional `count` argument can be used to specify the number of elements to pop, and is\n        set to 1 by default.\n\n        The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n        See https://valkey.io/commands/zmpop for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            filter (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n                members with the lowest/highest scores accordingly.\n            count (Optional[int]): The number of elements to pop.\n\n        Returns:\n            Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n                which elements were popped, and a member-score mapping of the popped elements. If no members could be\n                popped, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n            &gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n                [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))] + keys + [filter.value]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[List[Union[bytes, Mapping[bytes, float]]]],\n            await self._execute_command(RequestType.ZMPop, args),\n        )\n\n    async def bzmpop(\n        self,\n        keys: List[TEncodable],\n        modifier: ScoreFilter,\n        timeout: float,\n        count: Optional[int] = None,\n    ) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n        \"\"\"\n        Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n        that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.\n\n        The optional `count` argument can be used to specify the number of elements to pop, and is set to 1 by default.\n\n        The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n        `BZMPOP` is the blocking variant of `ZMPOP`.\n\n        See https://valkey.io/commands/bzmpop for more details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BZMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            modifier (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n                members with the lowest/highest scores accordingly.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will\n                block indefinitely.\n            count (Optional[int]): The number of elements to pop.\n\n        Returns:\n            Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n                which elements were popped, and a member-score mapping of the popped elements. If no members could be\n                popped and the timeout expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n            &gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n                [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(timeout), str(len(keys))] + keys + [modifier.value]\n        if count is not None:\n            args = args + [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[List[Union[bytes, Mapping[bytes, float]]]],\n            await self._execute_command(RequestType.BZMPop, args),\n        )\n\n    async def zintercard(\n        self, keys: List[TEncodable], limit: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Returns the cardinality of the intersection of the sorted sets specified by `keys`. When provided with the\n        optional `limit` argument, if the intersection cardinality reaches `limit` partway through the computation, the\n        algorithm will exit early and yield `limit` as the cardinality.\n\n        See https://valkey.io/commands/zintercard for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets to intersect.\n            limit (Optional[int]): An optional argument that can be used to specify a maximum number for the\n                intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Returns:\n            int: The cardinality of the intersection of the given sorted sets, or the `limit` if reached.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n            &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n                2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n            &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n                1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(len(keys))] + keys\n        if limit is not None:\n            args.extend([\"LIMIT\", str(limit)])\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZInterCard, args),\n        )\n\n    async def script_show(self, sha1: TEncodable) -&gt; bytes:\n        \"\"\"\n        Returns the original source code of a script in the script cache.\n\n        See https://valkey.io/commands/script-show for more details.\n\n        Args:\n            sha1 (TEncodable): The SHA1 digest of the script.\n\n        Returns:\n            bytes: The original source code of the script, if present in the cache.\n                If the script is not found in the cache, an error is thrown.\n\n        Example:\n            &gt;&gt;&gt; await client.script_show(script.get_hash())\n                b\"return { KEYS[1], ARGV[1] }\"\n\n        Since: Valkey version 8.0.0.\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.ScriptShow, [sha1]))\n\n    async def pfadd(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Adds all elements to the HyperLogLog data structure stored at the specified `key`.\n        Creates a new structure if the `key` does not exist.\n        When no elements are provided, and `key` exists and is a HyperLogLog, then no operation is performed.\n\n        See https://valkey.io/commands/pfadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the HyperLogLog data structure to add elements into.\n            elements (List[TEncodable]): A list of members to add to the HyperLogLog stored at `key`.\n\n        Returns:\n            int: If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is\n            altered, then returns 1. Otherwise, returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n                1 # A data structure was created or modified\n            &gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n                1 # A new empty data structure was created\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PfAdd, [key] + elements),\n        )\n\n    async def pfcount(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or\n        calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.\n\n        See https://valkey.io/commands/pfcount for more details.\n\n        Note:\n            When in Cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the HyperLogLog data structures to be analyzed.\n\n        Returns:\n            int: The approximated cardinality of given HyperLogLog data structures.\n                The cardinality of a key that does not exist is 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n                4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PfCount, keys),\n        )\n\n    async def pfmerge(\n        self, destination: TEncodable, source_keys: List[TEncodable]\n    ) -&gt; TOK:\n        \"\"\"\n        Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one\n        of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.\n\n        See https://valkey.io/commands/pfmerge for more details.\n\n        Note:\n            When in Cluster mode, all keys in `source_keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination HyperLogLog where the merged data sets will be stored.\n            source_keys (List[TEncodable]): The keys of the HyperLogLog structures to be merged.\n\n        Returns:\n            OK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n            &gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n            &gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n                OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n            &gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n                3  # The approximated cardinality of \"new_hll\" is 3.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.PfMerge, [destination] + source_keys\n            ),\n        )\n\n    async def bitcount(\n        self, key: TEncodable, options: Optional[OffsetOptions] = None\n    ) -&gt; int:\n        \"\"\"\n        Counts the number of set bits (population counting) in the string stored at `key`. The `options` argument can\n        optionally be provided to count the number of bits in a specific string interval.\n\n        See https://valkey.io/commands/bitcount for more details.\n\n        Args:\n            key (TEncodable): The key for the string to count the set bits of.\n            options (Optional[OffsetOptions]): The offset options.\n\n        Returns:\n            int: If `options` is provided, returns the number of set bits in the string interval specified by `options`.\n                If `options` is not provided, returns the number of set bits in the string stored at `key`.\n                Otherwise, if `key` is missing, returns `0` as it is treated as an empty string.\n\n        Examples:\n            &gt;&gt;&gt; await client.bitcount(\"my_key1\")\n                2  # The string stored at \"my_key1\" contains 2 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n                8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n                2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n                1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n            &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n                1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        if options is not None:\n            args.extend(options.to_args())\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitCount, args),\n        )\n\n    async def setbit(self, key: TEncodable, offset: int, value: int) -&gt; int:\n        \"\"\"\n        Sets or clears the bit at `offset` in the string value stored at `key`. The `offset` is a zero-based index,\n        with `0` being the first element of the list, `1` being the next element, and so on. The `offset` must be less\n        than `2^32` and greater than or equal to `0`. If a key is non-existent then the bit at `offset` is set to\n        `value` and the preceding bits are set to `0`.\n\n        See https://valkey.io/commands/setbit for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            offset (int): The index of the bit to be set.\n            value (int): The bit value to set at `offset`. The value must be `0` or `1`.\n\n        Returns:\n            int: The bit value that was previously stored at `offset`.\n\n        Examples:\n            &gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n                0  # The second bit value was 0 before setting to 1.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.SetBit, [key, str(offset), str(value)]\n            ),\n        )\n\n    async def getbit(self, key: TEncodable, offset: int) -&gt; int:\n        \"\"\"\n        Returns the bit value at `offset` in the string value stored at `key`.\n        `offset` should be greater than or equal to zero.\n\n        See https://valkey.io/commands/getbit for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            offset (int): The index of the bit to return.\n\n        Returns:\n            int: The bit at the given `offset` of the string. Returns `0` if the key is empty or if the `offset` exceeds\n                the length of the string.\n\n        Examples:\n            &gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n                1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.GetBit, [key, str(offset)]),\n        )\n\n    async def bitpos(\n        self, key: TEncodable, bit: int, start: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Returns the position of the first bit matching the given `bit` value. The optional starting offset\n        `start` is a zero-based index, with `0` being the first byte of the list, `1` being the next byte and so on.\n        The offset can also be a negative number indicating an offset starting at the end of the list, with `-1` being\n        the last byte of the list, `-2` being the penultimate, and so on.\n\n        See https://valkey.io/commands/bitpos for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            bit (int): The bit value to match. Must be `0` or `1`.\n            start (Optional[int]): The starting offset.\n\n        Returns:\n            int: The position of the first occurrence of `bit` in the binary value of the string held at `key`.\n                If `start` was provided, the search begins at the offset indicated by `start`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n            &gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n                1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n            &gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n                10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n        \"\"\"\n        args = [key, str(bit)] if start is None else [key, str(bit), str(start)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitPos, args),\n        )\n\n    async def bitpos_interval(\n        self,\n        key: TEncodable,\n        bit: int,\n        start: int,\n        end: int,\n        index_type: Optional[BitmapIndexType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Returns the position of the first bit matching the given `bit` value. The offsets are zero-based indexes, with\n        `0` being the first element of the list, `1` being the next, and so on. These offsets can also be negative\n        numbers indicating offsets starting at the end of the list, with `-1` being the last element of the list, `-2`\n        being the penultimate, and so on.\n\n        If you are using Valkey 7.0.0 or above, the optional `index_type` can also be provided to specify whether the\n        `start` and `end` offsets specify BIT or BYTE offsets. If `index_type` is not provided, BYTE offsets\n        are assumed. If BIT is specified, `start=0` and `end=2` means to look at the first three bits. If BYTE is\n        specified, `start=0` and `end=2` means to look at the first three bytes.\n\n        See https://valkey.io/commands/bitpos for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            bit (int): The bit value to match. Must be `0` or `1`.\n            start (int): The starting offset.\n            end (int): The ending offset.\n            index_type (Optional[BitmapIndexType]): The index offset type. This option can only be specified if you are\n                using Valkey version 7.0.0 or above. Could be either `BitmapIndexType.BYTE` or `BitmapIndexType.BIT`.\n                If no index type is provided, the indexes will be assumed to be byte indexes.\n\n        Returns:\n            int: The position of the first occurrence from the `start` to the `end` offsets of the `bit` in the binary\n                value of the string held at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n            &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n                10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n            &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n                7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n        \"\"\"\n        if index_type is not None:\n            args = [key, str(bit), str(start), str(end), index_type.value]\n        else:\n            args = [key, str(bit), str(start), str(end)]\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitPos, args),\n        )\n\n    async def bitop(\n        self,\n        operation: BitwiseOperation,\n        destination: TEncodable,\n        keys: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Perform a bitwise operation between multiple keys (containing string values) and store the result in the\n        `destination`.\n\n        See https://valkey.io/commands/bitop for more details.\n\n        Note:\n            When in cluster mode, `destination` and all `keys` must map to the same hash slot.\n\n        Args:\n            operation (BitwiseOperation): The bitwise operation to perform.\n            destination (TEncodable): The key that will store the resulting string.\n            keys (List[TEncodable]): The list of keys to perform the bitwise operation on.\n\n        Returns:\n            int: The size of the string stored in `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n            &gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n                1  # The size of the resulting string stored in \"destination\" is 1\n            &gt;&gt;&gt; await client.get(\"destination\")\n                \"@\"  # \"@\" has binary value 01000000\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.BitOp, [operation.value, destination] + keys\n            ),\n        )\n\n    async def bitfield(\n        self, key: TEncodable, subcommands: List[BitFieldSubCommands]\n    ) -&gt; List[Optional[int]]:\n        \"\"\"\n        Reads or modifies the array of bits representing the string that is held at `key` based on the specified\n        `subcommands`.\n\n        See https://valkey.io/commands/bitfield for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            subcommands (List[BitFieldSubCommands]): The subcommands to be performed on the binary value of the string\n                at `key`, which could be any of the following:\n                    - `BitFieldGet`\n                    - `BitFieldSet`\n                    - `BitFieldIncrBy`\n                    - `BitFieldOverflow`\n\n        Returns:\n            List[Optional[int]]: An array of results from the executed subcommands:\n                - `BitFieldGet` returns the value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldSet` returns the old value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldIncrBy` returns the new value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldOverflow` determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or\n                  underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list\n                  response.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n                [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n        \"\"\"\n        args = [key] + _create_bitfield_args(subcommands)\n        return cast(\n            List[Optional[int]],\n            await self._execute_command(RequestType.BitField, args),\n        )\n\n    async def bitfield_read_only(\n        self, key: TEncodable, subcommands: List[BitFieldGet]\n    ) -&gt; List[int]:\n        \"\"\"\n        Reads the array of bits representing the string that is held at `key` based on the specified `subcommands`.\n\n        See https://valkey.io/commands/bitfield_ro for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            subcommands (List[BitFieldGet]): The \"GET\" subcommands to be performed.\n\n        Returns:\n            List[int]: An array of results from the \"GET\" subcommands.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n                [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n\n        Since: Valkey version 6.0.0.\n        \"\"\"\n        args = [key] + _create_bitfield_read_only_args(subcommands)\n        return cast(\n            List[int],\n            await self._execute_command(RequestType.BitFieldReadOnly, args),\n        )\n\n    async def object_encoding(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns the internal encoding for the Valkey object stored at `key`.\n\n        See https://valkey.io/commands/object-encoding for more details.\n\n        Args:\n            key (TEncodable): The `key` of the object to get the internal encoding of.\n\n        Returns:\n            Optional[bytes]: If `key` exists, returns the internal encoding of the object stored at\n                `key` as a bytes string. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n                b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.ObjectEncoding, [key]),\n        )\n\n    async def object_freq(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the logarithmic access frequency counter of a Valkey object stored at `key`.\n\n        See https://valkey.io/commands/object-freq for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the logarithmic access frequency counter of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the logarithmic access frequency counter of the object stored at `key` as an\n                integer. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_freq(\"my_hash\")\n                2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectFreq, [key]),\n        )\n\n    async def object_idletime(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the time in seconds since the last access to the value stored at `key`.\n\n        See https://valkey.io/commands/object-idletime for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the idle time of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the idle time in seconds. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n                13  # \"my_hash\" was last accessed 13 seconds ago.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectIdleTime, [key]),\n        )\n\n    async def object_refcount(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the reference count of the object stored at `key`.\n\n        See https://valkey.io/commands/object-refcount for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the reference count of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the reference count of the object stored at `key` as an integer.\n                Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n                2  # \"my_hash\" has a reference count of 2.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectRefCount, [key]),\n        )\n\n    async def srandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random element from the set value stored at 'key'.\n\n        See https://valkey.io/commands/srandmember for more details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the set member.\n\n        Returns:\n            Optional[bytes]: A random element from the set, or None if 'key' does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.srandmember(b\"my_set\")\n                b\"member1\"  # \"member1\" is a random member of \"my_set\".\n            &gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n                None  # \"non_existing_set\" is not an existing key, so None was returned.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.SRandMember, args),\n        )\n\n    async def srandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Returns one or more random elements from the set value stored at 'key'.\n\n        See https://valkey.io/commands/srandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[bytes]: A list of members from the set.\n                If the set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n                [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n            &gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n                []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.SRandMember, [key, str(count)]),\n        )\n\n    async def getex(\n        self,\n        key: TEncodable,\n        expiry: Optional[ExpiryGetEx] = None,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Get the value of `key` and optionally set its expiration. `GETEX` is similar to `GET`.\n        See https://valkey.io/commands/getex for more details.\n\n        Args:\n            key (TEncodable): The key to get.\n            expiry (Optional[ExpiryGetEx], optional): set expiriation to the given key.\n                Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `PERSIST`] in the Valkey API.\n\n        Returns:\n            Optional[bytes]:\n                If `key` exists, return the value stored at `key`\n                If `key` does not exist, return `None`\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n                'OK'\n            &gt;&gt;&gt; await client.getex(\"key\")\n                b'value'\n            &gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n                b'value'\n            &gt;&gt;&gt; time.sleep(1)\n            &gt;&gt;&gt; await client.getex(b\"key\")\n                None\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = [key]\n        if expiry is not None:\n            args.extend(expiry.get_cmd_args())\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.GetEx, args),\n        )\n\n    async def dump(\n        self,\n        key: TEncodable,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Serialize the value stored at `key` in a Valkey-specific format and return it to the user.\n\n        See https://valkey.io/commands/dump for more details.\n\n        Args:\n            key (TEncodable): The `key` to serialize.\n\n        Returns:\n            Optional[bytes]: The serialized value of the data stored at `key`.\n                If `key` does not exist, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.dump(\"key\")\n                b\"value\" # The serialized value stored at `key`.\n            &gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n                None # Non-existing key will return `None`.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.Dump, [key]),\n        )\n\n    async def restore(\n        self,\n        key: TEncodable,\n        ttl: int,\n        value: TEncodable,\n        replace: bool = False,\n        absttl: bool = False,\n        idletime: Optional[int] = None,\n        frequency: Optional[int] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Create a `key` associated with a `value` that is obtained by deserializing the provided\n        serialized `value` obtained via `dump`.\n\n        See https://valkey.io/commands/restore for more details.\n\n        Note: `IDLETIME` and `FREQ` modifiers cannot be set at the same time.\n\n        Args:\n            key (TEncodable): The `key` to create.\n            ttl (int): The expiry time (in milliseconds). If `0`, the `key` will persist.\n            value (TEncodable) The serialized value to deserialize and assign to `key`.\n            replace (bool): Set to `True` to replace the key if it exists.\n            absttl (bool): Set to `True` to specify that `ttl` represents an absolute Unix\n                timestamp (in milliseconds).\n            idletime (Optional[int]): Set the `IDLETIME` option with object idletime to the given key.\n            frequency (Optional[int]): Set the `FREQ` option with object frequency to the given key.\n\n        Returns:\n            OK: If the `key` was successfully restored with a `value`.\n\n        Examples:\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n                OK # Indicates restore `newKey` without any ttl expiry nor any option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n                OK # Indicates restore `newKey` with `REPLACE` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n                OK # Indicates restore `newKey` with `ABSTTL` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n                OK # Indicates restore `newKey` with `IDLETIME` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n                OK # Indicates restore `newKey` with `FREQ` option\n        \"\"\"\n        args = [key, str(ttl), value]\n        if replace is True:\n            args.append(\"REPLACE\")\n        if absttl is True:\n            args.append(\"ABSTTL\")\n        if idletime is not None:\n            args.extend([\"IDLETIME\", str(idletime)])\n        if frequency is not None:\n            args.extend([\"FREQ\", str(frequency)])\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.Restore, args),\n        )\n\n    async def sscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a set.\n\n        See https://valkey.io/commands/sscan for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a\n                subset of the set then there could be a case where the result is empty although there are items that\n                match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n                only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the set.\n                `COUNT` could be ignored until the set is large enough for the `SCAN` commands to represent the results\n                as compact single-allocation packed encoding.\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the set held by `key`.\n                The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n                returned on the last iteration of the set. The second element is always an `Array` of the subset of the\n                set held in `key`.\n\n        Examples:\n            # Assume \"key\" contains a set with 130 members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor:  48\n            Members: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\n            Cursor: 24\n            Members: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\n            Cursor: 0\n            Members: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.SScan, args),\n        )\n\n    async def zscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        no_scores: bool = False,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a sorted set.\n\n        See https://valkey.io/commands/zscan for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return\n                only a subset of the sorted set then there could be a case where the result is empty although there are\n                items that match the pattern specified. This is due to the default `COUNT` being `10` which indicates\n                that it will only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the\n                sorted set. `COUNT` could be ignored until the sorted set is large enough for the `SCAN` commands to\n                represent the results as compact single-allocation packed encoding.\n            no_scores (bool): If `True`, the command will not return scores associated with the members. Since Valkey \"8.0.0\".\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the sorted set held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the sorted set. The second element is always an `Array` of the subset\n            of the sorted set held in `key`. The `Array` in the second element is a flattened series of\n            `String` pairs, where the value is at even indices and the score is at odd indices.\n            If `no_scores` is set to`True`, the second element will only contain the members without scores.\n\n        Examples:\n            # Assume \"key\" contains a sorted set with multiple members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 123\n            Members: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\n            Cursor: 47\n            Members: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\n            Cursor: 0\n            Members: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n\n            # Using no-score\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n            ...     new_cursor = str(result[0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 123\n            Members: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\n            Cursor: 47\n            Members: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\n            Cursor: 0\n            Members: [b'value 55', b'value 24', b'value 90', b'value 113']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n        if no_scores:\n            args.append(\"NOSCORES\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.ZScan, args),\n        )\n\n    async def hscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        no_values: bool = False,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a hash.\n\n        See https://valkey.io/commands/hscan for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a\n                subset of the hash then there could be a case where the result is empty although there are items that\n                match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n                only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the hash.\n                `COUNT` could be ignored until the hash is large enough for the `SCAN` commands to represent the results\n                as compact single-allocation packed encoding.\n            no_values (bool): If `True`, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the hash held by `key`.\n                The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n                returned on the last iteration of the hash. The second element is always an `Array` of the subset of the\n                hash held in `key`. The `Array` in the second element is a flattened series of `String` pairs,\n                where the value is at even indices and the score is at odd indices.\n                If `no_values` is set to `True`, the second element will only contain the fields without the values.\n\n        Examples:\n            # Assume \"key\" contains a hash with multiple members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 1\n            Members: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\n            Cursor: 39\n            Members: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\n            Cursor: 0\n            Members: [b'field 420', b'value 420', b'field 221', b'value 221']\n\n            # Use no-values\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 1\n            Members: [b'field 79',b'field 20', b'field 115']\n            Cursor: 39\n            Members: [b'field 63', b'field 293', b'field 162']\n            Cursor: 0\n            Members: [b'field 420', b'field 221']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n        if no_values:\n            args.append(\"NOVALUES\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.HScan, args),\n        )\n\n    async def fcall(\n        self,\n        function: TEncodable,\n        keys: Optional[List[TEncodable]] = None,\n        arguments: Optional[List[TEncodable]] = None,\n    ) -&gt; TResult:\n        \"\"\"\n        Invokes a previously loaded function.\n        See https://valkey.io/commands/fcall/ for more details.\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n        Args:\n            function (TEncodable): The function name.\n            keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct\n                execution of functions, both in standalone and clustered deployments, all names of keys\n                that a function accesses must be explicitly provided as `keys`.\n            arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n                should not represent names of keys.\n        Returns:\n            TResult:\n                The invoked function's return value.\n        Example:\n            &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")\n                b'new_value' # Returns the function's return value.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = []\n        if keys is not None:\n            args.extend([function, str(len(keys))] + keys)\n        else:\n            args.extend([function, str(0)])\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TResult,\n            await self._execute_command(RequestType.FCall, args),\n        )\n\n    async def fcall_ro(\n        self,\n        function: TEncodable,\n        keys: Optional[List[TEncodable]] = None,\n        arguments: Optional[List[TEncodable]] = None,\n    ) -&gt; TResult:\n        \"\"\"\n        Invokes a previously loaded read-only function.\n\n        See https://valkey.io/commands/fcall_ro for more details.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        Args:\n            function (TEncodable): The function name.\n            keys (List[TEncodable]): An `array` of keys accessed by the function. To ensure the correct\n                execution of functions, all names of keys that a function accesses must be\n                explicitly provided as `keys`.\n            arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n                represent names of keys.\n\n        Returns:\n            TResult: The return value depends on the function that was executed.\n\n        Examples:\n            &gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n                    \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n                42 # The return value on the function that was executed\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = []\n        if keys is not None:\n            args.extend([function, str(len(keys))] + keys)\n        else:\n            args.extend([function, str(0)])\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TResult,\n            await self._execute_command(RequestType.FCallReadOnly, args),\n        )\n\n    async def watch(self, keys: List[TEncodable]) -&gt; TOK:\n        \"\"\"\n        Marks the given keys to be watched for conditional execution of a transaction. Transactions\n        will only execute commands if the watched keys are not modified before execution of the\n        transaction.\n\n        See https://valkey.io/commands/watch for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The keys to watch.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.watch(\"sampleKey\")\n                'OK'\n            &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n            &gt;&gt;&gt; await client.exec(transaction)\n                'OK' # Executes successfully and keys are unwatched.\n\n            &gt;&gt;&gt; await client.watch(\"sampleKey\")\n                'OK'\n            &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n            &gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n                'OK'\n            &gt;&gt;&gt; await client.exec(transaction)\n                None  # None is returned when the watched key is modified before transaction execution.\n        \"\"\"\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.Watch, keys),\n        )\n\n    @dataclass\n    class PubSubMsg:\n        \"\"\"\n        Describes the incoming pubsub message\n\n        Attributes:\n            message (TEncodable): Incoming message.\n            channel (TEncodable): Name of an channel that triggered the message.\n            pattern (Optional[TEncodable]): Pattern that triggered the message.\n        \"\"\"\n\n        message: TEncodable\n        channel: TEncodable\n        pattern: Optional[TEncodable]\n\n    async def get_pubsub_message(self) -&gt; PubSubMsg:\n        \"\"\"\n        Returns the next pubsub message.\n        Throws WrongConfiguration in cases:\n        1. No pubsub subscriptions are configured for the client\n        2. Callback is configured with the pubsub subsciptions\n\n        See https://valkey.io/docs/topics/pubsub/ for more details.\n\n        Returns:\n            PubSubMsg: The next pubsub message\n\n        Examples:\n            &gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n        \"\"\"\n        ...\n\n    def try_get_pubsub_message(self) -&gt; Optional[PubSubMsg]:\n        \"\"\"\n        Tries to return the next pubsub message.\n        Throws WrongConfiguration in cases:\n        1. No pubsub subscriptions are configured for the client\n        2. Callback is configured with the pubsub subsciptions\n\n        See https://valkey.io/docs/topics/pubsub/ for more details.\n\n        Returns:\n            Optional[PubSubMsg]: The next pubsub message or None\n\n        Examples:\n            &gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n        \"\"\"\n        ...\n\n    async def lcs(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n    ) -&gt; bytes:\n        \"\"\"\n        Returns the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string.\n            key2 (TEncodable): The key that stores the second string.\n\n        Returns:\n            A Bytes String containing the longest common subsequence between the 2 strings.\n            An empty String is returned if the keys do not exist or have no common subsequences.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n                b'OK'\n            &gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n                b'acd'\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2]\n\n        return cast(\n            bytes,\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lcs_len(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Returns the length of the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string value.\n            key2 (TEncodable): The key that stores the second string value.\n\n        Returns:\n            The length of the longest common subsequence between the 2 strings.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n                'OK'\n            &gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n                3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2, \"LEN\"]\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lcs_idx(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n        min_match_len: Optional[int] = None,\n        with_match_len: Optional[bool] = False,\n    ) -&gt; Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]:\n        \"\"\"\n        Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string value.\n            key2 (TEncodable): The key that stores the second string value.\n            min_match_len (Optional[int]): The minimum length of matches to include in the result.\n            with_match_len (Optional[bool]): If True, include the length of the substring matched for each substring.\n\n        Returns:\n            A Mapping containing the indices of the longest common subsequence between the\n            2 strings and the length of the longest common subsequence. The resulting map contains two\n            keys, \"matches\" and \"len\":\n                - \"len\" is mapped to the length of the longest common subsequence between the 2 strings.\n                - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that\n                  represent the location of the common subsequences in the strings held by key1 and key2,\n                  with the length of the match after each matches, if with_match_len is enabled.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n                'OK'\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n                {\n                    b'matches': [\n                        [\n                            [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                            [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n                        ],\n                        [\n                            [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                            [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n                        ],\n                    ],\n                    b'len': 7  # length of the entire longest common subsequence\n                }\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n                {\n                    b'matches': [\n                        [\n                            [4, 7],\n                            [5, 8],\n                        ],\n                        # the other match with a length of 3 is excluded\n                    ],\n                    b'len': 7\n                }\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n                {\n                    b'matches': [\n                        [\n                            [4, 7],\n                            [5, 8],\n                            4,  # length of this match (b\"1234\")\n                        ],\n                        [\n                            [1, 3],\n                            [0, 2],\n                            3,  # length of this match (b\"bcd\")\n                        ],\n                    ],\n                    b'len': 7\n                }\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2, \"IDX\"]\n\n        if min_match_len is not None:\n            args.extend([\"MINMATCHLEN\", str(min_match_len)])\n\n        if with_match_len:\n            args.append(\"WITHMATCHLEN\")\n\n        return cast(\n            Mapping[bytes, Union[List[List[Union[List[int], int]]], int]],\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lpos(\n        self,\n        key: TEncodable,\n        element: TEncodable,\n        rank: Optional[int] = None,\n        count: Optional[int] = None,\n        max_len: Optional[int] = None,\n    ) -&gt; Union[int, List[int], None]:\n        \"\"\"\n        Returns the index or indexes of element(s) matching `element` in the `key` list. If no match is found,\n        None is returned.\n\n        See https://valkey.io/commands/lpos for more details.\n\n        Args:\n            key (TEncodable): The name of the list.\n            element (TEncodable): The value to search for within the list.\n            rank (Optional[int]): The rank of the match to return.\n            count (Optional[int]): The number of matches wanted. A `count` of 0 returns all the matches.\n            max_len (Optional[int]): The maximum number of comparisons to make between the element and the items\n                                     in the list. A `max_len` of 0 means unlimited amount of comparisons.\n\n        Returns:\n            Union[int, List[int], None]: The index of the first occurrence of `element`,\n            or None if `element` is not in the list.\n            With the `count` option, a list of indices of matching elements will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n            &gt;&gt;&gt; await client.lpos(key, 'c')\n                2\n            &gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n                6\n            &gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n                7\n            &gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n                [2, 6]\n            &gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n                [2, 6, 7]\n\n        Since: Valkey version 6.0.6.\n        \"\"\"\n        args: List[TEncodable] = [key, element]\n\n        if rank is not None:\n            args.extend([\"RANK\", str(rank)])\n\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        if max_len is not None:\n            args.extend([\"MAXLEN\", str(max_len)])\n\n        return cast(\n            Union[int, List[int], None],\n            await self._execute_command(RequestType.LPos, args),\n        )\n\n    async def pubsub_channels(\n        self, pattern: Optional[TEncodable] = None\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Lists the currently active channels.\n        The command is routed to all nodes, and aggregates the response to a single array.\n\n        See https://valkey.io/commands/pubsub-channels for more details.\n\n        Args:\n            pattern (Optional[TEncodable]): A glob-style pattern to match active channels.\n                                If not provided, all active channels are returned.\n\n        Returns:\n            List[bytes]: A list of currently active channels matching the given pattern.\n                    If no pattern is specified, all active channels are returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_channels()\n                [b\"channel1\", b\"channel2\"]\n\n            &gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n                [b\"news.sports\", \"news.weather\"]\n        \"\"\"\n\n        return cast(\n            List[bytes],\n            await self._execute_command(\n                RequestType.PubSubChannels, [pattern] if pattern else []\n            ),\n        )\n\n    async def pubsub_numpat(self) -&gt; int:\n        \"\"\"\n        Returns the number of unique patterns that are subscribed to by clients.\n\n        Note: This is the total number of unique patterns all the clients are subscribed to,\n        not the count of clients subscribed to patterns.\n        The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.\n\n        See https://valkey.io/commands/pubsub-numpat for more details.\n\n        Returns:\n            int: The number of unique patterns.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_numpat()\n                3\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.PubSubNumPat, []))\n\n    async def pubsub_numsub(\n        self, channels: Optional[List[TEncodable]] = None\n    ) -&gt; Mapping[bytes, int]:\n        \"\"\"\n        Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.\n\n        Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n        The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n        See https://valkey.io/commands/pubsub-numsub for more details.\n\n        Args:\n            channels (Optional[List[TEncodable]]): The list of channels to query for the number of subscribers.\n                                            If not provided, returns an empty map.\n\n        Returns:\n            Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n                {b'channel1': 3, b'channel2': 5}\n\n            &gt;&gt;&gt; await client.pubsub_numsub()\n                {}\n        \"\"\"\n        return cast(\n            Mapping[bytes, int],\n            await self._execute_command(\n                RequestType.PubSubNumSub, channels if channels else []\n            ),\n        )\n\n    async def sort(\n        self,\n        key: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n        The `sort` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n        This command is routed to primary nodes only.\n        To store the result into a new key, see `sort_store`.\n\n        Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            List[Optional[bytes]]: Returns a list of sorted elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n            &gt;&gt;&gt; await client.sort(\"mylist\")\n                [b'1', b'2', b'3']\n            &gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n                [b'3', b'2', b'1']\n            &gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n            &gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n                [b'2', b'2', b'3']\n            &gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n            &gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n            &gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n            &gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n                [b'Bob', b'Alice']\n        \"\"\"\n        args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n        result = await self._execute_command(RequestType.Sort, args)\n        return cast(List[Optional[bytes]], result)\n\n    async def sort_ro(\n        self,\n        key: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n        The `sort_ro` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n        This command is routed depending on the client's `ReadFrom` strategy.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_pattern (Optional[TEncodable]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            List[Optional[bytes]]: Returns a list of sorted elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n            &gt;&gt;&gt; await client.sort_ro(\"mylist\")\n                [b'1', b'2', b'3']\n            &gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n                [b'3', b'2', b'1']\n            &gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n            &gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n                [b'2', b'2', b'3']\n            &gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n            &gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n            &gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n            &gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n                [b'Bob', b'Alice']\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n        result = await self._execute_command(RequestType.SortReadOnly, args)\n        return cast(List[Optional[bytes]], result)\n\n    async def sort_store(\n        self,\n        key: TEncodable,\n        destination: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and stores the result in `store`.\n        The `sort` command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key.\n        To get the sort result without storing it into a key, see `sort`.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Note: When in cluster mode, `key`, `destination`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            destination (TEncodable): The key where the sorted result will be stored.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            int: The number of elements in the sorted key stored at `store`.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n            &gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n                3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n            &gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n                [b'1', b'2', b'3']\n        \"\"\"\n        args = _build_sort_args(\n            key, by_pattern, limit, get_patterns, order, alpha, store=destination\n        )\n        result = await self._execute_command(RequestType.Sort, args)\n        return cast(int, result)\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>A condition to the <code>SET</code>, <code>ZADD</code> and <code>GEOADD</code> commands. - ONLY_IF_EXISTS - Only update key / elements that already exist. Equivalent to <code>XX</code> in the Valkey API. - ONLY_IF_DOES_NOT_EXIST - Only set key / add elements that does not already exist. Equivalent to <code>NX</code> in the Valkey API.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ConditionalChange(Enum):\n    \"\"\"\n    A condition to the `SET`, `ZADD` and `GEOADD` commands.\n    - ONLY_IF_EXISTS - Only update key / elements that already exist. Equivalent to `XX` in the Valkey API.\n    - ONLY_IF_DOES_NOT_EXIST - Only set key / add elements that does not already exist. Equivalent to `NX` in the Valkey API.\n    \"\"\"\n\n    ONLY_IF_EXISTS = \"XX\"\n    ONLY_IF_DOES_NOT_EXIST = \"NX\"\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>SET option: The type of the expiry. - SEC - Set the specified expire time, in seconds. Equivalent to <code>EX</code> in the Valkey API. - MILLSEC - Set the specified expire time, in milliseconds. Equivalent to <code>PX</code> in the Valkey API. - UNIX_SEC - Set the specified Unix time at which the key will expire, in seconds. Equivalent to <code>EXAT</code> in the Valkey API. - UNIX_MILLSEC - Set the specified Unix time at which the key will expire, in milliseconds. Equivalent to <code>PXAT</code> in the     Valkey API. - KEEP_TTL - Retain the time to live associated with the key. Equivalent to <code>KEEPTTL</code> in the Valkey API.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ExpiryType(Enum):\n    \"\"\"SET option: The type of the expiry.\n    - SEC - Set the specified expire time, in seconds. Equivalent to `EX` in the Valkey API.\n    - MILLSEC - Set the specified expire time, in milliseconds. Equivalent to `PX` in the Valkey API.\n    - UNIX_SEC - Set the specified Unix time at which the key will expire, in seconds. Equivalent to `EXAT` in the Valkey API.\n    - UNIX_MILLSEC - Set the specified Unix time at which the key will expire, in milliseconds. Equivalent to `PXAT` in the\n        Valkey API.\n    - KEEP_TTL - Retain the time to live associated with the key. Equivalent to `KEEPTTL` in the Valkey API.\n    \"\"\"\n\n    SEC = 0, Union[int, timedelta]  # Equivalent to `EX` in the Valkey API\n    MILLSEC = 1, Union[int, timedelta]  # Equivalent to `PX` in the Valkey API\n    UNIX_SEC = 2, Union[int, datetime]  # Equivalent to `EXAT` in the Valkey API\n    UNIX_MILLSEC = 3, Union[int, datetime]  # Equivalent to `PXAT` in the Valkey API\n    KEEP_TTL = 4, Type[None]  # Equivalent to `KEEPTTL` in the Valkey API\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>GetEx option: The type of the expiry. - EX - Set the specified expire time, in seconds. Equivalent to <code>EX</code> in the Valkey API. - PX - Set the specified expire time, in milliseconds. Equivalent to <code>PX</code> in the Valkey API. - UNIX_SEC - Set the specified Unix time at which the key will expire, in seconds. Equivalent to <code>EXAT</code> in the Valkey API. - UNIX_MILLSEC - Set the specified Unix time at which the key will expire, in milliseconds. Equivalent to <code>PXAT</code> in the     Valkey API. - PERSIST - Remove the time to live associated with the key. Equivalent to <code>PERSIST</code> in the Valkey API.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ExpiryTypeGetEx(Enum):\n    \"\"\"GetEx option: The type of the expiry.\n    - EX - Set the specified expire time, in seconds. Equivalent to `EX` in the Valkey API.\n    - PX - Set the specified expire time, in milliseconds. Equivalent to `PX` in the Valkey API.\n    - UNIX_SEC - Set the specified Unix time at which the key will expire, in seconds. Equivalent to `EXAT` in the Valkey API.\n    - UNIX_MILLSEC - Set the specified Unix time at which the key will expire, in milliseconds. Equivalent to `PXAT` in the\n        Valkey API.\n    - PERSIST - Remove the time to live associated with the key. Equivalent to `PERSIST` in the Valkey API.\n    \"\"\"\n\n    SEC = 0, Union[int, timedelta]  # Equivalent to `EX` in the Valkey API\n    MILLSEC = 1, Union[int, timedelta]  # Equivalent to `PX` in the Valkey API\n    UNIX_SEC = 2, Union[int, datetime]  # Equivalent to `EXAT` in the Valkey API\n    UNIX_MILLSEC = 3, Union[int, datetime]  # Equivalent to `PXAT` in the Valkey API\n    PERSIST = 4, Type[None]  # Equivalent to `PERSIST` in the Valkey API\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>INFO option: a specific section of information:</p> <p>-SERVER: General information about the server -CLIENTS: Client connections section -MEMORY: Memory consumption related information -PERSISTENCE: RDB and AOF related information -STATS: General statistics -REPLICATION: Master/replica replication information -CPU: CPU consumption statistics -COMMANDSTATS: Valkey command statistics -LATENCYSTATS: Valkey command latency percentile distribution statistics -SENTINEL: Valkey Sentinel section (only applicable to Sentinel instances) -CLUSTER: Valkey Cluster section -MODULES: Modules section -KEYSPACE: Database related statistics -ERRORSTATS: Valkey error statistics -ALL: Return all sections (excluding module generated ones) -DEFAULT: Return only the default set of sections -EVERYTHING: Includes all and modules When no parameter is provided, the default option is assumed.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class InfoSection(Enum):\n    \"\"\"\n    INFO option: a specific section of information:\n\n    -SERVER: General information about the server\n    -CLIENTS: Client connections section\n    -MEMORY: Memory consumption related information\n    -PERSISTENCE: RDB and AOF related information\n    -STATS: General statistics\n    -REPLICATION: Master/replica replication information\n    -CPU: CPU consumption statistics\n    -COMMANDSTATS: Valkey command statistics\n    -LATENCYSTATS: Valkey command latency percentile distribution statistics\n    -SENTINEL: Valkey Sentinel section (only applicable to Sentinel instances)\n    -CLUSTER: Valkey Cluster section\n    -MODULES: Modules section\n    -KEYSPACE: Database related statistics\n    -ERRORSTATS: Valkey error statistics\n    -ALL: Return all sections (excluding module generated ones)\n    -DEFAULT: Return only the default set of sections\n    -EVERYTHING: Includes all and modules\n    When no parameter is provided, the default option is assumed.\n    \"\"\"\n\n    SERVER = \"server\"\n    CLIENTS = \"clients\"\n    MEMORY = \"memory\"\n    PERSISTENCE = \"persistence\"\n    STATS = \"stats\"\n    REPLICATION = \"replication\"\n    CPU = \"cpu\"\n    COMMAND_STATS = \"commandstats\"\n    LATENCY_STATS = \"latencystats\"\n    SENTINEL = \"sentinel\"\n    CLUSTER = \"cluster\"\n    MODULES = \"modules\"\n    KEYSPACE = \"keyspace\"\n    ERROR_STATS = \"errorstats\"\n    ALL = \"all\"\n    DEFAULT = \"default\"\n    EVERYTHING = \"everything\"\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>EXPIRE option: options for setting key expiry.</p> <ul> <li>HasNoExpiry: Set expiry only when the key has no expiry (Equivalent to \"NX\" in Valkey).</li> <li>HasExistingExpiry: Set expiry only when the key has an existing expiry (Equivalent to \"XX\" in Valkey).</li> <li>NewExpiryGreaterThanCurrent: Set expiry only when the new expiry is greater than the current one (Equivalent     to \"GT\" in Valkey).</li> <li>NewExpiryLessThanCurrent: Set expiry only when the new expiry is less than the current one (Equivalent to \"LT\" in Valkey).</li> </ul> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ExpireOptions(Enum):\n    \"\"\"\n    EXPIRE option: options for setting key expiry.\n\n    - HasNoExpiry: Set expiry only when the key has no expiry (Equivalent to \"NX\" in Valkey).\n    - HasExistingExpiry: Set expiry only when the key has an existing expiry (Equivalent to \"XX\" in Valkey).\n    - NewExpiryGreaterThanCurrent: Set expiry only when the new expiry is greater than the current one (Equivalent\n        to \"GT\" in Valkey).\n    - NewExpiryLessThanCurrent: Set expiry only when the new expiry is less than the current one (Equivalent to \"LT\" in Valkey).\n    \"\"\"\n\n    HasNoExpiry = \"NX\"\n    HasExistingExpiry = \"XX\"\n    NewExpiryGreaterThanCurrent = \"GT\"\n    NewExpiryLessThanCurrent = \"LT\"\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>Options for updating elements of a sorted set key.</p> <ul> <li>LESS_THAN: Only update existing elements if the new score is less than the current score.</li> <li>GREATER_THAN: Only update existing elements if the new score is greater than the current score.</li> </ul> Source code in <code>glide/async_commands/core.py</code> <pre><code>class UpdateOptions(Enum):\n    \"\"\"\n    Options for updating elements of a sorted set key.\n\n    - LESS_THAN: Only update existing elements if the new score is less than the current score.\n    - GREATER_THAN: Only update existing elements if the new score is greater than the current score.\n    \"\"\"\n\n    LESS_THAN = \"LT\"\n    GREATER_THAN = \"GT\"\n</code></pre> <p>SET option: Represents the expiry type and value to be executed with \"SET\" command.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ExpirySet:\n    \"\"\"SET option: Represents the expiry type and value to be executed with \"SET\" command.\"\"\"\n\n    def __init__(\n        self,\n        expiry_type: ExpiryType,\n        value: Optional[Union[int, datetime, timedelta]],\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            - expiry_type (ExpiryType): The expiry type.\n            - value (Optional[Union[int, datetime, timedelta]]): The value of the expiration type. The type of expiration\n                determines the type of expiration value:\n                - SEC: Union[int, timedelta]\n                - MILLSEC: Union[int, timedelta]\n                - UNIX_SEC: Union[int, datetime]\n                - UNIX_MILLSEC: Union[int, datetime]\n                - KEEP_TTL: Type[None]\n        \"\"\"\n        self.set_expiry_type_and_value(expiry_type, value)\n\n    def set_expiry_type_and_value(\n        self, expiry_type: ExpiryType, value: Optional[Union[int, datetime, timedelta]]\n    ):\n        if not isinstance(value, get_args(expiry_type.value[1])):\n            raise ValueError(\n                f\"The value of {expiry_type} should be of type {expiry_type.value[1]}\"\n            )\n        self.expiry_type = expiry_type\n        if self.expiry_type == ExpiryType.SEC:\n            self.cmd_arg = \"EX\"\n            if isinstance(value, timedelta):\n                value = int(value.total_seconds())\n        elif self.expiry_type == ExpiryType.MILLSEC:\n            self.cmd_arg = \"PX\"\n            if isinstance(value, timedelta):\n                value = int(value.total_seconds() * 1000)\n        elif self.expiry_type == ExpiryType.UNIX_SEC:\n            self.cmd_arg = \"EXAT\"\n            if isinstance(value, datetime):\n                value = int(value.timestamp())\n        elif self.expiry_type == ExpiryType.UNIX_MILLSEC:\n            self.cmd_arg = \"PXAT\"\n            if isinstance(value, datetime):\n                value = int(value.timestamp() * 1000)\n        elif self.expiry_type == ExpiryType.KEEP_TTL:\n            self.cmd_arg = \"KEEPTTL\"\n        self.value = str(value) if value else None\n\n    def get_cmd_args(self) -&gt; List[str]:\n        return [self.cmd_arg] if self.value is None else [self.cmd_arg, self.value]\n</code></pre> <p>GetEx option: Represents the expiry type and value to be executed with \"GetEx\" command.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class ExpiryGetEx:\n    \"\"\"GetEx option: Represents the expiry type and value to be executed with \"GetEx\" command.\"\"\"\n\n    def __init__(\n        self,\n        expiry_type: ExpiryTypeGetEx,\n        value: Optional[Union[int, datetime, timedelta]],\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            - expiry_type (ExpiryType): The expiry type.\n            - value (Optional[Union[int, datetime, timedelta]]): The value of the expiration type. The type of expiration\n                determines the type of expiration value:\n                - SEC: Union[int, timedelta]\n                - MILLSEC: Union[int, timedelta]\n                - UNIX_SEC: Union[int, datetime]\n                - UNIX_MILLSEC: Union[int, datetime]\n                - PERSIST: Type[None]\n        \"\"\"\n        self.set_expiry_type_and_value(expiry_type, value)\n\n    def set_expiry_type_and_value(\n        self,\n        expiry_type: ExpiryTypeGetEx,\n        value: Optional[Union[int, datetime, timedelta]],\n    ):\n        if not isinstance(value, get_args(expiry_type.value[1])):\n            raise ValueError(\n                f\"The value of {expiry_type} should be of type {expiry_type.value[1]}\"\n            )\n        self.expiry_type = expiry_type\n        if self.expiry_type == ExpiryTypeGetEx.SEC:\n            self.cmd_arg = \"EX\"\n            if isinstance(value, timedelta):\n                value = int(value.total_seconds())\n        elif self.expiry_type == ExpiryTypeGetEx.MILLSEC:\n            self.cmd_arg = \"PX\"\n            if isinstance(value, timedelta):\n                value = int(value.total_seconds() * 1000)\n        elif self.expiry_type == ExpiryTypeGetEx.UNIX_SEC:\n            self.cmd_arg = \"EXAT\"\n            if isinstance(value, datetime):\n                value = int(value.timestamp())\n        elif self.expiry_type == ExpiryTypeGetEx.UNIX_MILLSEC:\n            self.cmd_arg = \"PXAT\"\n            if isinstance(value, datetime):\n                value = int(value.timestamp() * 1000)\n        elif self.expiry_type == ExpiryTypeGetEx.PERSIST:\n            self.cmd_arg = \"PERSIST\"\n        self.value = str(value) if value else None\n\n    def get_cmd_args(self) -&gt; List[str]:\n        return [self.cmd_arg] if self.value is None else [self.cmd_arg, self.value]\n</code></pre> <p>               Bases: <code>Enum</code></p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class InsertPosition(Enum):\n    BEFORE = \"BEFORE\"\n    AFTER = \"AFTER\"\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>Defines flushing mode for:</p> <p><code>FLUSHALL</code> command and <code>FUNCTION FLUSH</code> command.</p> <p>See https://valkey.io/commands/flushall/ and https://valkey.io/commands/function-flush/ for details</p> <p>SYNC was introduced in version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class FlushMode(Enum):\n    \"\"\"\n    Defines flushing mode for:\n\n    `FLUSHALL` command and `FUNCTION FLUSH` command.\n\n    See https://valkey.io/commands/flushall/ and https://valkey.io/commands/function-flush/ for details\n\n    SYNC was introduced in version 6.2.0.\n    \"\"\"\n\n    ASYNC = \"ASYNC\"\n    SYNC = \"SYNC\"\n</code></pre> <p>               Bases: <code>Enum</code></p> <p>Options for the FUNCTION RESTORE command.</p> <ul> <li>APPEND: Appends the restored libraries to the existing libraries and aborts on collision. This is the     default policy.</li> <li>FLUSH: Deletes all existing libraries before restoring the payload.</li> <li>REPLACE: Appends the restored libraries to the existing libraries, replacing any existing ones in case     of name collisions. Note that this policy doesn't prevent function name collisions, only libraries.</li> </ul> Source code in <code>glide/async_commands/core.py</code> <pre><code>class FunctionRestorePolicy(Enum):\n    \"\"\"\n    Options for the FUNCTION RESTORE command.\n\n    - APPEND: Appends the restored libraries to the existing libraries and aborts on collision. This is the\n        default policy.\n    - FLUSH: Deletes all existing libraries before restoring the payload.\n    - REPLACE: Appends the restored libraries to the existing libraries, replacing any existing ones in case\n        of name collisions. Note that this policy doesn't prevent function name collisions, only libraries.\n    \"\"\"\n\n    APPEND = \"APPEND\"\n    FLUSH = \"FLUSH\"\n    REPLACE = \"REPLACE\"\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.PubSubMsg","title":"<code>PubSubMsg</code>  <code>dataclass</code>","text":"<p>Describes the incoming pubsub message</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>TEncodable</code> <p>Incoming message.</p> <code>channel</code> <code>TEncodable</code> <p>Name of an channel that triggered the message.</p> <code>pattern</code> <code>Optional[TEncodable]</code> <p>Pattern that triggered the message.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>@dataclass\nclass PubSubMsg:\n    \"\"\"\n    Describes the incoming pubsub message\n\n    Attributes:\n        message (TEncodable): Incoming message.\n        channel (TEncodable): Name of an channel that triggered the message.\n        pattern (Optional[TEncodable]): Pattern that triggered the message.\n    \"\"\"\n\n    message: TEncodable\n    channel: TEncodable\n    pattern: Optional[TEncodable]\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.append","title":"<code>append(key, value)</code>  <code>async</code>","text":"<p>Appends a value to a key. If <code>key</code> does not exist it is created and set as an empty string, so <code>APPEND</code> will be similar to <code>SET</code> in this special case.</p> <p>See https://valkey.io/commands/append for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to which the value will be appended.</p> required <code>value</code> <code>TEncodable</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the stored value after appending <code>value</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n    5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n&gt;&gt;&gt; await client.append(\"key\", \" world\")\n    11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n&gt;&gt;&gt; await client.get(\"key\")\n    b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def append(self, key: TEncodable, value: TEncodable) -&gt; int:\n    \"\"\"\n    Appends a value to a key.\n    If `key` does not exist it is created and set as an empty string, so `APPEND` will be similar to `SET` in this special case.\n\n    See https://valkey.io/commands/append for more details.\n\n    Args:\n        key (TEncodable): The key to which the value will be appended.\n        value (TEncodable): The value to append.\n\n    Returns:\n        int: The length of the stored value after appending `value`.\n\n    Examples:\n        &gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n            5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n        &gt;&gt;&gt; await client.append(\"key\", \" world\")\n            11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n        &gt;&gt;&gt; await client.get(\"key\")\n            b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Append, [key, value]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitcount","title":"<code>bitcount(key, options=None)</code>  <code>async</code>","text":"<p>Counts the number of set bits (population counting) in the string stored at <code>key</code>. The <code>options</code> argument can optionally be provided to count the number of bits in a specific string interval.</p> <p>See https://valkey.io/commands/bitcount for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key for the string to count the set bits of.</p> required <code>options</code> <code>Optional[OffsetOptions]</code> <p>The offset options.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>If <code>options</code> is provided, returns the number of set bits in the string interval specified by <code>options</code>. If <code>options</code> is not provided, returns the number of set bits in the string stored at <code>key</code>. Otherwise, if <code>key</code> is missing, returns <code>0</code> as it is treated as an empty string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.bitcount(\"my_key1\")\n    2  # The string stored at \"my_key1\" contains 2 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n    8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n    2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n    1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n&gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n    1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitcount(\n    self, key: TEncodable, options: Optional[OffsetOptions] = None\n) -&gt; int:\n    \"\"\"\n    Counts the number of set bits (population counting) in the string stored at `key`. The `options` argument can\n    optionally be provided to count the number of bits in a specific string interval.\n\n    See https://valkey.io/commands/bitcount for more details.\n\n    Args:\n        key (TEncodable): The key for the string to count the set bits of.\n        options (Optional[OffsetOptions]): The offset options.\n\n    Returns:\n        int: If `options` is provided, returns the number of set bits in the string interval specified by `options`.\n            If `options` is not provided, returns the number of set bits in the string stored at `key`.\n            Otherwise, if `key` is missing, returns `0` as it is treated as an empty string.\n\n    Examples:\n        &gt;&gt;&gt; await client.bitcount(\"my_key1\")\n            2  # The string stored at \"my_key1\" contains 2 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n            8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n            2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n            1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n        &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n            1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    if options is not None:\n        args.extend(options.to_args())\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitCount, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitfield","title":"<code>bitfield(key, subcommands)</code>  <code>async</code>","text":"<p>Reads or modifies the array of bits representing the string that is held at <code>key</code> based on the specified <code>subcommands</code>.</p> <p>See https://valkey.io/commands/bitfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>subcommands</code> <code>List[BitFieldSubCommands]</code> <p>The subcommands to be performed on the binary value of the string at <code>key</code>, which could be any of the following:     - <code>BitFieldGet</code>     - <code>BitFieldSet</code>     - <code>BitFieldIncrBy</code>     - <code>BitFieldOverflow</code></p> required <p>Returns:</p> Type Description <code>List[Optional[int]]</code> <p>List[Optional[int]]: An array of results from the executed subcommands: - <code>BitFieldGet</code> returns the value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldSet</code> returns the old value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldIncrBy</code> returns the new value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldOverflow</code> determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or   underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list   response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n    [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitfield(\n    self, key: TEncodable, subcommands: List[BitFieldSubCommands]\n) -&gt; List[Optional[int]]:\n    \"\"\"\n    Reads or modifies the array of bits representing the string that is held at `key` based on the specified\n    `subcommands`.\n\n    See https://valkey.io/commands/bitfield for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        subcommands (List[BitFieldSubCommands]): The subcommands to be performed on the binary value of the string\n            at `key`, which could be any of the following:\n                - `BitFieldGet`\n                - `BitFieldSet`\n                - `BitFieldIncrBy`\n                - `BitFieldOverflow`\n\n    Returns:\n        List[Optional[int]]: An array of results from the executed subcommands:\n            - `BitFieldGet` returns the value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldSet` returns the old value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldIncrBy` returns the new value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldOverflow` determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or\n              underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list\n              response.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n            [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n    \"\"\"\n    args = [key] + _create_bitfield_args(subcommands)\n    return cast(\n        List[Optional[int]],\n        await self._execute_command(RequestType.BitField, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitfield_read_only","title":"<code>bitfield_read_only(key, subcommands)</code>  <code>async</code>","text":"<p>Reads the array of bits representing the string that is held at <code>key</code> based on the specified <code>subcommands</code>.</p> <p>See https://valkey.io/commands/bitfield_ro for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>subcommands</code> <code>List[BitFieldGet]</code> <p>The \"GET\" subcommands to be performed.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: An array of results from the \"GET\" subcommands.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n    [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n</code></pre> <p>Since: Valkey version 6.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitfield_read_only(\n    self, key: TEncodable, subcommands: List[BitFieldGet]\n) -&gt; List[int]:\n    \"\"\"\n    Reads the array of bits representing the string that is held at `key` based on the specified `subcommands`.\n\n    See https://valkey.io/commands/bitfield_ro for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        subcommands (List[BitFieldGet]): The \"GET\" subcommands to be performed.\n\n    Returns:\n        List[int]: An array of results from the \"GET\" subcommands.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n            [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n\n    Since: Valkey version 6.0.0.\n    \"\"\"\n    args = [key] + _create_bitfield_read_only_args(subcommands)\n    return cast(\n        List[int],\n        await self._execute_command(RequestType.BitFieldReadOnly, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitop","title":"<code>bitop(operation, destination, keys)</code>  <code>async</code>","text":"<p>Perform a bitwise operation between multiple keys (containing string values) and store the result in the <code>destination</code>.</p> <p>See https://valkey.io/commands/bitop for more details.</p> Note <p>When in cluster mode, <code>destination</code> and all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>BitwiseOperation</code> <p>The bitwise operation to perform.</p> required <code>destination</code> <code>TEncodable</code> <p>The key that will store the resulting string.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to perform the bitwise operation on.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The size of the string stored in <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n&gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n    1  # The size of the resulting string stored in \"destination\" is 1\n&gt;&gt;&gt; await client.get(\"destination\")\n    \"@\"  # \"@\" has binary value 01000000\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitop(\n    self,\n    operation: BitwiseOperation,\n    destination: TEncodable,\n    keys: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Perform a bitwise operation between multiple keys (containing string values) and store the result in the\n    `destination`.\n\n    See https://valkey.io/commands/bitop for more details.\n\n    Note:\n        When in cluster mode, `destination` and all `keys` must map to the same hash slot.\n\n    Args:\n        operation (BitwiseOperation): The bitwise operation to perform.\n        destination (TEncodable): The key that will store the resulting string.\n        keys (List[TEncodable]): The list of keys to perform the bitwise operation on.\n\n    Returns:\n        int: The size of the string stored in `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n        &gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n            1  # The size of the resulting string stored in \"destination\" is 1\n        &gt;&gt;&gt; await client.get(\"destination\")\n            \"@\"  # \"@\" has binary value 01000000\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.BitOp, [operation.value, destination] + keys\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitpos","title":"<code>bitpos(key, bit, start=None)</code>  <code>async</code>","text":"<p>Returns the position of the first bit matching the given <code>bit</code> value. The optional starting offset <code>start</code> is a zero-based index, with <code>0</code> being the first byte of the list, <code>1</code> being the next byte and so on. The offset can also be a negative number indicating an offset starting at the end of the list, with <code>-1</code> being the last byte of the list, <code>-2</code> being the penultimate, and so on.</p> <p>See https://valkey.io/commands/bitpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>bit</code> <code>int</code> <p>The bit value to match. Must be <code>0</code> or <code>1</code>.</p> required <code>start</code> <code>Optional[int]</code> <p>The starting offset.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The position of the first occurrence of <code>bit</code> in the binary value of the string held at <code>key</code>. If <code>start</code> was provided, the search begins at the offset indicated by <code>start</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n&gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n    1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n&gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n    10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitpos(\n    self, key: TEncodable, bit: int, start: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Returns the position of the first bit matching the given `bit` value. The optional starting offset\n    `start` is a zero-based index, with `0` being the first byte of the list, `1` being the next byte and so on.\n    The offset can also be a negative number indicating an offset starting at the end of the list, with `-1` being\n    the last byte of the list, `-2` being the penultimate, and so on.\n\n    See https://valkey.io/commands/bitpos for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        bit (int): The bit value to match. Must be `0` or `1`.\n        start (Optional[int]): The starting offset.\n\n    Returns:\n        int: The position of the first occurrence of `bit` in the binary value of the string held at `key`.\n            If `start` was provided, the search begins at the offset indicated by `start`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n        &gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n            1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n        &gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n            10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n    \"\"\"\n    args = [key, str(bit)] if start is None else [key, str(bit), str(start)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitPos, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bitpos_interval","title":"<code>bitpos_interval(key, bit, start, end, index_type=None)</code>  <code>async</code>","text":"<p>Returns the position of the first bit matching the given <code>bit</code> value. The offsets are zero-based indexes, with <code>0</code> being the first element of the list, <code>1</code> being the next, and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with <code>-1</code> being the last element of the list, <code>-2</code> being the penultimate, and so on.</p> <p>If you are using Valkey 7.0.0 or above, the optional <code>index_type</code> can also be provided to specify whether the <code>start</code> and <code>end</code> offsets specify BIT or BYTE offsets. If <code>index_type</code> is not provided, BYTE offsets are assumed. If BIT is specified, <code>start=0</code> and <code>end=2</code> means to look at the first three bits. If BYTE is specified, <code>start=0</code> and <code>end=2</code> means to look at the first three bytes.</p> <p>See https://valkey.io/commands/bitpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>bit</code> <code>int</code> <p>The bit value to match. Must be <code>0</code> or <code>1</code>.</p> required <code>start</code> <code>int</code> <p>The starting offset.</p> required <code>end</code> <code>int</code> <p>The ending offset.</p> required <code>index_type</code> <code>Optional[BitmapIndexType]</code> <p>The index offset type. This option can only be specified if you are using Valkey version 7.0.0 or above. Could be either <code>BitmapIndexType.BYTE</code> or <code>BitmapIndexType.BIT</code>. If no index type is provided, the indexes will be assumed to be byte indexes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The position of the first occurrence from the <code>start</code> to the <code>end</code> offsets of the <code>bit</code> in the binary value of the string held at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n&gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n    10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n&gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n    7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitpos_interval(\n    self,\n    key: TEncodable,\n    bit: int,\n    start: int,\n    end: int,\n    index_type: Optional[BitmapIndexType] = None,\n) -&gt; int:\n    \"\"\"\n    Returns the position of the first bit matching the given `bit` value. The offsets are zero-based indexes, with\n    `0` being the first element of the list, `1` being the next, and so on. These offsets can also be negative\n    numbers indicating offsets starting at the end of the list, with `-1` being the last element of the list, `-2`\n    being the penultimate, and so on.\n\n    If you are using Valkey 7.0.0 or above, the optional `index_type` can also be provided to specify whether the\n    `start` and `end` offsets specify BIT or BYTE offsets. If `index_type` is not provided, BYTE offsets\n    are assumed. If BIT is specified, `start=0` and `end=2` means to look at the first three bits. If BYTE is\n    specified, `start=0` and `end=2` means to look at the first three bytes.\n\n    See https://valkey.io/commands/bitpos for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        bit (int): The bit value to match. Must be `0` or `1`.\n        start (int): The starting offset.\n        end (int): The ending offset.\n        index_type (Optional[BitmapIndexType]): The index offset type. This option can only be specified if you are\n            using Valkey version 7.0.0 or above. Could be either `BitmapIndexType.BYTE` or `BitmapIndexType.BIT`.\n            If no index type is provided, the indexes will be assumed to be byte indexes.\n\n    Returns:\n        int: The position of the first occurrence from the `start` to the `end` offsets of the `bit` in the binary\n            value of the string held at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n        &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n            10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n        &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n            7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n    \"\"\"\n    if index_type is not None:\n        args = [key, str(bit), str(start), str(end), index_type.value]\n    else:\n        args = [key, str(bit), str(start), str(end)]\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitPos, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.blmove","title":"<code>blmove(source, destination, where_from, where_to, timeout)</code>  <code>async</code>","text":"<p>Blocks the connection until it pops atomically and removes the left/right-most element to the list stored at <code>source</code> depending on <code>where_from</code>, and pushes the element at the first/last element of the list stored at <code>destination</code> depending on <code>where_to</code>. <code>BLMOVE</code> is the blocking variant of <code>LMOVE</code>.</p> Notes <ol> <li>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</li> <li><code>BLMOVE</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>See https://valkey.io/commands/blmove/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source list.</p> required <code>destination</code> <code>TEncodable</code> <p>The key to the destination list.</p> required <code>where_from</code> <code>ListDirection</code> <p>The direction to remove the element from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>where_to</code> <code>ListDirection</code> <p>The direction to add the element to (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of <code>0</code> will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The popped element, or None if <code>source</code> does not exist or if the operation timed-out.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n&gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n&gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n    b\"one\"\n&gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n    [b\"two\"]\n&gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n    [b\"one\", b\"three\", bb\"four\"]\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blmove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    where_from: ListDirection,\n    where_to: ListDirection,\n    timeout: float,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Blocks the connection until it pops atomically and removes the left/right-most element to the\n    list stored at `source` depending on `where_from`, and pushes the element at the first/last element\n    of the list stored at `destination` depending on `where_to`.\n    `BLMOVE` is the blocking variant of `LMOVE`.\n\n    Notes:\n        1. When in cluster mode, both `source` and `destination` must map to the same hash slot.\n        2. `BLMOVE` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/blmove/ for details.\n\n    Args:\n        source (TEncodable): The key to the source list.\n        destination (TEncodable): The key to the destination list.\n        where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n\n    Returns:\n        Optional[bytes]: The popped element, or None if `source` does not exist or if the operation timed-out.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n        &gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n        &gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n            b\"one\"\n        &gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n            [b\"two\"]\n        &gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n            [b\"one\", b\"three\", bb\"four\"]\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(\n            RequestType.BLMove,\n            [source, destination, where_from.value, where_to.value, str(timeout)],\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.blmpop","title":"<code>blmpop(keys, direction, timeout, count=None)</code>  <code>async</code>","text":"<p>Blocks the connection until it pops one or more elements from the first non-empty list from the provided <code>keys</code>.</p> <p><code>BLMPOP</code> is the blocking variant of <code>LMPOP</code>.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BLMPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>See https://valkey.io/commands/blmpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>An array of keys of lists.</p> required <code>direction</code> <code>ListDirection</code> <p>The direction based on which elements are popped from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of <code>0</code> will block indefinitely.</p> required <code>count</code> <code>Optional[int]</code> <p>The maximum number of popped elements. If not provided, defaults to popping a single element.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[bytes]]]</code> <p>Optional[Mapping[bytes, List[bytes]]]: A map of <code>key</code> name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n&gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n   {b\"testKey\": [b\"three\", b\"two\"]}\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blmpop(\n    self,\n    keys: List[TEncodable],\n    direction: ListDirection,\n    timeout: float,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n    \"\"\"\n    Blocks the connection until it pops one or more elements from the first non-empty list from the provided `keys`.\n\n    `BLMPOP` is the blocking variant of `LMPOP`.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BLMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/blmpop/ for details.\n\n    Args:\n        keys (List[TEncodable]): An array of keys of lists.\n        direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n        count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n    Returns:\n        Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n        &gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n           {b\"testKey\": [b\"three\", b\"two\"]}\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(timeout), str(len(keys)), *keys, direction.value]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[Mapping[bytes, List[bytes]]],\n        await self._execute_command(RequestType.BLMPop, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.blpop","title":"<code>blpop(keys, timeout)</code>  <code>async</code>","text":"<p>Pops an element from the head of the first list that is non-empty, with the given keys being checked in the order that they are given. Blocks the connection when there are no elements to pop from any of the given lists. See https://valkey.io/commands/blpop for details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BLPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the lists to pop from.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the popped element, formatted as <code>[key, value]</code>. If no element could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n    [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blpop(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Pops an element from the head of the first list that is non-empty, with the given keys being checked in the\n    order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n    See https://valkey.io/commands/blpop for details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BLPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the lists to pop from.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n            popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n            [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.BLPop, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.brpop","title":"<code>brpop(keys, timeout)</code>  <code>async</code>","text":"<p>Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given. Blocks the connection when there are no elements to pop from any of the given lists. See https://valkey.io/commands/brpop for details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BRPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the lists to pop from.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the popped element, formatted as <code>[key, value]</code>. If no element could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n    [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def brpop(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the\n    order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n    See https://valkey.io/commands/brpop for details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BRPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the lists to pop from.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n            popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n            [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.BRPop, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bzmpop","title":"<code>bzmpop(keys, modifier, timeout, count=None)</code>  <code>async</code>","text":"<p>Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.</p> <p>The optional <code>count</code> argument can be used to specify the number of elements to pop, and is set to 1 by default.</p> <p>The number of popped elements is the minimum from the sorted set's cardinality and <code>count</code>.</p> <p><code>BZMPOP</code> is the blocking variant of <code>ZMPOP</code>.</p> <p>See https://valkey.io/commands/bzmpop for more details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BZMPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>modifier</code> <code>ScoreFilter</code> <p>The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop members with the lowest/highest scores accordingly.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of elements to pop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, Mapping[bytes, float]]]]</code> <p>Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from which elements were popped, and a member-score mapping of the popped elements. If no members could be popped and the timeout expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n&gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n    [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzmpop(\n    self,\n    keys: List[TEncodable],\n    modifier: ScoreFilter,\n    timeout: float,\n    count: Optional[int] = None,\n) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n    \"\"\"\n    Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n    that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.\n\n    The optional `count` argument can be used to specify the number of elements to pop, and is set to 1 by default.\n\n    The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n    `BZMPOP` is the blocking variant of `ZMPOP`.\n\n    See https://valkey.io/commands/bzmpop for more details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BZMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        modifier (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n            members with the lowest/highest scores accordingly.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will\n            block indefinitely.\n        count (Optional[int]): The number of elements to pop.\n\n    Returns:\n        Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n            which elements were popped, and a member-score mapping of the popped elements. If no members could be\n            popped and the timeout expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n        &gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n            [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(timeout), str(len(keys))] + keys + [modifier.value]\n    if count is not None:\n        args = args + [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[List[Union[bytes, Mapping[bytes, float]]]],\n        await self._execute_command(RequestType.BZMPop, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bzpopmax","title":"<code>bzpopmax(keys, timeout)</code>  <code>async</code>","text":"<p>Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to remove from any of the given sorted sets.</p> <p>When in cluster mode, all keys must map to the same hash slot.</p> <p><code>BZPOPMAX</code> is the blocking variant of <code>ZPOPMAX</code>.</p> <p><code>BZPOPMAX</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</p> <p>See https://valkey.io/commands/bzpopmax for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, float]]]</code> <p>Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself, and the member score. If no member could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n    2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n&gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n    [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzpopmax(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[Union[bytes, float]]]:\n    \"\"\"\n    Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in\n    the order that they are given. Blocks the connection when there are no members to remove from any of the given\n    sorted sets.\n\n    When in cluster mode, all keys must map to the same hash slot.\n\n    `BZPOPMAX` is the blocking variant of `ZPOPMAX`.\n\n    `BZPOPMAX` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/bzpopmax for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        timeout (float): The number of seconds to wait for a blocking operation to complete.\n            A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n            and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n            2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n        &gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n            [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n    \"\"\"\n    return cast(\n        Optional[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.BZPopMax, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.bzpopmin","title":"<code>bzpopmin(keys, timeout)</code>  <code>async</code>","text":"<p>Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to remove from any of the given sorted sets.</p> <p>When in cluster mode, all keys must map to the same hash slot.</p> <p><code>BZPOPMIN</code> is the blocking variant of <code>ZPOPMIN</code>.</p> <p><code>BZPOPMIN</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</p> <p>See https://valkey.io/commands/bzpopmin for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, float]]]</code> <p>Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself, and the member score. If no member could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n    2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n&gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n    [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzpopmin(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[Union[bytes, float]]]:\n    \"\"\"\n    Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in\n    the order that they are given. Blocks the connection when there are no members to remove from any of the given\n    sorted sets.\n\n    When in cluster mode, all keys must map to the same hash slot.\n\n    `BZPOPMIN` is the blocking variant of `ZPOPMIN`.\n\n    `BZPOPMIN` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/bzpopmin for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        timeout (float): The number of seconds to wait for a blocking operation to complete.\n            A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n            and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n            2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n        &gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n            [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n    \"\"\"\n    args: List[TEncodable] = keys + [str(timeout)]\n    return cast(\n        Optional[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.BZPopMin, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.decr","title":"<code>decr(key)</code>  <code>async</code>","text":"<p>Decrement the number stored at <code>key</code> by one. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/decr/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the decrement.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.decr(\"key\")\n    9\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def decr(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Decrement the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n    operation.\n    See https://valkey.io/commands/decr/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n\n    Returns:\n        int: The value of key after the decrement.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.decr(\"key\")\n            9\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Decr, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.decrby","title":"<code>decrby(key, amount)</code>  <code>async</code>","text":"<p>Decrements the number stored at <code>key</code> by <code>amount</code>. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/decrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to decrement its value.</p> required <code>amount</code> <code>int) </code> <p>The amount to decrement.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the decrement.</p> Example <p>await client.set(\"key\", \"10\") await client.decrby(\"key\" , 5)     5</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def decrby(self, key: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Decrements the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n    the operation.\n    See https://valkey.io/commands/decrby/ for more details.\n\n    Args:\n      key (TEncodable): The key to decrement its value.\n      amount (int) : The amount to decrement.\n\n    Returns:\n        int: The value of key after the decrement.\n\n    Example:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.decrby(\"key\" , 5)\n            5\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.DecrBy, [key, str(amount)])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.delete","title":"<code>delete(keys)</code>  <code>async</code>","text":"<p>Delete one or more keys from the database. A key is ignored if it does not exist. See https://valkey.io/commands/del/ for details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys to be deleted from the database.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.delete([\"key\"])\n    1 # Indicates that the key was successfully deleted.\n&gt;&gt;&gt; await client.delete([\"key\"])\n    0 # No keys we're deleted since \"key\" doesn't exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def delete(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Delete one or more keys from the database. A key is ignored if it does not exist.\n    See https://valkey.io/commands/del/ for details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): A list of keys to be deleted from the database.\n\n    Returns:\n        int: The number of keys that were deleted.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.delete([\"key\"])\n            1 # Indicates that the key was successfully deleted.\n        &gt;&gt;&gt; await client.delete([\"key\"])\n            0 # No keys we're deleted since \"key\" doesn't exist.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Del, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.dump","title":"<code>dump(key)</code>  <code>async</code>","text":"<p>Serialize the value stored at <code>key</code> in a Valkey-specific format and return it to the user.</p> <p>See https://valkey.io/commands/dump for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to serialize.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The serialized value of the data stored at <code>key</code>. If <code>key</code> does not exist, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.dump(\"key\")\n    b\"value\" # The serialized value stored at `key`.\n&gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n    None # Non-existing key will return `None`.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def dump(\n    self,\n    key: TEncodable,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Serialize the value stored at `key` in a Valkey-specific format and return it to the user.\n\n    See https://valkey.io/commands/dump for more details.\n\n    Args:\n        key (TEncodable): The `key` to serialize.\n\n    Returns:\n        Optional[bytes]: The serialized value of the data stored at `key`.\n            If `key` does not exist, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.dump(\"key\")\n            b\"value\" # The serialized value stored at `key`.\n        &gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n            None # Non-existing key will return `None`.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.Dump, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.exists","title":"<code>exists(keys)</code>  <code>async</code>","text":"<p>Returns the number of keys in <code>keys</code> that exist in the database. See https://valkey.io/commands/exists/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to check.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that exist. If the same existing key is mentioned in <code>keys</code> multiple times, it will be counted multiple times.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n    3  # Indicates that all three keys exist in the database.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def exists(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Returns the number of keys in `keys` that exist in the database.\n    See https://valkey.io/commands/exists/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The list of keys to check.\n\n    Returns:\n        int: The number of keys that exist. If the same existing key is mentioned in `keys` multiple times,\n            it will be counted multiple times.\n\n    Examples:\n        &gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n            3  # Indicates that all three keys exist in the database.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Exists, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.expire","title":"<code>expire(key, seconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> in seconds. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. If <code>seconds</code> is a non-positive number, the key will be deleted rather than expired. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/expire/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>seconds</code> <code>int</code> <p>The timeout in seconds.</p> required <code>option</code> <code>ExpireOptions</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n    True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expire(\n    self,\n    key: TEncodable,\n    seconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` in seconds. After the timeout has expired, the key will automatically be deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    If `seconds` is a non-positive number, the key will be deleted rather than expired.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/expire/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        seconds (int): The timeout in seconds.\n        option (ExpireOptions, optional): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n    \"\"\"\n    args: List[TEncodable] = (\n        [key, str(seconds)] if option is None else [key, str(seconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.Expire, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.expireat","title":"<code>expireat(key, unix_seconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the number of seconds. A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/expireat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>unix_seconds</code> <code>int</code> <p>The timeout in an absolute Unix timestamp.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n    True\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expireat(\n    self,\n    key: TEncodable,\n    unix_seconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the\n    number of seconds.\n    A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n    deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/expireat/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        unix_seconds (int): The timeout in an absolute Unix timestamp.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n            True\n    \"\"\"\n    args = (\n        [key, str(unix_seconds)]\n        if option is None\n        else [key, str(unix_seconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.ExpireAt, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.expiretime","title":"<code>expiretime(key)</code>  <code>async</code>","text":"<p>Returns the absolute Unix timestamp (since January 1, 1970) at which the given <code>key</code> will expire, in seconds. To get the expiration with millisecond precision, use <code>pexpiretime</code>.</p> <p>See https://valkey.io/commands/expiretime/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to determine the expiration value of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expiration Unix timestamp in seconds, -2 if <code>key</code> does not exist or -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    -2 # 'my_key' doesn't exist.\n&gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    -1 # 'my_key' has no associate expiration.\n&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    1718614954\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expiretime(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the absolute Unix timestamp (since January 1, 1970) at which\n    the given `key` will expire, in seconds.\n    To get the expiration with millisecond precision, use `pexpiretime`.\n\n    See https://valkey.io/commands/expiretime/ for details.\n\n    Args:\n        key (TEncodable): The `key` to determine the expiration value of.\n\n    Returns:\n        int: The expiration Unix timestamp in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            -2 # 'my_key' doesn't exist.\n        &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            -1 # 'my_key' has no associate expiration.\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            1718614954\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.ExpireTime, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.fcall","title":"<code>fcall(function, keys=None, arguments=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded function. See https://valkey.io/commands/fcall/ for more details. When in cluster mode, all keys in <code>keys</code> must map to the same hash slot. Args:     function (TEncodable): The function name.     keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct         execution of functions, both in standalone and clustered deployments, all names of keys         that a function accesses must be explicitly provided as <code>keys</code>.     arguments (Optional[List[TEncodable]]): A list of <code>function</code> arguments. <code>Arguments</code>         should not represent names of keys. Returns:     TResult:         The invoked function's return value. Example:     &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")         b'new_value' # Returns the function's return value.</p> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def fcall(\n    self,\n    function: TEncodable,\n    keys: Optional[List[TEncodable]] = None,\n    arguments: Optional[List[TEncodable]] = None,\n) -&gt; TResult:\n    \"\"\"\n    Invokes a previously loaded function.\n    See https://valkey.io/commands/fcall/ for more details.\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n    Args:\n        function (TEncodable): The function name.\n        keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct\n            execution of functions, both in standalone and clustered deployments, all names of keys\n            that a function accesses must be explicitly provided as `keys`.\n        arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n            should not represent names of keys.\n    Returns:\n        TResult:\n            The invoked function's return value.\n    Example:\n        &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")\n            b'new_value' # Returns the function's return value.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = []\n    if keys is not None:\n        args.extend([function, str(len(keys))] + keys)\n    else:\n        args.extend([function, str(0)])\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TResult,\n        await self._execute_command(RequestType.FCall, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.fcall_ro","title":"<code>fcall_ro(function, keys=None, arguments=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded read-only function.</p> <p>See https://valkey.io/commands/fcall_ro for more details.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>TEncodable</code> <p>The function name.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>An <code>array</code> of keys accessed by the function. To ensure the correct execution of functions, all names of keys that a function accesses must be explicitly provided as <code>keys</code>.</p> <code>None</code> <code>arguments</code> <code>List[TEncodable]</code> <p>An <code>array</code> of <code>function</code> arguments. <code>arguments</code> should not represent names of keys.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TResult</code> <p>The return value depends on the function that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n        \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n    42 # The return value on the function that was executed\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def fcall_ro(\n    self,\n    function: TEncodable,\n    keys: Optional[List[TEncodable]] = None,\n    arguments: Optional[List[TEncodable]] = None,\n) -&gt; TResult:\n    \"\"\"\n    Invokes a previously loaded read-only function.\n\n    See https://valkey.io/commands/fcall_ro for more details.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    Args:\n        function (TEncodable): The function name.\n        keys (List[TEncodable]): An `array` of keys accessed by the function. To ensure the correct\n            execution of functions, all names of keys that a function accesses must be\n            explicitly provided as `keys`.\n        arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n            represent names of keys.\n\n    Returns:\n        TResult: The return value depends on the function that was executed.\n\n    Examples:\n        &gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n                \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n            42 # The return value on the function that was executed\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = []\n    if keys is not None:\n        args.extend([function, str(len(keys))] + keys)\n    else:\n        args.extend([function, str(0)])\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TResult,\n        await self._execute_command(RequestType.FCallReadOnly, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geoadd","title":"<code>geoadd(key, members_geospatialdata, existing_options=None, changed=False)</code>  <code>async</code>","text":"<p>Adds geospatial members with their positions to the specified sorted set stored at <code>key</code>. If a member is already a part of the sorted set, its position is updated.</p> <p>See https://valkey.io/commands/geoadd for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members_geospatialdata</code> <code>Mapping[TEncodable, GeospatialData]</code> <p>A mapping of member names to their corresponding positions. See <code>GeospatialData</code>.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling existing members. - NX: Only add new elements. - XX: Only update existing elements.</p> <code>None</code> <code>changed</code> <code>bool</code> <p>Modify the return value to return the number of changed elements, instead of the number of new elements added.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements added to the sorted set.</p> <code>int</code> <p>If <code>changed</code> is set, returns the number of elements updated in the sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n    2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n    1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geoadd(\n    self,\n    key: TEncodable,\n    members_geospatialdata: Mapping[TEncodable, GeospatialData],\n    existing_options: Optional[ConditionalChange] = None,\n    changed: bool = False,\n) -&gt; int:\n    \"\"\"\n    Adds geospatial members with their positions to the specified sorted set stored at `key`.\n    If a member is already a part of the sorted set, its position is updated.\n\n    See https://valkey.io/commands/geoadd for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members_geospatialdata (Mapping[TEncodable, GeospatialData]): A mapping of member names to their corresponding positions. See `GeospatialData`.\n        The command will report an error when the user attempts to index coordinates outside the specified ranges.\n        existing_options (Optional[ConditionalChange]): Options for handling existing members.\n            - NX: Only add new elements.\n            - XX: Only update existing elements.\n        changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n    Returns:\n        int: The number of elements added to the sorted set.\n        If `changed` is set, returns the number of elements updated in the sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n            1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if changed:\n        args.append(\"CH\")\n\n    members_geospatialdata_list = [\n        coord\n        for member, position in members_geospatialdata.items()\n        for coord in [str(position.longitude), str(position.latitude), member]\n    ]\n    args += members_geospatialdata_list\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.GeoAdd, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geodist","title":"<code>geodist(key, member1, member2, unit=None)</code>  <code>async</code>","text":"<p>Returns the distance between two members in the geospatial index stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geodist for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member1</code> <code>TEncodable</code> <p>The name of the first member.</p> required <code>member2</code> <code>TEncodable</code> <p>The name of the second member.</p> required <code>unit</code> <code>Optional[GeoUnit]</code> <p>The unit of distance measurement. See <code>GeoUnit</code>. If not specified, the default unit is <code>METERS</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The distance between <code>member1</code> and <code>member2</code>.</p> <code>Optional[float]</code> <p>If one or both members do not exist, or if the key does not exist, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n    166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n    166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n    None  # Returns None for non-existing member.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geodist(\n    self,\n    key: TEncodable,\n    member1: TEncodable,\n    member2: TEncodable,\n    unit: Optional[GeoUnit] = None,\n) -&gt; Optional[float]:\n    \"\"\"\n    Returns the distance between two members in the geospatial index stored at `key`.\n\n    See https://valkey.io/commands/geodist for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member1 (TEncodable): The name of the first member.\n        member2 (TEncodable): The name of the second member.\n        unit (Optional[GeoUnit]): The unit of distance measurement. See `GeoUnit`.\n            If not specified, the default unit is `METERS`.\n\n    Returns:\n        Optional[float]: The distance between `member1` and `member2`.\n        If one or both members do not exist, or if the key does not exist, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n            166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n            166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n            None  # Returns None for non-existing member.\n    \"\"\"\n    args = [key, member1, member2]\n    if unit:\n        args.append(unit.value)\n\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.GeoDist, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geohash","title":"<code>geohash(key, members)</code>  <code>async</code>","text":"<p>Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geohash for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>The list of members whose GeoHash bytes strings are to be retrieved.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at <code>key</code>.</p> <code>List[Optional[bytes]]</code> <p>If a member does not exist in the sorted set, a None value is returned for that member.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n    [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geohash(\n    self, key: TEncodable, members: List[TEncodable]\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at\n    `key`.\n\n    See https://valkey.io/commands/geohash for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): The list of members whose GeoHash bytes strings are to be retrieved.\n\n    Returns:\n        List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at `key`.\n        If a member does not exist in the sorted set, a None value is returned for that member.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n            [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n    \"\"\"\n    return cast(\n        List[Optional[bytes]],\n        await self._execute_command(RequestType.GeoHash, [key] + members),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geopos","title":"<code>geopos(key, members)</code>  <code>async</code>","text":"<p>Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geopos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>The members for which to get the positions.</p> required <p>Returns:</p> Type Description <code>List[Optional[List[float]]]</code> <p>List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.</p> <code>List[Optional[List[float]]]</code> <p>If a member does not exist, its position will be None.</p> Example <p>await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)}) await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])     [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geopos(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; List[Optional[List[float]]]:\n    \"\"\"\n    Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at\n    `key`.\n\n    See https://valkey.io/commands/geopos for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): The members for which to get the positions.\n\n    Returns:\n        List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.\n        If a member does not exist, its position will be None.\n\n    Example:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])\n            [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]\n    \"\"\"\n    return cast(\n        List[Optional[List[float]]],\n        await self._execute_command(RequestType.GeoPos, [key] + members),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geosearch","title":"<code>geosearch(key, search_from, search_by, order_by=None, count=None, with_coord=False, with_dist=False, with_hash=False)</code>  <code>async</code>","text":"<p>Searches for members in a sorted set stored at <code>key</code> representing geospatial data within a circular or rectangular area.</p> <p>See https://valkey.io/commands/geosearch/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set representing geospatial data.</p> required <code>search_from</code> <code>Union[str, bytes, GeospatialData]</code> <p>The location to search from. Can be specified either as a member from the sorted set or as a geospatial data (see <code>GeospatialData</code>).</p> required <code>search_by</code> <code>Union[GeoSearchByRadius, GeoSearchByBox]</code> <p>The search criteria. For circular area search, see <code>GeoSearchByRadius</code>. For rectangular area search, see <code>GeoSearchByBox</code>.</p> required <code>order_by</code> <code>Optional[OrderBy]</code> <p>Specifies the order in which the results should be returned.     - <code>ASC</code>: Sorts items from the nearest to the farthest, relative to the center point.     - <code>DESC</code>: Sorts items from the farthest to the nearest, relative to the center point. If not specified, the results would be unsorted.</p> <code>None</code> <code>count</code> <code>Optional[GeoSearchCount]</code> <p>Specifies the maximum number of results to return. See <code>GeoSearchCount</code>. If not specified, return all results.</p> <code>None</code> <code>with_coord</code> <code>bool</code> <p>Whether to include coordinates of the returned items. Defaults to False.</p> <code>False</code> <code>with_dist</code> <code>bool</code> <p>Whether to include distance from the center in the returned items. The distance is returned in the same unit as specified for the <code>search_by</code> arguments. Defaults to False.</p> <code>False</code> <code>with_hash</code> <code>bool</code> <p>Whether to include geohash of the returned items. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]</code> <p>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.</p> <code>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]</code> <p>If any of <code>with_coord</code>, <code>with_dist</code> or <code>with_hash</code> are True, returns an array of arrays, we're each sub array represents a single item in the following order: (bytes): The member (location) name. (float): The distance from the center as a floating point number, in the same unit specified in the radius, if <code>with_dist</code> is set to True. (int): The Geohash integer, if <code>with_hash</code> is set to True. List[float]: The coordinates as a two item [longitude,latitude] array, if <code>with_coord</code> is set to True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n    ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n&gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n    [\n        [\n            b\"Catania\",\n            [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n        ],\n        [\n            b\"Palermo\",\n            [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n        ],\n        [\n            b\"edge2\",\n            [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n        ],\n        [\n            b\"edge1\",\n            [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n        ],\n    ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geosearch(\n    self,\n    key: TEncodable,\n    search_from: Union[str, bytes, GeospatialData],\n    search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n    order_by: Optional[OrderBy] = None,\n    count: Optional[GeoSearchCount] = None,\n    with_coord: bool = False,\n    with_dist: bool = False,\n    with_hash: bool = False,\n) -&gt; List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]:\n    \"\"\"\n    Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area.\n\n    See https://valkey.io/commands/geosearch/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set representing geospatial data.\n        search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n            from the sorted set or as a geospatial data (see `GeospatialData`).\n        search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n            For circular area search, see `GeoSearchByRadius`.\n            For rectangular area search, see `GeoSearchByBox`.\n        order_by (Optional[OrderBy]): Specifies the order in which the results should be returned.\n                - `ASC`: Sorts items from the nearest to the farthest, relative to the center point.\n                - `DESC`: Sorts items from the farthest to the nearest, relative to the center point.\n            If not specified, the results would be unsorted.\n        count (Optional[GeoSearchCount]): Specifies the maximum number of results to return. See `GeoSearchCount`.\n            If not specified, return all results.\n        with_coord (bool): Whether to include coordinates of the returned items. Defaults to False.\n        with_dist (bool): Whether to include distance from the center in the returned items.\n            The distance is returned in the same unit as specified for the `search_by` arguments. Defaults to False.\n        with_hash (bool): Whether to include geohash of the returned items. Defaults to False.\n\n    Returns:\n        List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.\n        If any of `with_coord`, `with_dist` or `with_hash` are True, returns an array of arrays, we're each sub array represents a single item in the following order:\n            (bytes): The member (location) name.\n            (float): The distance from the center as a floating point number, in the same unit specified in the radius, if `with_dist` is set to True.\n            (int): The Geohash integer, if `with_hash` is set to True.\n            List[float]: The coordinates as a two item [longitude,latitude] array, if `with_coord` is set to True.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n            ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n        &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n            [\n                [\n                    b\"Catania\",\n                    [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n                ],\n                [\n                    b\"Palermo\",\n                    [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n                ],\n                [\n                    b\"edge2\",\n                    [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n                ],\n                [\n                    b\"edge1\",\n                    [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n                ],\n            ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = _create_geosearch_args(\n        [key],\n        search_from,\n        search_by,\n        order_by,\n        count,\n        with_coord,\n        with_dist,\n        with_hash,\n    )\n\n    return cast(\n        List[Union[bytes, List[Union[bytes, float, int, List[float]]]]],\n        await self._execute_command(RequestType.GeoSearch, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.geosearchstore","title":"<code>geosearchstore(destination, source, search_from, search_by, count=None, store_dist=False)</code>  <code>async</code>","text":"<p>Searches for members in a sorted set stored at <code>key</code> representing geospatial data within a circular or rectangular area and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created.</p> <p>To get the result directly, see <code>geosearch</code>.</p> Note <p>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Args:     destination (TEncodable): The key to store the search results.     source (TEncodable): The key of the sorted set representing geospatial data to search from.     search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member         from the sorted set or as a geospatial data (see <code>GeospatialData</code>).     search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.         For circular area search, see <code>GeoSearchByRadius</code>.         For rectangular area search, see <code>GeoSearchByBox</code>.     count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See <code>GeoSearchCount</code>.         If not specified, stores all results.     store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.         - If set to False, the geohash of the location will be stored as the sorted set score.         - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.             The distance is represented as a floating-point number in the same unit specified for that shape.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n    2 # Number of elements stored in \"my_dest_sorted_set\".\n&gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n    {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n&gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n    2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n    {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geosearchstore(\n    self,\n    destination: TEncodable,\n    source: TEncodable,\n    search_from: Union[str, bytes, GeospatialData],\n    search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n    count: Optional[GeoSearchCount] = None,\n    store_dist: bool = False,\n) -&gt; int:\n    \"\"\"\n    Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n\n    To get the result directly, see `geosearch`.\n\n    Note:\n        When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key to store the search results.\n            source (TEncodable): The key of the sorted set representing geospatial data to search from.\n            search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                from the sorted set or as a geospatial data (see `GeospatialData`).\n            search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                For circular area search, see `GeoSearchByRadius`.\n                For rectangular area search, see `GeoSearchByBox`.\n            count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See `GeoSearchCount`.\n                If not specified, stores all results.\n            store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.\n                - If set to False, the geohash of the location will be stored as the sorted set score.\n                - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.\n                    The distance is represented as a floating-point number in the same unit specified for that shape.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n            2 # Number of elements stored in \"my_dest_sorted_set\".\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n            {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n        &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n            2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n            {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = _create_geosearch_args(\n        [destination, source],\n        search_from,\n        search_by,\n        None,\n        count,\n        False,\n        False,\n        False,\n        store_dist,\n    )\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.GeoSearchStore, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.get","title":"<code>get(key)</code>  <code>async</code>","text":"<p>Get the value associated with the given key, or null if no such value exists. See https://valkey.io/commands/get/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.</p> Example <p>await client.get(\"key\")     b'value'</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def get(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Get the value associated with the given key, or null if no such value exists.\n    See https://valkey.io/commands/get/ for details.\n\n    Args:\n        key (TEncodable): The key to retrieve from the database.\n\n    Returns:\n        Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.\n\n    Example:\n        &gt;&gt;&gt; await client.get(\"key\")\n            b'value'\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(Optional[bytes], await self._execute_command(RequestType.Get, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.get_pubsub_message","title":"<code>get_pubsub_message()</code>  <code>async</code>","text":"<p>Returns the next pubsub message. Throws WrongConfiguration in cases: 1. No pubsub subscriptions are configured for the client 2. Callback is configured with the pubsub subsciptions</p> <p>See https://valkey.io/docs/topics/pubsub/ for more details.</p> <p>Returns:</p> Name Type Description <code>PubSubMsg</code> <code>PubSubMsg</code> <p>The next pubsub message</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def get_pubsub_message(self) -&gt; PubSubMsg:\n    \"\"\"\n    Returns the next pubsub message.\n    Throws WrongConfiguration in cases:\n    1. No pubsub subscriptions are configured for the client\n    2. Callback is configured with the pubsub subsciptions\n\n    See https://valkey.io/docs/topics/pubsub/ for more details.\n\n    Returns:\n        PubSubMsg: The next pubsub message\n\n    Examples:\n        &gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.getbit","title":"<code>getbit(key, offset)</code>  <code>async</code>","text":"<p>Returns the bit value at <code>offset</code> in the string value stored at <code>key</code>. <code>offset</code> should be greater than or equal to zero.</p> <p>See https://valkey.io/commands/getbit for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>offset</code> <code>int</code> <p>The index of the bit to return.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The bit at the given <code>offset</code> of the string. Returns <code>0</code> if the key is empty or if the <code>offset</code> exceeds the length of the string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n    1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getbit(self, key: TEncodable, offset: int) -&gt; int:\n    \"\"\"\n    Returns the bit value at `offset` in the string value stored at `key`.\n    `offset` should be greater than or equal to zero.\n\n    See https://valkey.io/commands/getbit for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        offset (int): The index of the bit to return.\n\n    Returns:\n        int: The bit at the given `offset` of the string. Returns `0` if the key is empty or if the `offset` exceeds\n            the length of the string.\n\n    Examples:\n        &gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n            1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.GetBit, [key, str(offset)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.getdel","title":"<code>getdel(key)</code>  <code>async</code>","text":"<p>Gets a value associated with the given string <code>key</code> and deletes the key.</p> <p>See https://valkey.io/commands/getdel for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, returns the <code>value</code> of <code>key</code>. Otherwise, returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.getdel(\"key\")\n    b'value'\n&gt;&gt;&gt; await client.getdel(\"key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getdel(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Gets a value associated with the given string `key` and deletes the key.\n\n    See https://valkey.io/commands/getdel for more details.\n\n    Args:\n        key (TEncodable): The `key` to retrieve from the database.\n\n    Returns:\n        Optional[bytes]: If `key` exists, returns the `value` of `key`. Otherwise, returns `None`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.getdel(\"key\")\n            b'value'\n        &gt;&gt;&gt; await client.getdel(\"key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.GetDel, [key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.getex","title":"<code>getex(key, expiry=None)</code>  <code>async</code>","text":"<p>Get the value of <code>key</code> and optionally set its expiration. <code>GETEX</code> is similar to <code>GET</code>. See https://valkey.io/commands/getex for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to get.</p> required <code>expiry</code> <code>Optional[ExpiryGetEx]</code> <p>set expiriation to the given key. Equivalent to [<code>EX</code> | <code>PX</code> | <code>EXAT</code> | <code>PXAT</code> | <code>PERSIST</code>] in the Valkey API.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, return the value stored at <code>key</code> If <code>key</code> does not exist, return <code>None</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n    'OK'\n&gt;&gt;&gt; await client.getex(\"key\")\n    b'value'\n&gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n    b'value'\n&gt;&gt;&gt; time.sleep(1)\n&gt;&gt;&gt; await client.getex(b\"key\")\n    None\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getex(\n    self,\n    key: TEncodable,\n    expiry: Optional[ExpiryGetEx] = None,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Get the value of `key` and optionally set its expiration. `GETEX` is similar to `GET`.\n    See https://valkey.io/commands/getex for more details.\n\n    Args:\n        key (TEncodable): The key to get.\n        expiry (Optional[ExpiryGetEx], optional): set expiriation to the given key.\n            Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `PERSIST`] in the Valkey API.\n\n    Returns:\n        Optional[bytes]:\n            If `key` exists, return the value stored at `key`\n            If `key` does not exist, return `None`\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            'OK'\n        &gt;&gt;&gt; await client.getex(\"key\")\n            b'value'\n        &gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n            b'value'\n        &gt;&gt;&gt; time.sleep(1)\n        &gt;&gt;&gt; await client.getex(b\"key\")\n            None\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = [key]\n    if expiry is not None:\n        args.extend(expiry.get_cmd_args())\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.GetEx, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.getrange","title":"<code>getrange(key, start, end)</code>  <code>async</code>","text":"<p>Returns the substring of the value stored at <code>key</code>, determined by the offsets <code>start</code> and <code>end</code> (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the value. So <code>-1</code> means the last character, <code>-2</code> the penultimate and so forth.</p> <p>If <code>key</code> does not exist, an empty byte string is returned. If <code>start</code> or <code>end</code> are out of range, returns the substring within the valid range of the value.</p> <p>See https://valkey.io/commands/getrange/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>start</code> <code>int</code> <p>The starting offset.</p> required <code>end</code> <code>int</code> <p>The ending offset.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>A substring extracted from the value stored at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n&gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n    b\"This\"\n&gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n    b\"ing\"  # extracted last 3 characters of a string\n&gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n    b\"This is a string\"\n&gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n    b\"\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getrange(self, key: TEncodable, start: int, end: int) -&gt; bytes:\n    \"\"\"\n    Returns the substring of the value stored at `key`, determined by the offsets `start` and `end` (both are inclusive).\n    Negative offsets can be used in order to provide an offset starting from the end of the value.\n    So `-1` means the last character, `-2` the penultimate and so forth.\n\n    If `key` does not exist, an empty byte string is returned. If `start` or `end`\n    are out of range, returns the substring within the valid range of the value.\n\n    See https://valkey.io/commands/getrange/ for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        start (int): The starting offset.\n        end (int): The ending offset.\n\n    Returns:\n        bytes: A substring extracted from the value stored at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n        &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n            b\"This\"\n        &gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n            b\"ing\"  # extracted last 3 characters of a string\n        &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n            b\"This is a string\"\n        &gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n            b\"\"\n    \"\"\"\n    return cast(\n        bytes,\n        await self._execute_command(\n            RequestType.GetRange, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hdel","title":"<code>hdel(key, fields)</code>  <code>async</code>","text":"<p>Remove specified fields from the hash stored at <code>key</code>. See https://valkey.io/commands/hdel/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>fields</code> <code>List[TEncodable]</code> <p>The list of fields to remove from the hash stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields that were removed from the hash, excluding specified but non-existing fields.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty hash, and the function returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n    2  # Indicates that two fields were successfully removed from the hash.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hdel(self, key: TEncodable, fields: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Remove specified fields from the hash stored at `key`.\n    See https://valkey.io/commands/hdel/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        fields (List[TEncodable]): The list of fields to remove from the hash stored at `key`.\n\n    Returns:\n        int: The number of fields that were removed from the hash, excluding specified but non-existing fields.\n        If `key` does not exist, it is treated as an empty hash, and the function returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n            2  # Indicates that two fields were successfully removed from the hash.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.HDel, [key] + fields))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hexists","title":"<code>hexists(key, field)</code>  <code>async</code>","text":"<p>Check if a field exists in the hash stored at <code>key</code>. See https://valkey.io/commands/hexists/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field to check in the hash stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns 'True' if the hash contains the specified field. If the hash does not contain the field, or if the key does not exist, it returns 'False'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n    True\n&gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n    False\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hexists(self, key: TEncodable, field: TEncodable) -&gt; bool:\n    \"\"\"\n    Check if a field exists in the hash stored at `key`.\n    See https://valkey.io/commands/hexists/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field to check in the hash stored at `key`.\n\n    Returns:\n        bool: Returns 'True' if the hash contains the specified field. If the hash does not contain the field,\n            or if the key does not exist, it returns 'False'.\n\n    Examples:\n        &gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n            True\n        &gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n            False\n    \"\"\"\n    return cast(\n        bool, await self._execute_command(RequestType.HExists, [key, field])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hget","title":"<code>hget(key, field)</code>  <code>async</code>","text":"<p>Retrieves the value associated with <code>field</code> in the hash stored at <code>key</code>. See https://valkey.io/commands/hget/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field whose value should be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value associated <code>field</code> in the hash.</p> <code>Optional[bytes]</code> <p>Returns None if <code>field</code> is not presented in the hash or <code>key</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n&gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n    b\"value\"\n&gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hget(self, key: TEncodable, field: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Retrieves the value associated with `field` in the hash stored at `key`.\n    See https://valkey.io/commands/hget/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field whose value should be retrieved.\n\n    Returns:\n        Optional[bytes]: The value associated `field` in the hash.\n        Returns None if `field` is not presented in the hash or `key` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n        &gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n            b\"value\"\n        &gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.HGet, [key, field]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hgetall","title":"<code>hgetall(key)</code>  <code>async</code>","text":"<p>Returns all fields and values of the hash stored at <code>key</code>. See https://valkey.io/commands/hgetall/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Dict[bytes, bytes]</code> <p>Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by</p> <code>Dict[bytes, bytes]</code> <p>its value.</p> <code>Dict[bytes, bytes]</code> <p>If <code>key</code> does not exist, it returns an empty dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hgetall(\"my_hash\")\n    {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hgetall(self, key: TEncodable) -&gt; Dict[bytes, bytes]:\n    \"\"\"\n    Returns all fields and values of the hash stored at `key`.\n    See https://valkey.io/commands/hgetall/ for details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by\n        its value.\n        If `key` does not exist, it returns an empty dictionary.\n\n    Examples:\n        &gt;&gt;&gt; await client.hgetall(\"my_hash\")\n            {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n    \"\"\"\n    return cast(\n        Dict[bytes, bytes], await self._execute_command(RequestType.HGetAll, [key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hincrby","title":"<code>hincrby(key, field, amount)</code>  <code>async</code>","text":"<p>Increment or decrement the value of a <code>field</code> in the hash stored at <code>key</code> by the specified amount. By using a negative increment value, the value stored at <code>field</code> in the hash stored at <code>key</code> is decremented. If <code>field</code> or <code>key</code> does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/hincrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash stored at <code>key</code> to increment or decrement its value.</p> required <code>amount</code> <code>int</code> <p>The amount by which to increment or decrement the field's value. Use a negative value to decrement.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of the specified field in the hash stored at <code>key</code> after the increment or decrement.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n    5\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hincrby(self, key: TEncodable, field: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Increment or decrement the value of a `field` in the hash stored at `key` by the specified amount.\n    By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n    If `field` or `key` does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/hincrby/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n        amount (int): The amount by which to increment or decrement the field's value.\n            Use a negative value to decrement.\n\n    Returns:\n        int: The value of the specified field in the hash stored at `key` after the increment or decrement.\n\n    Examples:\n        &gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n            5\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.HIncrBy, [key, field, str(amount)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hincrbyfloat","title":"<code>hincrbyfloat(key, field, amount)</code>  <code>async</code>","text":"<p>Increment or decrement the floating-point value stored at <code>field</code> in the hash stored at <code>key</code> by the specified amount. By using a negative increment value, the value stored at <code>field</code> in the hash stored at <code>key</code> is decremented. If <code>field</code> or <code>key</code> does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/hincrbyfloat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash stored at <code>key</code> to increment or decrement its value.</p> required <code>amount</code> <code>float</code> <p>The amount by which to increment or decrement the field's value. Use a negative value to decrement.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the specified field in the hash stored at <code>key</code> after the increment as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n    \"2.5\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hincrbyfloat(\n    self, key: TEncodable, field: TEncodable, amount: float\n) -&gt; float:\n    \"\"\"\n    Increment or decrement the floating-point value stored at `field` in the hash stored at `key` by the specified\n    amount.\n    By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n    If `field` or `key` does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/hincrbyfloat/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n        amount (float): The amount by which to increment or decrement the field's value.\n            Use a negative value to decrement.\n\n    Returns:\n        float: The value of the specified field in the hash stored at `key` after the increment as a string.\n\n    Examples:\n        &gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n            \"2.5\"\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(\n            RequestType.HIncrByFloat, [key, field, str(amount)]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hkeys","title":"<code>hkeys(key)</code>  <code>async</code>","text":"<p>Returns all field names in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hkeys/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hkeys(\"my_hash\")\n    [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hkeys(self, key: TEncodable) -&gt; List[bytes]:\n    \"\"\"\n    Returns all field names in the hash stored at `key`.\n\n    See https://valkey.io/commands/hkeys/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hkeys(\"my_hash\")\n            [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(List[bytes], await self._execute_command(RequestType.HKeys, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hlen","title":"<code>hlen(key)</code>  <code>async</code>","text":"<p>Returns the number of fields contained in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields in the hash, or 0 when the key does not exist.</p> <code>int</code> <p>If <code>key</code> holds a value that is not a hash, an error is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hlen(\"my_hash\")\n    3\n&gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n    0\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the number of fields contained in the hash stored at `key`.\n\n    See https://valkey.io/commands/hlen/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        int: The number of fields in the hash, or 0 when the key does not exist.\n        If `key` holds a value that is not a hash, an error is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.hlen(\"my_hash\")\n            3\n        &gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n            0\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.HLen, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hmget","title":"<code>hmget(key, fields)</code>  <code>async</code>","text":"<p>Retrieve the values associated with specified fields in the hash stored at <code>key</code>. See https://valkey.io/commands/hmget/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>fields</code> <code>List[TEncodable]</code> <p>The list of fields in the hash stored at <code>key</code> to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.</p> <code>List[Optional[bytes]]</code> <p>For every field that does not exist in the hash, a null value is returned.</p> <code>List[Optional[bytes]]</code> <p>If <code>key</code> does not exist, it is treated as an empty hash, and the function returns a list of null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n    [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hmget(\n    self, key: TEncodable, fields: List[TEncodable]\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Retrieve the values associated with specified fields in the hash stored at `key`.\n    See https://valkey.io/commands/hmget/ for details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        fields (List[TEncodable]): The list of fields in the hash stored at `key` to retrieve from the database.\n\n    Returns:\n        List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.\n        For every field that does not exist in the hash, a null value is returned.\n        If `key` does not exist, it is treated as an empty hash, and the function returns a list of null values.\n\n    Examples:\n        &gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n            [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n    \"\"\"\n    return cast(\n        List[Optional[bytes]],\n        await self._execute_command(RequestType.HMGet, [key] + fields),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hrandfield","title":"<code>hrandfield(key)</code>  <code>async</code>","text":"<p>Returns a random field name from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random field name from the hash stored at <code>key</code>.</p> <code>Optional[bytes]</code> <p>If the hash does not exist or is empty, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n    b\"field1\"  # A random field name stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random field name from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        Optional[bytes]: A random field name from the hash stored at `key`.\n        If the hash does not exist or is empty, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n            b\"field1\"  # A random field name stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.HRandField, [key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hrandfield_count","title":"<code>hrandfield_count(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to <code>count</code> random field names from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>count</code> <code>int</code> <p>The number of field names to return. If <code>count</code> is positive, returns unique elements. If <code>count</code> is negative, allows for duplicates elements.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of random field names from the hash.</p> <code>List[bytes]</code> <p>If the hash does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n    [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n&gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n    []  # Empty list\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieves up to `count` random field names from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        count (int): The number of field names to return.\n            If `count` is positive, returns unique elements.\n            If `count` is negative, allows for duplicates elements.\n\n    Returns:\n        List[bytes]: A list of random field names from the hash.\n        If the hash does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n            [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n        &gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n            []  # Empty list\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.HRandField, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hrandfield_withvalues","title":"<code>hrandfield_withvalues(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to <code>count</code> random field names along with their values from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>count</code> <code>int</code> <p>The number of field names to return. If <code>count</code> is positive, returns unique elements. If <code>count</code> is negative, allows for duplicates elements.</p> required <p>Returns:</p> Type Description <code>List[List[bytes]]</code> <p>List[List[bytes]]: A list of <code>[field_name, value]</code> lists, where <code>field_name</code> is a random field name from the</p> <code>List[List[bytes]]</code> <p>hash and <code>value</code> is the associated value of the field name.</p> <code>List[List[bytes]]</code> <p>If the hash does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n    [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield_withvalues(\n    self, key: TEncodable, count: int\n) -&gt; List[List[bytes]]:\n    \"\"\"\n    Retrieves up to `count` random field names along with their values from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        count (int): The number of field names to return.\n            If `count` is positive, returns unique elements.\n            If `count` is negative, allows for duplicates elements.\n\n    Returns:\n        List[List[bytes]]: A list of `[field_name, value]` lists, where `field_name` is a random field name from the\n        hash and `value` is the associated value of the field name.\n        If the hash does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n            [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n    \"\"\"\n    return cast(\n        List[List[bytes]],\n        await self._execute_command(\n            RequestType.HRandField, [key, str(count), \"WITHVALUES\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hscan","title":"<code>hscan(key, cursor, match=None, count=None, no_values=False)</code>  <code>async</code>","text":"<p>Iterates incrementally over a hash.</p> <p>See https://valkey.io/commands/hscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a subset of the hash then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the hash. <code>COUNT</code> could be ignored until the hash is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <code>no_values</code> <code>bool</code> <p>If <code>True</code>, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the hash held by <code>key</code>. The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code> returned on the last iteration of the hash. The second element is always an <code>Array</code> of the subset of the hash held in <code>key</code>. The <code>Array</code> in the second element is a flattened series of <code>String</code> pairs, where the value is at even indices and the score is at odd indices. If <code>no_values</code> is set to <code>True</code>, the second element will only contain the fields without the values.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.hscan--assume-key-contains-a-hash-with-multiple-members","title":"Assume \"key\" contains a hash with multiple members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 1\nMembers: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\nCursor: 39\nMembers: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\nCursor: 0\nMembers: [b'field 420', b'value 420', b'field 221', b'value 221']\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hscan--use-no-values","title":"Use no-values","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 1\nMembers: [b'field 79',b'field 20', b'field 115']\nCursor: 39\nMembers: [b'field 63', b'field 293', b'field 162']\nCursor: 0\nMembers: [b'field 420', b'field 221']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    no_values: bool = False,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a hash.\n\n    See https://valkey.io/commands/hscan for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a\n            subset of the hash then there could be a case where the result is empty although there are items that\n            match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n            only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the hash.\n            `COUNT` could be ignored until the hash is large enough for the `SCAN` commands to represent the results\n            as compact single-allocation packed encoding.\n        no_values (bool): If `True`, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the hash held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the hash. The second element is always an `Array` of the subset of the\n            hash held in `key`. The `Array` in the second element is a flattened series of `String` pairs,\n            where the value is at even indices and the score is at odd indices.\n            If `no_values` is set to `True`, the second element will only contain the fields without the values.\n\n    Examples:\n        # Assume \"key\" contains a hash with multiple members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 1\n        Members: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\n        Cursor: 39\n        Members: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\n        Cursor: 0\n        Members: [b'field 420', b'value 420', b'field 221', b'value 221']\n\n        # Use no-values\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 1\n        Members: [b'field 79',b'field 20', b'field 115']\n        Cursor: 39\n        Members: [b'field 63', b'field 293', b'field 162']\n        Cursor: 0\n        Members: [b'field 420', b'field 221']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n    if no_values:\n        args.append(\"NOVALUES\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.HScan, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hset","title":"<code>hset(key, field_value_map)</code>  <code>async</code>","text":"<p>Sets the specified fields to their respective values in the hash stored at <code>key</code>. See https://valkey.io/commands/hset/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A field-value map consisting of fields and their corresponding values</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields that were added to the hash.</p> Example <p>await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})     2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hset(\n    self,\n    key: TEncodable,\n    field_value_map: Mapping[TEncodable, TEncodable],\n) -&gt; int:\n    \"\"\"\n    Sets the specified fields to their respective values in the hash stored at `key`.\n    See https://valkey.io/commands/hset/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field_value_map (Mapping[TEncodable, TEncodable]): A field-value map consisting of fields and their corresponding values\n        to be set in the hash stored at the specified key.\n\n    Returns:\n        int: The number of fields that were added to the hash.\n\n    Example:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})\n            2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".\n    \"\"\"\n    field_value_list: List[TEncodable] = [key]\n    for pair in field_value_map.items():\n        field_value_list.extend(pair)\n    return cast(\n        int,\n        await self._execute_command(RequestType.HSet, field_value_list),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hsetnx","title":"<code>hsetnx(key, field, value)</code>  <code>async</code>","text":"<p>Sets <code>field</code> in the hash stored at <code>key</code> to <code>value</code>, only if <code>field</code> does not yet exist. If <code>key</code> does not exist, a new key holding a hash is created. If <code>field</code> already exists, this operation has no effect. See https://valkey.io/commands/hsetnx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field to set the value for.</p> required <code>value</code> <code>TEncodable</code> <p>The value to set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the field was set, False if the field already existed and was not set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n    True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n&gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n    False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hsetnx(\n    self,\n    key: TEncodable,\n    field: TEncodable,\n    value: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Sets `field` in the hash stored at `key` to `value`, only if `field` does not yet exist.\n    If `key` does not exist, a new key holding a hash is created.\n    If `field` already exists, this operation has no effect.\n    See https://valkey.io/commands/hsetnx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field to set the value for.\n        value (TEncodable): The value to set.\n\n    Returns:\n        bool: True if the field was set, False if the field already existed and was not set.\n\n    Examples:\n        &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n            True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n        &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n            False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.HSetNX, [key, field, value]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hstrlen","title":"<code>hstrlen(key, field)</code>  <code>async</code>","text":"<p>Returns the string length of the value associated with <code>field</code> in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hstrlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The string length or 0 if <code>field</code> or <code>key</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n&gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n    5\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hstrlen(self, key: TEncodable, field: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the string length of the value associated with `field` in the hash stored at `key`.\n\n    See https://valkey.io/commands/hstrlen/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash.\n\n    Returns:\n        int: The string length or 0 if `field` or `key` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n        &gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n            5\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.HStrlen, [key, field]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.hvals","title":"<code>hvals(key)</code>  <code>async</code>","text":"<p>Returns all values in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hvals/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of values in the hash, or an empty list when the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hvals(\"my_hash\")\n    [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hvals(self, key: TEncodable) -&gt; List[bytes]:\n    \"\"\"\n    Returns all values in the hash stored at `key`.\n\n    See https://valkey.io/commands/hvals/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        List[bytes]: A list of values in the hash, or an empty list when the key does not exist.\n\n    Examples:\n       &gt;&gt;&gt; await client.hvals(\"my_hash\")\n           [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(List[bytes], await self._execute_command(RequestType.HVals, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.incr","title":"<code>incr(key)</code>  <code>async</code>","text":"<p>Increments the number stored at <code>key</code> by one. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incr/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of <code>key</code> after the increment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.incr(\"key\")\n    11\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incr(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Increments the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n    operation.\n    See https://valkey.io/commands/incr/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n\n    Returns:\n        int: The value of `key` after the increment.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incr(\"key\")\n            11\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Incr, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.incrby","title":"<code>incrby(key, amount)</code>  <code>async</code>","text":"<p>Increments the number stored at <code>key</code> by <code>amount</code>. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <code>amount</code> <code>int) </code> <p>The amount to increment.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the increment.</p> Example <p>await client.set(\"key\", \"10\") await client.incrby(\"key\" , 5)     15</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incrby(self, key: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Increments the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n    the operation. See https://valkey.io/commands/incrby/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n      amount (int) : The amount to increment.\n\n    Returns:\n        int: The value of key after the increment.\n\n    Example:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incrby(\"key\" , 5)\n            15\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.IncrBy, [key, str(amount)])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.incrbyfloat","title":"<code>incrbyfloat(key, amount)</code>  <code>async</code>","text":"<p>Increment the string representing a floating point number stored at <code>key</code> by <code>amount</code>. By using a negative increment value, the value stored at the <code>key</code> is decremented. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incrbyfloat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <code>amount</code> <code>float) </code> <p>The amount to increment.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of key after the increment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n    15.55\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incrbyfloat(self, key: TEncodable, amount: float) -&gt; float:\n    \"\"\"\n    Increment the string representing a floating point number stored at `key` by `amount`.\n    By using a negative increment value, the value stored at the `key` is decremented.\n    If the key does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/incrbyfloat/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n      amount (float) : The amount to increment.\n\n    Returns:\n        float: The value of key after the increment.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n            15.55\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(RequestType.IncrByFloat, [key, str(amount)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lcs","title":"<code>lcs(key1, key2)</code>  <code>async</code>","text":"<p>Returns the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A Bytes String containing the longest common subsequence between the 2 strings.</p> <code>bytes</code> <p>An empty String is returned if the keys do not exist or have no common subsequences.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n    b'OK'\n&gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n    b'acd'\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n) -&gt; bytes:\n    \"\"\"\n    Returns the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string.\n        key2 (TEncodable): The key that stores the second string.\n\n    Returns:\n        A Bytes String containing the longest common subsequence between the 2 strings.\n        An empty String is returned if the keys do not exist or have no common subsequences.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n            b'OK'\n        &gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n            b'acd'\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2]\n\n    return cast(\n        bytes,\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lcs_idx","title":"<code>lcs_idx(key1, key2, min_match_len=None, with_match_len=False)</code>  <code>async</code>","text":"<p>Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string value.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string value.</p> required <code>min_match_len</code> <code>Optional[int]</code> <p>The minimum length of matches to include in the result.</p> <code>None</code> <code>with_match_len</code> <code>Optional[bool]</code> <p>If True, include the length of the substring matched for each substring.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>A Mapping containing the indices of the longest common subsequence between the</p> <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>2 strings and the length of the longest common subsequence. The resulting map contains two</p> <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>keys, \"matches\" and \"len\": - \"len\" is mapped to the length of the longest common subsequence between the 2 strings. - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that   represent the location of the common subsequences in the strings held by key1 and key2,   with the length of the match after each matches, if with_match_len is enabled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n    'OK'\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n    {\n        b'matches': [\n            [\n                [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n            ],\n            [\n                [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n            ],\n        ],\n        b'len': 7  # length of the entire longest common subsequence\n    }\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n    {\n        b'matches': [\n            [\n                [4, 7],\n                [5, 8],\n            ],\n            # the other match with a length of 3 is excluded\n        ],\n        b'len': 7\n    }\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n    {\n        b'matches': [\n            [\n                [4, 7],\n                [5, 8],\n                4,  # length of this match (b\"1234\")\n            ],\n            [\n                [1, 3],\n                [0, 2],\n                3,  # length of this match (b\"bcd\")\n            ],\n        ],\n        b'len': 7\n    }\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs_idx(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n    min_match_len: Optional[int] = None,\n    with_match_len: Optional[bool] = False,\n) -&gt; Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]:\n    \"\"\"\n    Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string value.\n        key2 (TEncodable): The key that stores the second string value.\n        min_match_len (Optional[int]): The minimum length of matches to include in the result.\n        with_match_len (Optional[bool]): If True, include the length of the substring matched for each substring.\n\n    Returns:\n        A Mapping containing the indices of the longest common subsequence between the\n        2 strings and the length of the longest common subsequence. The resulting map contains two\n        keys, \"matches\" and \"len\":\n            - \"len\" is mapped to the length of the longest common subsequence between the 2 strings.\n            - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that\n              represent the location of the common subsequences in the strings held by key1 and key2,\n              with the length of the match after each matches, if with_match_len is enabled.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n            'OK'\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n            {\n                b'matches': [\n                    [\n                        [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                        [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n                    ],\n                    [\n                        [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                        [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n                    ],\n                ],\n                b'len': 7  # length of the entire longest common subsequence\n            }\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n            {\n                b'matches': [\n                    [\n                        [4, 7],\n                        [5, 8],\n                    ],\n                    # the other match with a length of 3 is excluded\n                ],\n                b'len': 7\n            }\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n            {\n                b'matches': [\n                    [\n                        [4, 7],\n                        [5, 8],\n                        4,  # length of this match (b\"1234\")\n                    ],\n                    [\n                        [1, 3],\n                        [0, 2],\n                        3,  # length of this match (b\"bcd\")\n                    ],\n                ],\n                b'len': 7\n            }\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2, \"IDX\"]\n\n    if min_match_len is not None:\n        args.extend([\"MINMATCHLEN\", str(min_match_len)])\n\n    if with_match_len:\n        args.append(\"WITHMATCHLEN\")\n\n    return cast(\n        Mapping[bytes, Union[List[List[Union[List[int], int]]], int]],\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lcs_len","title":"<code>lcs_len(key1, key2)</code>  <code>async</code>","text":"<p>Returns the length of the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string value.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The length of the longest common subsequence between the 2 strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n    'OK'\n&gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n    3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs_len(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Returns the length of the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string value.\n        key2 (TEncodable): The key that stores the second string value.\n\n    Returns:\n        The length of the longest common subsequence between the 2 strings.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n            'OK'\n        &gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n            3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2, \"LEN\"]\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lindex","title":"<code>lindex(key, index)</code>  <code>async</code>","text":"<p>Returns the element at <code>index</code> in the list stored at <code>key</code>.</p> <p>The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.</p> <p>See https://valkey.io/commands/lindex/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index of the element in the list to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The element at <code>index</code> in the list stored at <code>key</code>. If <code>index</code> is out of range or if <code>key</code> does not exist, None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n    b'value1'  # Returns the first element in the list stored at 'my_list'.\n&gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n    b'value3'  # Returns the last element in the list stored at 'my_list'.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lindex(\n    self,\n    key: TEncodable,\n    index: int,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns the element at `index` in the list stored at `key`.\n\n    The index is zero-based, so 0 means the first element, 1 the second element and so on.\n    Negative indices can be used to designate elements starting at the tail of the list.\n    Here, -1 means the last element, -2 means the penultimate and so forth.\n\n    See https://valkey.io/commands/lindex/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        index (int): The index of the element in the list to retrieve.\n\n    Returns:\n        Optional[bytes]: The element at `index` in the list stored at `key`.\n            If `index` is out of range or if `key` does not exist, None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n            b'value1'  # Returns the first element in the list stored at 'my_list'.\n        &gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n            b'value3'  # Returns the last element in the list stored at 'my_list'.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.LIndex, [key, str(index)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.linsert","title":"<code>linsert(key, position, pivot, element)</code>  <code>async</code>","text":"<p>Inserts <code>element</code> in the list at <code>key</code> either before or after the <code>pivot</code>.</p> <p>See https://valkey.io/commands/linsert/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>position</code> <code>InsertPosition</code> <p>The relative position to insert into - either <code>InsertPosition.BEFORE</code> or <code>InsertPosition.AFTER</code> the <code>pivot</code>.</p> required <code>pivot</code> <code>TEncodable</code> <p>An element of the list.</p> required <code>element</code> <code>TEncodable</code> <p>The new element to insert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The list length after a successful insert operation. If the <code>key</code> doesn't exist returns <code>-1</code>. If the <code>pivot</code> wasn't found, returns <code>0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n    3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def linsert(\n    self,\n    key: TEncodable,\n    position: InsertPosition,\n    pivot: TEncodable,\n    element: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Inserts `element` in the list at `key` either before or after the `pivot`.\n\n    See https://valkey.io/commands/linsert/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        position (InsertPosition): The relative position to insert into - either `InsertPosition.BEFORE` or\n            `InsertPosition.AFTER` the `pivot`.\n        pivot (TEncodable): An element of the list.\n        element (TEncodable): The new element to insert.\n\n    Returns:\n        int: The list length after a successful insert operation.\n            If the `key` doesn't exist returns `-1`.\n            If the `pivot` wasn't found, returns `0`.\n\n    Examples:\n        &gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n            3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.LInsert, [key, position.value, pivot, element]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.llen","title":"<code>llen(key)</code>  <code>async</code>","text":"<p>Get the length of the list stored at <code>key</code>. See https://valkey.io/commands/llen/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list at the specified key. If <code>key</code> does not exist, it is interpreted as an empty list and 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.llen(\"my_list\")\n    3  # Indicates that there are 3 elements in the list.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def llen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Get the length of the list stored at `key`.\n    See https://valkey.io/commands/llen/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        int: The length of the list at the specified key.\n            If `key` does not exist, it is interpreted as an empty list and 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.llen(\"my_list\")\n            3  # Indicates that there are 3 elements in the list.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.LLen, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lmove","title":"<code>lmove(source, destination, where_from, where_to)</code>  <code>async</code>","text":"<p>Atomically pops and removes the left/right-most element to the list stored at <code>source</code> depending on <code>where_from</code>, and pushes the element at the first/last element of the list stored at <code>destination</code> depending on <code>where_to</code>.</p> <p>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/lmove/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source list.</p> required <code>destination</code> <code>TEncodable</code> <p>The key to the destination list.</p> required <code>where_from</code> <code>ListDirection</code> <p>The direction to remove the element from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>where_to</code> <code>ListDirection</code> <p>The direction to add the element to (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The popped element, or None if <code>source</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n&gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n&gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n    b\"one\"\n&gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n    [b\"two\"]\n&gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n    [b\"one\", b\"three\", b\"four\"]\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lmove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    where_from: ListDirection,\n    where_to: ListDirection,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Atomically pops and removes the left/right-most element to the list stored at `source`\n    depending on `where_from`, and pushes the element at the first/last element of the list\n    stored at `destination` depending on `where_to`.\n\n    When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n    See https://valkey.io/commands/lmove/ for details.\n\n    Args:\n        source (TEncodable): The key to the source list.\n        destination (TEncodable): The key to the destination list.\n        where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n\n    Returns:\n        Optional[bytes]: The popped element, or None if `source` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n        &gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n        &gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n            b\"one\"\n        &gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n            [b\"two\"]\n        &gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n            [b\"one\", b\"three\", b\"four\"]\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(\n            RequestType.LMove,\n            [source, destination, where_from.value, where_to.value],\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lmpop","title":"<code>lmpop(keys, direction, count=None)</code>  <code>async</code>","text":"<p>Pops one or more elements from the first non-empty list from the provided <code>keys</code>.</p> <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/lmpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>An array of keys of lists.</p> required <code>direction</code> <code>ListDirection</code> <p>The direction based on which elements are popped from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>count</code> <code>Optional[int]</code> <p>The maximum number of popped elements. If not provided, defaults to popping a single element.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[bytes]]]</code> <p>Optional[Mapping[bytes, List[bytes]]]: A map of <code>key</code> name mapped to an array of popped elements, or None if no elements could be popped.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n&gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n   {b\"testKey\": [b\"three\", b\"two\"]}\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lmpop(\n    self,\n    keys: List[TEncodable],\n    direction: ListDirection,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n    \"\"\"\n    Pops one or more elements from the first non-empty list from the provided `keys`.\n\n    When in cluster mode, all `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/lmpop/ for details.\n\n    Args:\n        keys (List[TEncodable]): An array of keys of lists.\n        direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n    Returns:\n        Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n        &gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n           {b\"testKey\": [b\"three\", b\"two\"]}\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(len(keys)), *keys, direction.value]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[Mapping[bytes, List[bytes]]],\n        await self._execute_command(RequestType.LMPop, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lpop","title":"<code>lpop(key)</code>  <code>async</code>","text":"<p>Remove and return the first elements of the list stored at <code>key</code>. The command pops a single element from the beginning of the list. See https://valkey.io/commands/lpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the first element.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpop(\"my_list\")\n    b\"value1\"\n&gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Remove and return the first elements of the list stored at `key`.\n    The command pops a single element from the beginning of the list.\n    See https://valkey.io/commands/lpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        Optional[bytes]: The value of the first element.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpop(\"my_list\")\n            b\"value1\"\n        &gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.LPop, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lpop_count","title":"<code>lpop_count(key, count)</code>  <code>async</code>","text":"<p>Remove and return up to <code>count</code> elements from the list stored at <code>key</code>, depending on the list's length. See https://valkey.io/commands/lpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of elements to pop from the list.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.</p> <code>Optional[List[bytes]]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n    [b\"value1\", b\"value2\"]\n&gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Remove and return up to `count` elements from the list stored at `key`, depending on the list's length.\n    See https://valkey.io/commands/lpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of elements to pop from the list.\n\n    Returns:\n        Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n            [b\"value1\", b\"value2\"]\n        &gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n            None\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.LPop, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lpos","title":"<code>lpos(key, element, rank=None, count=None, max_len=None)</code>  <code>async</code>","text":"<p>Returns the index or indexes of element(s) matching <code>element</code> in the <code>key</code> list. If no match is found, None is returned.</p> <p>See https://valkey.io/commands/lpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The name of the list.</p> required <code>element</code> <code>TEncodable</code> <p>The value to search for within the list.</p> required <code>rank</code> <code>Optional[int]</code> <p>The rank of the match to return.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>The number of matches wanted. A <code>count</code> of 0 returns all the matches.</p> <code>None</code> <code>max_len</code> <code>Optional[int]</code> <p>The maximum number of comparisons to make between the element and the items                      in the list. A <code>max_len</code> of 0 means unlimited amount of comparisons.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[int, List[int], None]</code> <p>Union[int, List[int], None]: The index of the first occurrence of <code>element</code>,</p> <code>Union[int, List[int], None]</code> <p>or None if <code>element</code> is not in the list.</p> <code>Union[int, List[int], None]</code> <p>With the <code>count</code> option, a list of indices of matching elements will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n&gt;&gt;&gt; await client.lpos(key, 'c')\n    2\n&gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n    6\n&gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n    7\n&gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n    [2, 6]\n&gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n    [2, 6, 7]\n</code></pre> <p>Since: Valkey version 6.0.6.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpos(\n    self,\n    key: TEncodable,\n    element: TEncodable,\n    rank: Optional[int] = None,\n    count: Optional[int] = None,\n    max_len: Optional[int] = None,\n) -&gt; Union[int, List[int], None]:\n    \"\"\"\n    Returns the index or indexes of element(s) matching `element` in the `key` list. If no match is found,\n    None is returned.\n\n    See https://valkey.io/commands/lpos for more details.\n\n    Args:\n        key (TEncodable): The name of the list.\n        element (TEncodable): The value to search for within the list.\n        rank (Optional[int]): The rank of the match to return.\n        count (Optional[int]): The number of matches wanted. A `count` of 0 returns all the matches.\n        max_len (Optional[int]): The maximum number of comparisons to make between the element and the items\n                                 in the list. A `max_len` of 0 means unlimited amount of comparisons.\n\n    Returns:\n        Union[int, List[int], None]: The index of the first occurrence of `element`,\n        or None if `element` is not in the list.\n        With the `count` option, a list of indices of matching elements will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n        &gt;&gt;&gt; await client.lpos(key, 'c')\n            2\n        &gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n            6\n        &gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n            7\n        &gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n            [2, 6]\n        &gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n            [2, 6, 7]\n\n    Since: Valkey version 6.0.6.\n    \"\"\"\n    args: List[TEncodable] = [key, element]\n\n    if rank is not None:\n        args.extend([\"RANK\", str(rank)])\n\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    if max_len is not None:\n        args.extend([\"MAXLEN\", str(max_len)])\n\n    return cast(\n        Union[int, List[int], None],\n        await self._execute_command(RequestType.LPos, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lpush","title":"<code>lpush(key, elements)</code>  <code>async</code>","text":"<p>Insert all the specified values at the head of the list stored at <code>key</code>. <code>elements</code> are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. If <code>key</code> does not exist, it is created as empty list before performing the push operations. See https://valkey.io/commands/lpush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the head of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n    3 # Indicates that the new length of the list is 3 after the push operation.\n&gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n    1\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Insert all the specified values at the head of the list stored at `key`.\n    `elements` are inserted one after the other to the head of the list, from the leftmost element\n    to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n    See https://valkey.io/commands/lpush/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operations.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n            3 # Indicates that the new length of the list is 3 after the push operation.\n        &gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n            1\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.LPush, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lpushx","title":"<code>lpushx(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the head of the list stored at <code>key</code>, only if <code>key</code> exists and holds a list. If <code>key</code> is not a list, this performs no operation.</p> <p>See https://valkey.io/commands/lpushx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the head of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n    3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n&gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n    0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the head of the list stored at `key`, only if `key` exists and holds a list.\n    If `key` is not a list, this performs no operation.\n\n    See https://valkey.io/commands/lpushx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operation.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n            3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n        &gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n            0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.LPushX, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lrange","title":"<code>lrange(key, start, end)</code>  <code>async</code>","text":"<p>Retrieve the specified elements of the list stored at <code>key</code> within the given range. The offsets <code>start</code> and <code>end</code> are zero-based indexes, with 0 being the first element of the list, 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last element of the list, -2 being the penultimate, and so on. See https://valkey.io/commands/lrange/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements within the specified range.</p> <code>List[bytes]</code> <p>If <code>start</code> exceeds the <code>end</code> of the list, or if <code>start</code> is greater than <code>end</code>, an empty list will be returned.</p> <code>List[bytes]</code> <p>If <code>end</code> exceeds the actual end of the list, the range will stop at the actual end of the list.</p> <code>List[bytes]</code> <p>If <code>key</code> does not exist an empty list will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n    [b\"value1\", b\"value2\", b\"value3\"]\n&gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n    [b\"value2\", b\"value3\"]\n&gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n    []\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lrange(self, key: TEncodable, start: int, end: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieve the specified elements of the list stored at `key` within the given range.\n    The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n    element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list,\n    with -1 being the last element of the list, -2 being the penultimate, and so on.\n    See https://valkey.io/commands/lrange/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        List[bytes]: A list of elements within the specified range.\n        If `start` exceeds the `end` of the list, or if `start` is greater than `end`, an empty list will be returned.\n        If `end` exceeds the actual end of the list, the range will stop at the actual end of the list.\n        If `key` does not exist an empty list will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n            [b\"value1\", b\"value2\", b\"value3\"]\n        &gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n            [b\"value2\", b\"value3\"]\n        &gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n            []\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(\n            RequestType.LRange, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lrem","title":"<code>lrem(key, count, element)</code>  <code>async</code>","text":"<p>Removes the first <code>count</code> occurrences of elements equal to <code>element</code> from the list stored at <code>key</code>. If <code>count</code> is positive, it removes elements equal to <code>element</code> moving from head to tail. If <code>count</code> is negative, it removes elements equal to <code>element</code> moving from tail to head. If <code>count</code> is 0 or greater than the occurrences of elements equal to <code>element</code>, it removes all elements equal to <code>element</code>. See https://valkey.io/commands/lrem/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of occurrences of elements equal to <code>element</code> to remove.</p> required <code>element</code> <code>TEncodable</code> <p>The element to remove from the list.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of removed elements. If <code>key</code> does not exist, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n    2  # Removes the first 2 occurrences of \"value\" in the list.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lrem(self, key: TEncodable, count: int, element: TEncodable) -&gt; int:\n    \"\"\"\n    Removes the first `count` occurrences of elements equal to `element` from the list stored at `key`.\n    If `count` is positive, it removes elements equal to `element` moving from head to tail.\n    If `count` is negative, it removes elements equal to `element` moving from tail to head.\n    If `count` is 0 or greater than the occurrences of elements equal to `element`, it removes all elements\n    equal to `element`.\n    See https://valkey.io/commands/lrem/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of occurrences of elements equal to `element` to remove.\n        element (TEncodable): The element to remove from the list.\n\n    Returns:\n        int: The number of removed elements.\n            If `key` does not exist, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n            2  # Removes the first 2 occurrences of \"value\" in the list.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.LRem, [key, str(count), element]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.lset","title":"<code>lset(key, index, element)</code>  <code>async</code>","text":"<p>Sets the list element at <code>index</code> to <code>element</code>.</p> <p>The index is zero-based, so <code>0</code> means the first element, <code>1</code> the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, <code>-1</code> means the last element, <code>-2</code> means the penultimate and so forth.</p> <p>See https://valkey.io/commands/lset/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index of the element in the list to be set.</p> required <code>element</code> <code>TEncodable</code> <p>The new element to set at the specified index.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n    OK\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lset(self, key: TEncodable, index: int, element: TEncodable) -&gt; TOK:\n    \"\"\"\n    Sets the list element at `index` to `element`.\n\n    The index is zero-based, so `0` means the first element, `1` the second element and so on.\n    Negative indices can be used to designate elements starting at the tail of the list.\n    Here, `-1` means the last element, `-2` means the penultimate and so forth.\n\n    See https://valkey.io/commands/lset/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        index (int): The index of the element in the list to be set.\n        element (TEncodable): The new element to set at the specified index.\n\n    Returns:\n        TOK: A simple `OK` response.\n\n    Examples:\n        &gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n            OK\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.LSet, [key, str(index), element]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.ltrim","title":"<code>ltrim(key, start, end)</code>  <code>async</code>","text":"<p>Trim an existing list so that it will contain only the specified range of elements specified. The offsets <code>start</code> and <code>end</code> are zero-based indexes, with 0 being the first element of the list, 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last element of the list, -2 being the penultimate, and so on. See https://valkey.io/commands/ltrim/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response. If <code>start</code> exceeds the end of the list, or if <code>start</code> is greater than <code>end</code>, the result will be an empty list (which causes <code>key</code> to be removed). If <code>end</code> exceeds the actual end of the list, it will be treated like the last element of the list. If <code>key</code> does not exist, \"OK\" will be returned without changes to the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n    \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def ltrim(self, key: TEncodable, start: int, end: int) -&gt; TOK:\n    \"\"\"\n    Trim an existing list so that it will contain only the specified range of elements specified.\n    The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n    element and so on.\n    These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last\n    element of the list, -2 being the penultimate, and so on.\n    See https://valkey.io/commands/ltrim/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n            If `start` exceeds the end of the list, or if `start` is greater than `end`, the result will be an empty list\n            (which causes `key` to be removed).\n            If `end` exceeds the actual end of the list, it will be treated like the last element of the list.\n            If `key` does not exist, \"OK\" will be returned without changes to the database.\n\n    Examples:\n        &gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n            \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.LTrim, [key, str(start), str(end)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.mget","title":"<code>mget(keys)</code>  <code>async</code>","text":"<p>Retrieve the values of multiple keys. See https://valkey.io/commands/mget/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys to retrieve values for.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,</p> <code>List[Optional[bytes]]</code> <p>its corresponding value in the list will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n&gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n&gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n    [b'value1' , b'value2']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def mget(self, keys: List[TEncodable]) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Retrieve the values of multiple keys.\n    See https://valkey.io/commands/mget/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): A list of keys to retrieve values for.\n\n    Returns:\n        List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,\n        its corresponding value in the list will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n        &gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n        &gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n            [b'value1' , b'value2']\n    \"\"\"\n    return cast(\n        List[Optional[bytes]], await self._execute_command(RequestType.MGet, keys)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.mset","title":"<code>mset(key_value_map)</code>  <code>async</code>","text":"<p>Set multiple keys to multiple values in a single atomic operation. See https://valkey.io/commands/mset/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when keys in <code>key_value_map</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>key_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A map of key value pairs.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>a simple OK response.</p> Example <p>await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})     'OK'</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def mset(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n    \"\"\"\n    Set multiple keys to multiple values in a single atomic operation.\n    See https://valkey.io/commands/mset/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when keys in `key_value_map` map to different hash slots.\n\n    Args:\n        key_value_map (Mapping[TEncodable, TEncodable]): A map of key value pairs.\n\n    Returns:\n        OK: a simple OK response.\n\n    Example:\n        &gt;&gt;&gt; await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})\n            'OK'\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in key_value_map.items():\n        parameters.extend(pair)\n    return cast(TOK, await self._execute_command(RequestType.MSet, parameters))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.msetnx","title":"<code>msetnx(key_value_map)</code>  <code>async</code>","text":"<p>Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or more keys already exist, the entire operation fails.</p> Note <p>When in cluster mode, all keys in <code>key_value_map</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/msetnx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A key-value map consisting of keys and their respective values to set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all keys were set. False if no key was set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n    True\n&gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n    False\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def msetnx(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; bool:\n    \"\"\"\n    Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or\n    more keys already exist, the entire operation fails.\n\n    Note:\n        When in cluster mode, all keys in `key_value_map` must map to the same hash slot.\n\n    See https://valkey.io/commands/msetnx/ for more details.\n\n    Args:\n        key_value_map (Mapping[TEncodable, TEncodable]): A key-value map consisting of keys and their respective values to set.\n\n    Returns:\n        bool: True if all keys were set. False if no key was set.\n\n    Examples:\n        &gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n            True\n        &gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n            False\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in key_value_map.items():\n        parameters.extend(pair)\n    return cast(\n        bool,\n        await self._execute_command(RequestType.MSetNX, parameters),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.object_encoding","title":"<code>object_encoding(key)</code>  <code>async</code>","text":"<p>Returns the internal encoding for the Valkey object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-encoding for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> of the object to get the internal encoding of.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, returns the internal encoding of the object stored at <code>key</code> as a bytes string. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n    b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_encoding(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns the internal encoding for the Valkey object stored at `key`.\n\n    See https://valkey.io/commands/object-encoding for more details.\n\n    Args:\n        key (TEncodable): The `key` of the object to get the internal encoding of.\n\n    Returns:\n        Optional[bytes]: If `key` exists, returns the internal encoding of the object stored at\n            `key` as a bytes string. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n            b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.ObjectEncoding, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.object_freq","title":"<code>object_freq(key)</code>  <code>async</code>","text":"<p>Returns the logarithmic access frequency counter of a Valkey object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-freq for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the logarithmic access frequency counter of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the logarithmic access frequency counter of the object stored at <code>key</code> as an integer. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_freq(\"my_hash\")\n    2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_freq(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the logarithmic access frequency counter of a Valkey object stored at `key`.\n\n    See https://valkey.io/commands/object-freq for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the logarithmic access frequency counter of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the logarithmic access frequency counter of the object stored at `key` as an\n            integer. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_freq(\"my_hash\")\n            2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectFreq, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.object_idletime","title":"<code>object_idletime(key)</code>  <code>async</code>","text":"<p>Returns the time in seconds since the last access to the value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-idletime for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the idle time of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the idle time in seconds. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n    13  # \"my_hash\" was last accessed 13 seconds ago.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_idletime(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the time in seconds since the last access to the value stored at `key`.\n\n    See https://valkey.io/commands/object-idletime for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the idle time of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the idle time in seconds. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n            13  # \"my_hash\" was last accessed 13 seconds ago.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectIdleTime, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.object_refcount","title":"<code>object_refcount(key)</code>  <code>async</code>","text":"<p>Returns the reference count of the object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-refcount for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the reference count of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the reference count of the object stored at <code>key</code> as an integer. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n    2  # \"my_hash\" has a reference count of 2.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_refcount(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the reference count of the object stored at `key`.\n\n    See https://valkey.io/commands/object-refcount for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the reference count of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the reference count of the object stored at `key` as an integer.\n            Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n            2  # \"my_hash\" has a reference count of 2.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectRefCount, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.persist","title":"<code>persist(key)</code>  <code>async</code>","text":"<p>Remove the existing timeout on <code>key</code>, turning the key from volatile (a key with an expire set) to persistent (a key that will never expire as no timeout is associated).</p> <p>See https://valkey.io/commands/persist/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to remove the existing timeout on.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if <code>key</code> does not exist or does not have an associated timeout, True if the timeout has been removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.persist(\"my_key\")\n    True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def persist(\n    self,\n    key: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Remove the existing timeout on `key`, turning the key from volatile (a key with an expire set) to\n    persistent (a key that will never expire as no timeout is associated).\n\n    See https://valkey.io/commands/persist/ for more details.\n\n    Args:\n        key (TEncodable): The key to remove the existing timeout on.\n\n    Returns:\n        bool: False if `key` does not exist or does not have an associated timeout, True if the timeout has been removed.\n\n    Examples:\n        &gt;&gt;&gt; await client.persist(\"my_key\")\n            True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.Persist, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pexpire","title":"<code>pexpire(key, milliseconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> in milliseconds. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. If <code>milliseconds</code> is a non-positive number, the key will be deleted rather than expired. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/pexpire/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>milliseconds</code> <code>int</code> <p>The timeout in milliseconds.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n    True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpire(\n    self,\n    key: TEncodable,\n    milliseconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` in milliseconds. After the timeout has expired, the key will automatically be deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    If `milliseconds` is a non-positive number, the key will be deleted rather than expired.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/pexpire/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        milliseconds (int): The timeout in milliseconds.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n            True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n    \"\"\"\n    args = (\n        [key, str(milliseconds)]\n        if option is None\n        else [key, str(milliseconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.PExpire, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pexpireat","title":"<code>pexpireat(key, unix_milliseconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead of specifying the number of milliseconds. A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/pexpireat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>unix_milliseconds</code> <code>int</code> <p>The timeout in an absolute Unix timestamp in milliseconds.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n    True\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpireat(\n    self,\n    key: TEncodable,\n    unix_milliseconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead\n    of specifying the number of milliseconds.\n    A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n    deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/pexpireat/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        unix_milliseconds (int): The timeout in an absolute Unix timestamp in milliseconds.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n            True\n    \"\"\"\n    args = (\n        [key, str(unix_milliseconds)]\n        if option is None\n        else [key, str(unix_milliseconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.PExpireAt, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pexpiretime","title":"<code>pexpiretime(key)</code>  <code>async</code>","text":"<p>Returns the absolute Unix timestamp (since January 1, 1970) at which the given <code>key</code> will expire, in milliseconds.</p> <p>See https://valkey.io/commands/pexpiretime/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to determine the expiration value of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expiration Unix timestamp in milliseconds, -2 if <code>key</code> does not exist, or -1 if <code>key</code> exists but has no associated expiration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    -2 # 'my_key' doesn't exist.\n&gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    -1 # 'my_key' has no associate expiration.\n&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    1718615446670\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpiretime(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the absolute Unix timestamp (since January 1, 1970) at which\n    the given `key` will expire, in milliseconds.\n\n    See https://valkey.io/commands/pexpiretime/ for details.\n\n    Args:\n        key (TEncodable): The `key` to determine the expiration value of.\n\n    Returns:\n        int: The expiration Unix timestamp in milliseconds, -2 if `key` does not exist, or -1 if `key` exists but has no associated expiration.\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            -2 # 'my_key' doesn't exist.\n        &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            -1 # 'my_key' has no associate expiration.\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            1718615446670\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.PExpireTime, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pfadd","title":"<code>pfadd(key, elements)</code>  <code>async</code>","text":"<p>Adds all elements to the HyperLogLog data structure stored at the specified <code>key</code>. Creates a new structure if the <code>key</code> does not exist. When no elements are provided, and <code>key</code> exists and is a HyperLogLog, then no operation is performed.</p> <p>See https://valkey.io/commands/pfadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the HyperLogLog data structure to add elements into.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>A list of members to add to the HyperLogLog stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is</p> <code>int</code> <p>altered, then returns 1. Otherwise, returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n    1 # A data structure was created or modified\n&gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n    1 # A new empty data structure was created\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfadd(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Adds all elements to the HyperLogLog data structure stored at the specified `key`.\n    Creates a new structure if the `key` does not exist.\n    When no elements are provided, and `key` exists and is a HyperLogLog, then no operation is performed.\n\n    See https://valkey.io/commands/pfadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the HyperLogLog data structure to add elements into.\n        elements (List[TEncodable]): A list of members to add to the HyperLogLog stored at `key`.\n\n    Returns:\n        int: If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is\n        altered, then returns 1. Otherwise, returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n            1 # A data structure was created or modified\n        &gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n            1 # A new empty data structure was created\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PfAdd, [key] + elements),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pfcount","title":"<code>pfcount(keys)</code>  <code>async</code>","text":"<p>Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.</p> <p>See https://valkey.io/commands/pfcount for more details.</p> Note <p>When in Cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the HyperLogLog data structures to be analyzed.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The approximated cardinality of given HyperLogLog data structures. The cardinality of a key that does not exist is 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n    4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfcount(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or\n    calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.\n\n    See https://valkey.io/commands/pfcount for more details.\n\n    Note:\n        When in Cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the HyperLogLog data structures to be analyzed.\n\n    Returns:\n        int: The approximated cardinality of given HyperLogLog data structures.\n            The cardinality of a key that does not exist is 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n            4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PfCount, keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pfmerge","title":"<code>pfmerge(destination, source_keys)</code>  <code>async</code>","text":"<p>Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.</p> <p>See https://valkey.io/commands/pfmerge for more details.</p> Note <p>When in Cluster mode, all keys in <code>source_keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination HyperLogLog where the merged data sets will be stored.</p> required <code>source_keys</code> <code>List[TEncodable]</code> <p>The keys of the HyperLogLog structures to be merged.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n&gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n&gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n    OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n&gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n    3  # The approximated cardinality of \"new_hll\" is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfmerge(\n    self, destination: TEncodable, source_keys: List[TEncodable]\n) -&gt; TOK:\n    \"\"\"\n    Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one\n    of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.\n\n    See https://valkey.io/commands/pfmerge for more details.\n\n    Note:\n        When in Cluster mode, all keys in `source_keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination HyperLogLog where the merged data sets will be stored.\n        source_keys (List[TEncodable]): The keys of the HyperLogLog structures to be merged.\n\n    Returns:\n        OK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n        &gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n        &gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n            OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n        &gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n            3  # The approximated cardinality of \"new_hll\" is 3.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.PfMerge, [destination] + source_keys\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pttl","title":"<code>pttl(key)</code>  <code>async</code>","text":"<p>Returns the remaining time to live of <code>key</code> that has a timeout, in milliseconds. See https://valkey.io/commands/pttl for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its timeout.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TTL in milliseconds. -2 if <code>key</code> does not exist, -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pttl(\"my_key\")\n    5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n&gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n    -2  # Indicates that the key \"non_existing_key\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pttl(\n    self,\n    key: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Returns the remaining time to live of `key` that has a timeout, in milliseconds.\n    See https://valkey.io/commands/pttl for more details.\n\n    Args:\n        key (TEncodable): The key to return its timeout.\n\n    Returns:\n        int: TTL in milliseconds. -2 if `key` does not exist, -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.pttl(\"my_key\")\n            5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n        &gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n            -2  # Indicates that the key \"non_existing_key\" does not exist.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PTTL, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pubsub_channels","title":"<code>pubsub_channels(pattern=None)</code>  <code>async</code>","text":"<p>Lists the currently active channels. The command is routed to all nodes, and aggregates the response to a single array.</p> <p>See https://valkey.io/commands/pubsub-channels for more details.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>Optional[TEncodable]</code> <p>A glob-style pattern to match active channels.                 If not provided, all active channels are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of currently active channels matching the given pattern.     If no pattern is specified, all active channels are returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_channels()\n    [b\"channel1\", b\"channel2\"]\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n    [b\"news.sports\", \"news.weather\"]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_channels(\n    self, pattern: Optional[TEncodable] = None\n) -&gt; List[bytes]:\n    \"\"\"\n    Lists the currently active channels.\n    The command is routed to all nodes, and aggregates the response to a single array.\n\n    See https://valkey.io/commands/pubsub-channels for more details.\n\n    Args:\n        pattern (Optional[TEncodable]): A glob-style pattern to match active channels.\n                            If not provided, all active channels are returned.\n\n    Returns:\n        List[bytes]: A list of currently active channels matching the given pattern.\n                If no pattern is specified, all active channels are returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_channels()\n            [b\"channel1\", b\"channel2\"]\n\n        &gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n            [b\"news.sports\", \"news.weather\"]\n    \"\"\"\n\n    return cast(\n        List[bytes],\n        await self._execute_command(\n            RequestType.PubSubChannels, [pattern] if pattern else []\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pubsub_numpat","title":"<code>pubsub_numpat()</code>  <code>async</code>","text":"<p>Returns the number of unique patterns that are subscribed to by clients.</p> <p>Note: This is the total number of unique patterns all the clients are subscribed to, not the count of clients subscribed to patterns. The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.</p> <p>See https://valkey.io/commands/pubsub-numpat for more details.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of unique patterns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_numpat()\n    3\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_numpat(self) -&gt; int:\n    \"\"\"\n    Returns the number of unique patterns that are subscribed to by clients.\n\n    Note: This is the total number of unique patterns all the clients are subscribed to,\n    not the count of clients subscribed to patterns.\n    The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.\n\n    See https://valkey.io/commands/pubsub-numpat for more details.\n\n    Returns:\n        int: The number of unique patterns.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_numpat()\n            3\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.PubSubNumPat, []))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.pubsub_numsub","title":"<code>pubsub_numsub(channels=None)</code>  <code>async</code>","text":"<p>Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.</p> <p>Note that it is valid to call this command without channels. In this case, it will just return an empty map. The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.</p> <p>See https://valkey.io/commands/pubsub-numsub for more details.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[List[TEncodable]]</code> <p>The list of channels to query for the number of subscribers.                             If not provided, returns an empty map.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, int]</code> <p>Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n    {b'channel1': 3, b'channel2': 5}\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_numsub()\n    {}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_numsub(\n    self, channels: Optional[List[TEncodable]] = None\n) -&gt; Mapping[bytes, int]:\n    \"\"\"\n    Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.\n\n    Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n    The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n    See https://valkey.io/commands/pubsub-numsub for more details.\n\n    Args:\n        channels (Optional[List[TEncodable]]): The list of channels to query for the number of subscribers.\n                                        If not provided, returns an empty map.\n\n    Returns:\n        Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n            {b'channel1': 3, b'channel2': 5}\n\n        &gt;&gt;&gt; await client.pubsub_numsub()\n            {}\n    \"\"\"\n    return cast(\n        Mapping[bytes, int],\n        await self._execute_command(\n            RequestType.PubSubNumSub, channels if channels else []\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.rename","title":"<code>rename(key, new_key)</code>  <code>async</code>","text":"<p>Renames <code>key</code> to <code>new_key</code>. If <code>newkey</code> already exists it is overwritten. See https://valkey.io/commands/rename/ for more details.</p> Note <p>When in cluster mode, both <code>key</code> and <code>newkey</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable) </code> <p>The key to rename.</p> required <code>new_key</code> <code>TEncodable) </code> <p>The new name of the key.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>If the <code>key</code> was successfully renamed, return \"OK\". If <code>key</code> does not exist, an error is thrown.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rename(self, key: TEncodable, new_key: TEncodable) -&gt; TOK:\n    \"\"\"\n    Renames `key` to `new_key`.\n    If `newkey` already exists it is overwritten.\n    See https://valkey.io/commands/rename/ for more details.\n\n    Note:\n        When in cluster mode, both `key` and `newkey` must map to the same hash slot.\n\n    Args:\n        key (TEncodable) : The key to rename.\n        new_key (TEncodable) : The new name of the key.\n\n    Returns:\n        OK: If the `key` was successfully renamed, return \"OK\". If `key` does not exist, an error is thrown.\n    \"\"\"\n    return cast(\n        TOK, await self._execute_command(RequestType.Rename, [key, new_key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.renamenx","title":"<code>renamenx(key, new_key)</code>  <code>async</code>","text":"<p>Renames <code>key</code> to <code>new_key</code> if <code>new_key</code> does not yet exist.</p> <p>See https://valkey.io/commands/renamenx for more details.</p> Note <p>When in cluster mode, both <code>key</code> and <code>new_key</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to rename.</p> required <code>new_key</code> <code>TEncodable</code> <p>The new key name.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>key</code> was renamed to <code>new_key</code>, or False if <code>new_key</code> already exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n    True  # \"old_key\" was renamed to \"new_key\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def renamenx(self, key: TEncodable, new_key: TEncodable) -&gt; bool:\n    \"\"\"\n    Renames `key` to `new_key` if `new_key` does not yet exist.\n\n    See https://valkey.io/commands/renamenx for more details.\n\n    Note:\n        When in cluster mode, both `key` and `new_key` must map to the same hash slot.\n\n    Args:\n        key (TEncodable): The key to rename.\n        new_key (TEncodable): The new key name.\n\n    Returns:\n        bool: True if `key` was renamed to `new_key`, or False if `new_key` already exists.\n\n    Examples:\n        &gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n            True  # \"old_key\" was renamed to \"new_key\"\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.RenameNX, [key, new_key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.restore","title":"<code>restore(key, ttl, value, replace=False, absttl=False, idletime=None, frequency=None)</code>  <code>async</code>","text":"<p>Create a <code>key</code> associated with a <code>value</code> that is obtained by deserializing the provided serialized <code>value</code> obtained via <code>dump</code>.</p> <p>See https://valkey.io/commands/restore for more details.</p> <p>Note: <code>IDLETIME</code> and <code>FREQ</code> modifiers cannot be set at the same time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to create.</p> required <code>ttl</code> <code>int</code> <p>The expiry time (in milliseconds). If <code>0</code>, the <code>key</code> will persist.</p> required <code>replace</code> <code>bool</code> <p>Set to <code>True</code> to replace the key if it exists.</p> <code>False</code> <code>absttl</code> <code>bool</code> <p>Set to <code>True</code> to specify that <code>ttl</code> represents an absolute Unix timestamp (in milliseconds).</p> <code>False</code> <code>idletime</code> <code>Optional[int]</code> <p>Set the <code>IDLETIME</code> option with object idletime to the given key.</p> <code>None</code> <code>frequency</code> <code>Optional[int]</code> <p>Set the <code>FREQ</code> option with object frequency to the given key.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>If the <code>key</code> was successfully restored with a <code>value</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n    OK # Indicates restore `newKey` without any ttl expiry nor any option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n    OK # Indicates restore `newKey` with `REPLACE` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n    OK # Indicates restore `newKey` with `ABSTTL` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n    OK # Indicates restore `newKey` with `IDLETIME` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n    OK # Indicates restore `newKey` with `FREQ` option\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def restore(\n    self,\n    key: TEncodable,\n    ttl: int,\n    value: TEncodable,\n    replace: bool = False,\n    absttl: bool = False,\n    idletime: Optional[int] = None,\n    frequency: Optional[int] = None,\n) -&gt; TOK:\n    \"\"\"\n    Create a `key` associated with a `value` that is obtained by deserializing the provided\n    serialized `value` obtained via `dump`.\n\n    See https://valkey.io/commands/restore for more details.\n\n    Note: `IDLETIME` and `FREQ` modifiers cannot be set at the same time.\n\n    Args:\n        key (TEncodable): The `key` to create.\n        ttl (int): The expiry time (in milliseconds). If `0`, the `key` will persist.\n        value (TEncodable) The serialized value to deserialize and assign to `key`.\n        replace (bool): Set to `True` to replace the key if it exists.\n        absttl (bool): Set to `True` to specify that `ttl` represents an absolute Unix\n            timestamp (in milliseconds).\n        idletime (Optional[int]): Set the `IDLETIME` option with object idletime to the given key.\n        frequency (Optional[int]): Set the `FREQ` option with object frequency to the given key.\n\n    Returns:\n        OK: If the `key` was successfully restored with a `value`.\n\n    Examples:\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n            OK # Indicates restore `newKey` without any ttl expiry nor any option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n            OK # Indicates restore `newKey` with `REPLACE` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n            OK # Indicates restore `newKey` with `ABSTTL` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n            OK # Indicates restore `newKey` with `IDLETIME` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n            OK # Indicates restore `newKey` with `FREQ` option\n    \"\"\"\n    args = [key, str(ttl), value]\n    if replace is True:\n        args.append(\"REPLACE\")\n    if absttl is True:\n        args.append(\"ABSTTL\")\n    if idletime is not None:\n        args.extend([\"IDLETIME\", str(idletime)])\n    if frequency is not None:\n        args.extend([\"FREQ\", str(frequency)])\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.Restore, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.rpop","title":"<code>rpop(key)</code>  <code>async</code>","text":"<p>Removes and returns the last elements of the list stored at <code>key</code>. The command pops a single element from the end of the list. See https://valkey.io/commands/rpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the last element.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpop(\"my_list\")\n    b\"value1\"\n&gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Removes and returns the last elements of the list stored at `key`.\n    The command pops a single element from the end of the list.\n    See https://valkey.io/commands/rpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        Optional[bytes]: The value of the last element.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpop(\"my_list\")\n            b\"value1\"\n        &gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.RPop, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.rpop_count","title":"<code>rpop_count(key, count)</code>  <code>async</code>","text":"<p>Removes and returns up to <code>count</code> elements from the list stored at <code>key</code>, depending on the list's length. See https://valkey.io/commands/rpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of elements to pop from the list.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.</p> <code>Optional[List[bytes]]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n    [b\"value1\", b\"value2\"]\n&gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Removes and returns up to `count` elements from the list stored at `key`, depending on the list's length.\n    See https://valkey.io/commands/rpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of elements to pop from the list.\n\n    Returns:\n        Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n            [b\"value1\", b\"value2\"]\n        &gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n            None\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.RPop, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.rpush","title":"<code>rpush(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the tail of the list stored at <code>key</code>. <code>elements</code> are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. If <code>key</code> does not exist, it is created as empty list before performing the push operations. See https://valkey.io/commands/rpush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the tail of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n    3 # Indicates that the new length of the list is 3 after the push operation.\n&gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n    1\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the tail of the list stored at `key`.\n    `elements` are inserted one after the other to the tail of the list, from the leftmost element\n    to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n    See https://valkey.io/commands/rpush/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operations.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n            3 # Indicates that the new length of the list is 3 after the push operation.\n        &gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n            1\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.RPush, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.rpushx","title":"<code>rpushx(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the tail of the list stored at <code>key</code>, only if <code>key</code> exists and holds a list. If <code>key</code> is not a list, this performs no operation.</p> <p>See https://valkey.io/commands/rpushx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the tail of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n    3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n&gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n    0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the tail of the list stored at `key`, only if `key` exists and holds a list.\n    If `key` is not a list, this performs no operation.\n\n    See https://valkey.io/commands/rpushx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operation.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n            3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n        &gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n            0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.RPushX, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sadd","title":"<code>sadd(key, members)</code>  <code>async</code>","text":"<p>Add specified members to the set stored at <code>key</code>. Specified members that are already a member of this set are ignored. If <code>key</code> does not exist, a new set is created before adding <code>members</code>. See https://valkey.io/commands/sadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key where members will be added to its set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to add to the set stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were added to the set, excluding members already present.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n    2\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sadd(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Add specified members to the set stored at `key`.\n    Specified members that are already a member of this set are ignored.\n    If `key` does not exist, a new set is created before adding `members`.\n    See https://valkey.io/commands/sadd/ for more details.\n\n    Args:\n        key (TEncodable): The key where members will be added to its set.\n        members (List[TEncodable]): A list of members to add to the set stored at `key`.\n\n    Returns:\n        int: The number of members that were added to the set, excluding members already present.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n            2\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SAdd, [key] + members))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.scard","title":"<code>scard(key)</code>  <code>async</code>","text":"<p>Retrieve the set cardinality (number of elements) of the set stored at <code>key</code>. See https://valkey.io/commands/scard/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the number of set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The cardinality (number of elements) of the set, or 0 if the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.scard(\"my_set\")\n    3\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def scard(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Retrieve the set cardinality (number of elements) of the set stored at `key`.\n    See https://valkey.io/commands/scard/ for details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the number of set members.\n\n    Returns:\n        int: The cardinality (number of elements) of the set, or 0 if the key does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.scard(\"my_set\")\n            3\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SCard, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.script_show","title":"<code>script_show(sha1)</code>  <code>async</code>","text":"<p>Returns the original source code of a script in the script cache.</p> <p>See https://valkey.io/commands/script-show for more details.</p> <p>Parameters:</p> Name Type Description Default <code>sha1</code> <code>TEncodable</code> <p>The SHA1 digest of the script.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The original source code of the script, if present in the cache. If the script is not found in the cache, an error is thrown.</p> Example <p>await client.script_show(script.get_hash())     b\"return { KEYS[1], ARGV[1] }\"</p> <p>Since: Valkey version 8.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def script_show(self, sha1: TEncodable) -&gt; bytes:\n    \"\"\"\n    Returns the original source code of a script in the script cache.\n\n    See https://valkey.io/commands/script-show for more details.\n\n    Args:\n        sha1 (TEncodable): The SHA1 digest of the script.\n\n    Returns:\n        bytes: The original source code of the script, if present in the cache.\n            If the script is not found in the cache, an error is thrown.\n\n    Example:\n        &gt;&gt;&gt; await client.script_show(script.get_hash())\n            b\"return { KEYS[1], ARGV[1] }\"\n\n    Since: Valkey version 8.0.0.\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.ScriptShow, [sha1]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sdiff","title":"<code>sdiff(keys)</code>  <code>async</code>","text":"<p>Computes the difference between the first set and all the successive sets in <code>keys</code>.</p> <p>See https://valkey.io/commands/sdiff for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets to diff</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of elements representing the difference between the sets. If any of the keys in <code>keys</code> do not exist, they are treated as empty sets.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n&gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n    {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sdiff(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Computes the difference between the first set and all the successive sets in `keys`.\n\n    See https://valkey.io/commands/sdiff for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets to diff\n\n    Returns:\n        Set[bytes]: A set of elements representing the difference between the sets.\n            If any of the keys in `keys` do not exist, they are treated as empty sets.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n        &gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n            {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n    \"\"\"\n    return cast(\n        Set[bytes],\n        await self._execute_command(RequestType.SDiff, keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sdiffstore","title":"<code>sdiffstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the difference between the first set and all the successive sets in <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sdiffstore for more details.</p> Note <p>When in Cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets to diff.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n&gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n    1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Stores the difference between the first set and all the successive sets in `keys` into a new set at\n    `destination`.\n\n    See https://valkey.io/commands/sdiffstore for more details.\n\n    Note:\n        When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys of the sets to diff.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n        &gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n            1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SDiffStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.set","title":"<code>set(key, value, conditional_set=None, expiry=None, return_old_value=False)</code>  <code>async</code>","text":"<p>Set the given key with the given value. Return value is dependent on the passed options. See https://valkey.io/commands/set/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>the key to store.</p> required <code>value</code> <code>TEncodable</code> <p>the value to store with the given key.</p> required <code>conditional_set</code> <code>Optional[ConditionalChange]</code> <p>set the key only if the given condition is met. Equivalent to [<code>XX</code> | <code>NX</code>] in the Valkey API. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>Optional[ExpirySet]</code> <p>set expiriation to the given key. Equivalent to [<code>EX</code> | <code>PX</code> | <code>EXAT</code> | <code>PXAT</code> | <code>KEEPTTL</code>] in the Valkey API. Defaults to None.</p> <code>None</code> <code>return_old_value</code> <code>bool</code> <p>Return the old value stored at key, or None if key did not exist. An error is returned and SET aborted if the value stored at key is not a string. Equivalent to <code>GET</code> in the Valkey API. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If the value is successfully set, return OK. If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None. If return_old_value is set, return the old value as a bytes string.</p> Example <p>await client.set(b\"key\", b\"value\")     'OK' await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))     'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds. await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)     b'new_value' # Returns the old value of \"key\". await client.get(\"key\")     b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def set(\n    self,\n    key: TEncodable,\n    value: TEncodable,\n    conditional_set: Optional[ConditionalChange] = None,\n    expiry: Optional[ExpirySet] = None,\n    return_old_value: bool = False,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Set the given key with the given value. Return value is dependent on the passed options.\n    See https://valkey.io/commands/set/ for more details.\n\n    Args:\n        key (TEncodable): the key to store.\n        value (TEncodable): the value to store with the given key.\n        conditional_set (Optional[ConditionalChange], optional): set the key only if the given condition is met.\n            Equivalent to [`XX` | `NX`] in the Valkey API. Defaults to None.\n        expiry (Optional[ExpirySet], optional): set expiriation to the given key.\n            Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `KEEPTTL`] in the Valkey API. Defaults to None.\n        return_old_value (bool, optional): Return the old value stored at key, or None if key did not exist.\n            An error is returned and SET aborted if the value stored at key is not a string.\n            Equivalent to `GET` in the Valkey API. Defaults to False.\n\n    Returns:\n        Optional[bytes]:\n            If the value is successfully set, return OK.\n            If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None.\n            If return_old_value is set, return the old value as a bytes string.\n\n    Example:\n        &gt;&gt;&gt; await client.set(b\"key\", b\"value\")\n            'OK'\n        &gt;&gt;&gt; await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))\n            'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds.\n        &gt;&gt;&gt; await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)\n            b'new_value' # Returns the old value of \"key\".\n        &gt;&gt;&gt; await client.get(\"key\")\n            b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.\n    \"\"\"\n    args = [key, value]\n    if conditional_set:\n        args.append(conditional_set.value)\n    if return_old_value:\n        args.append(\"GET\")\n    if expiry is not None:\n        args.extend(expiry.get_cmd_args())\n    return cast(Optional[bytes], await self._execute_command(RequestType.Set, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.setbit","title":"<code>setbit(key, offset, value)</code>  <code>async</code>","text":"<p>Sets or clears the bit at <code>offset</code> in the string value stored at <code>key</code>. The <code>offset</code> is a zero-based index, with <code>0</code> being the first element of the list, <code>1</code> being the next element, and so on. The <code>offset</code> must be less than <code>2^32</code> and greater than or equal to <code>0</code>. If a key is non-existent then the bit at <code>offset</code> is set to <code>value</code> and the preceding bits are set to <code>0</code>.</p> <p>See https://valkey.io/commands/setbit for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>offset</code> <code>int</code> <p>The index of the bit to be set.</p> required <code>value</code> <code>int</code> <p>The bit value to set at <code>offset</code>. The value must be <code>0</code> or <code>1</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The bit value that was previously stored at <code>offset</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n    0  # The second bit value was 0 before setting to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def setbit(self, key: TEncodable, offset: int, value: int) -&gt; int:\n    \"\"\"\n    Sets or clears the bit at `offset` in the string value stored at `key`. The `offset` is a zero-based index,\n    with `0` being the first element of the list, `1` being the next element, and so on. The `offset` must be less\n    than `2^32` and greater than or equal to `0`. If a key is non-existent then the bit at `offset` is set to\n    `value` and the preceding bits are set to `0`.\n\n    See https://valkey.io/commands/setbit for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        offset (int): The index of the bit to be set.\n        value (int): The bit value to set at `offset`. The value must be `0` or `1`.\n\n    Returns:\n        int: The bit value that was previously stored at `offset`.\n\n    Examples:\n        &gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n            0  # The second bit value was 0 before setting to 1.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.SetBit, [key, str(offset), str(value)]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.setrange","title":"<code>setrange(key, offset, value)</code>  <code>async</code>","text":"<p>Overwrites part of the string stored at <code>key</code>, starting at the specified <code>offset</code>, for the entire length of <code>value</code>. If the <code>offset</code> is larger than the current length of the string at <code>key</code>, the string is padded with zero bytes to make <code>offset</code> fit. Creates the <code>key</code> if it doesn't exist.</p> <p>See https://valkey.io/commands/setrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string to update.</p> required <code>offset</code> <code>int</code> <p>The position in the string where <code>value</code> should be written.</p> required <code>value</code> <code>TEncodable</code> <p>The value written with <code>offset</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the string stored at <code>key</code> after it was modified.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n&gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n    11  # The length of the string stored at `key` after it was modified.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def setrange(self, key: TEncodable, offset: int, value: TEncodable) -&gt; int:\n    \"\"\"\n    Overwrites part of the string stored at `key`, starting at the specified\n    `offset`, for the entire length of `value`.\n    If the `offset` is larger than the current length of the string at `key`,\n    the string is padded with zero bytes to make `offset` fit. Creates the `key`\n    if it doesn't exist.\n\n    See https://valkey.io/commands/setrange for more details.\n\n    Args:\n        key (TEncodable): The key of the string to update.\n        offset (int): The position in the string where `value` should be written.\n        value (TEncodable): The value written with `offset`.\n\n    Returns:\n        int: The length of the string stored at `key` after it was modified.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n        &gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n            11  # The length of the string stored at `key` after it was modified.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.SetRange, [key, str(offset), value]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sinter","title":"<code>sinter(keys)</code>  <code>async</code>","text":"<p>Gets the intersection of all the given sets.</p> <p>See https://valkey.io/commands/sinter for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of members which are present in all given sets. If one or more sets do no exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n     {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n&gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sinter(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Gets the intersection of all the given sets.\n\n    See https://valkey.io/commands/sinter for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets.\n\n    Returns:\n        Set[bytes]: A set of members which are present in all given sets.\n            If one or more sets do no exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n             {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n        &gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n            None\n    \"\"\"\n    return cast(Set[bytes], await self._execute_command(RequestType.SInter, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sintercard","title":"<code>sintercard(keys, limit=None)</code>  <code>async</code>","text":"<p>Gets the cardinality of the intersection of all the given sets. Optionally, a <code>limit</code> can be specified to stop the computation early if the intersection cardinality reaches the specified limit.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/sintercard for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys representing the sets to intersect.</p> required <code>limit</code> <code>Optional[int]</code> <p>An optional limit to the maximum number of intersecting elements to count. If specified, the computation stops as soon as the cardinality reaches this limit.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set of the intersection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n&gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n&gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n</code></pre> <pre><code>&gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sintercard(\n    self, keys: List[TEncodable], limit: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Gets the cardinality of the intersection of all the given sets.\n    Optionally, a `limit` can be specified to stop the computation early if the intersection cardinality reaches the specified limit.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/sintercard for more details.\n\n    Args:\n        keys (List[TEncodable]): A list of keys representing the sets to intersect.\n        limit (Optional[int]): An optional limit to the maximum number of intersecting elements to count.\n            If specified, the computation stops as soon as the cardinality reaches this limit.\n\n    Returns:\n        int: The number of elements in the resulting set of the intersection.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n        &gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n        &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n        2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n\n        &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n        1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    if limit is not None:\n        args += [\"LIMIT\", str(limit)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.SInterCard, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sinterstore","title":"<code>sinterstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the members of the intersection of all given sets specified by <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sinterstore for more details.</p> Note <p>When in Cluster mode, all <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys from which to retrieve the set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n    1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sinterstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Stores the members of the intersection of all given sets specified by `keys` into a new set at `destination`.\n\n    See https://valkey.io/commands/sinterstore for more details.\n\n    Note:\n        When in Cluster mode, all `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n            1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SInterStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sismember","title":"<code>sismember(key, member)</code>  <code>async</code>","text":"<p>Returns if <code>member</code> is a member of the set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/sismember/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>member</code> <code>TEncodable</code> <p>The member to check for existence in the set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the member exists in the set, False otherwise.</p> <code>bool</code> <p>If <code>key</code> doesn't exist, it is treated as an empty set and the command returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n    True  # Indicates that \"member1\" exists in the set \"my_set\".\n&gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n    False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sismember(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Returns if `member` is a member of the set stored at `key`.\n\n    See https://valkey.io/commands/sismember/ for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        member (TEncodable): The member to check for existence in the set.\n\n    Returns:\n        bool: True if the member exists in the set, False otherwise.\n        If `key` doesn't exist, it is treated as an empty set and the command returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n            True  # Indicates that \"member1\" exists in the set \"my_set\".\n        &gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n            False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.SIsMember, [key, member]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.smembers","title":"<code>smembers(key)</code>  <code>async</code>","text":"<p>Retrieve all the members of the set value stored at <code>key</code>. See https://valkey.io/commands/smembers/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the set members.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of all members of the set. If <code>key</code> does not exist an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.smembers(\"my_set\")\n    {b\"member1\", b\"member2\", b\"member3\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smembers(self, key: TEncodable) -&gt; Set[bytes]:\n    \"\"\"\n    Retrieve all the members of the set value stored at `key`.\n    See https://valkey.io/commands/smembers/ for details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the set members.\n\n    Returns:\n        Set[bytes]: A set of all members of the set.\n            If `key` does not exist an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.smembers(\"my_set\")\n            {b\"member1\", b\"member2\", b\"member3\"}\n    \"\"\"\n    return cast(\n        Set[bytes], await self._execute_command(RequestType.SMembers, [key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.smismember","title":"<code>smismember(key, members)</code>  <code>async</code>","text":"<p>Checks whether each member is contained in the members of the set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/smismember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set to check.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to check for existence in the set.</p> required <p>Returns:</p> Type Description <code>List[bool]</code> <p>List[bool]: A list of bool values, each indicating if the respective member exists in the set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n&gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n    [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smismember(\n    self, key: TEncodable, members: List[TEncodable]\n) -&gt; List[bool]:\n    \"\"\"\n    Checks whether each member is contained in the members of the set stored at `key`.\n\n    See https://valkey.io/commands/smismember for more details.\n\n    Args:\n        key (TEncodable): The key of the set to check.\n        members (List[TEncodable]): A list of members to check for existence in the set.\n\n    Returns:\n        List[bool]: A list of bool values, each indicating if the respective member exists in the set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n        &gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n            [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n    \"\"\"\n    return cast(\n        List[bool],\n        await self._execute_command(RequestType.SMIsMember, [key] + members),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.smove","title":"<code>smove(source, destination, member)</code>  <code>async</code>","text":"<p>Moves <code>member</code> from the set at <code>source</code> to the set at <code>destination</code>, removing it from the source set. Creates a new destination set if needed. The operation is atomic.</p> <p>See https://valkey.io/commands/smove for more details.</p> Note <p>When in cluster mode, <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key of the set to remove the element from.</p> required <code>destination</code> <code>TEncodable</code> <p>The key of the set to add the element to.</p> required <code>member</code> <code>TEncodable</code> <p>The set element to move.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True on success, or False if the <code>source</code> set does not exist or the element is not a member of the source set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n    True  # \"member1\" was moved from \"set1\" to \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    member: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Moves `member` from the set at `source` to the set at `destination`, removing it from the source set. Creates a\n    new destination set if needed. The operation is atomic.\n\n    See https://valkey.io/commands/smove for more details.\n\n    Note:\n        When in cluster mode, `source` and `destination` must map to the same hash slot.\n\n    Args:\n        source (TEncodable): The key of the set to remove the element from.\n        destination (TEncodable): The key of the set to add the element to.\n        member (TEncodable): The set element to move.\n\n    Returns:\n        bool: True on success, or False if the `source` set does not exist or the element is not a member of the source set.\n\n    Examples:\n        &gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n            True  # \"member1\" was moved from \"set1\" to \"set2\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(\n            RequestType.SMove, [source, destination, member]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sort","title":"<code>sort(key, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and returns the result. The <code>sort</code> command can be used to sort elements based on different criteria and apply transformations on sorted elements. This command is routed to primary nodes only. To store the result into a new key, see <code>sort_store</code>.</p> When in cluster mode, <code>key</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>See https://valkey.io/commands/sort for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_patterns</code> <code>Optional[List[TEncodable]]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: Returns a list of sorted elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n&gt;&gt;&gt; await client.sort(\"mylist\")\n    [b'1', b'2', b'3']\n&gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n    [b'3', b'2', b'1']\n&gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n&gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n    [b'2', b'2', b'3']\n&gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n&gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n&gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n&gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n    [b'Bob', b'Alice']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort(\n    self,\n    key: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n    The `sort` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n    This command is routed to primary nodes only.\n    To store the result into a new key, see `sort_store`.\n\n    Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        List[Optional[bytes]]: Returns a list of sorted elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n        &gt;&gt;&gt; await client.sort(\"mylist\")\n            [b'1', b'2', b'3']\n        &gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n            [b'3', b'2', b'1']\n        &gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n        &gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n            [b'2', b'2', b'3']\n        &gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n        &gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n        &gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n        &gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n            [b'Bob', b'Alice']\n    \"\"\"\n    args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n    result = await self._execute_command(RequestType.Sort, args)\n    return cast(List[Optional[bytes]], result)\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sort_ro","title":"<code>sort_ro(key, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and returns the result. The <code>sort_ro</code> command can be used to sort elements based on different criteria and apply transformations on sorted elements. This command is routed depending on the client's <code>ReadFrom</code> strategy.</p> <p>See https://valkey.io/commands/sort for more details.</p> When in cluster mode, <code>key</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> required <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: Returns a list of sorted elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n&gt;&gt;&gt; await client.sort_ro(\"mylist\")\n    [b'1', b'2', b'3']\n&gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n    [b'3', b'2', b'1']\n&gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n&gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n    [b'2', b'2', b'3']\n&gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n&gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n&gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n&gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n    [b'Bob', b'Alice']\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort_ro(\n    self,\n    key: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n    The `sort_ro` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n    This command is routed depending on the client's `ReadFrom` strategy.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_pattern (Optional[TEncodable]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        List[Optional[bytes]]: Returns a list of sorted elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n        &gt;&gt;&gt; await client.sort_ro(\"mylist\")\n            [b'1', b'2', b'3']\n        &gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n            [b'3', b'2', b'1']\n        &gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n        &gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n            [b'2', b'2', b'3']\n        &gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n        &gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n        &gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n        &gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n            [b'Bob', b'Alice']\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n    result = await self._execute_command(RequestType.SortReadOnly, args)\n    return cast(List[Optional[bytes]], result)\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sort_store","title":"<code>sort_store(key, destination, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and stores the result in <code>store</code>. The <code>sort</code> command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key. To get the sort result without storing it into a key, see <code>sort</code>.</p> <p>See https://valkey.io/commands/sort for more details.</p> When in cluster mode, <code>key</code>, <code>destination</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>destination</code> <code>TEncodable</code> <p>The key where the sorted result will be stored.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_patterns</code> <code>Optional[List[TEncodable]]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted key stored at <code>store</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n&gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n    3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n&gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n    [b'1', b'2', b'3']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort_store(\n    self,\n    key: TEncodable,\n    destination: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and stores the result in `store`.\n    The `sort` command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key.\n    To get the sort result without storing it into a key, see `sort`.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Note: When in cluster mode, `key`, `destination`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        destination (TEncodable): The key where the sorted result will be stored.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        int: The number of elements in the sorted key stored at `store`.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n        &gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n            3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n        &gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n            [b'1', b'2', b'3']\n    \"\"\"\n    args = _build_sort_args(\n        key, by_pattern, limit, get_patterns, order, alpha, store=destination\n    )\n    result = await self._execute_command(RequestType.Sort, args)\n    return cast(int, result)\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.spop","title":"<code>spop(key)</code>  <code>async</code>","text":"<p>Removes and returns one random member from the set stored at <code>key</code>.</p> <p>See https://valkey-io.github.io/commands/spop/ for more details. To pop multiple members, see <code>spop_count</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the popped member.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.spop(\"my_set\")\n    b\"value1\" # Removes and returns a random member from the set \"my_set\".\n&gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def spop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Removes and returns one random member from the set stored at `key`.\n\n    See https://valkey-io.github.io/commands/spop/ for more details.\n    To pop multiple members, see `spop_count`.\n\n    Args:\n        key (TEncodable): The key of the set.\n\n    Returns:\n        Optional[bytes]: The value of the popped member.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.spop(\"my_set\")\n            b\"value1\" # Removes and returns a random member from the set \"my_set\".\n        &gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.SPop, [key])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.spop_count","title":"<code>spop_count(key, count)</code>  <code>async</code>","text":"<p>Removes and returns up to <code>count</code> random members from the set stored at <code>key</code>, depending on the set's length.</p> <p>See https://valkey-io.github.io/commands/spop/ for more details. To pop a single member, see <code>spop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>The count of the elements to pop from the set.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of popped elements will be returned depending on the set's length. If <code>key</code> does not exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n    {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n&gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n    Set()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def spop_count(self, key: TEncodable, count: int) -&gt; Set[bytes]:\n    \"\"\"\n    Removes and returns up to `count` random members from the set stored at `key`, depending on the set's length.\n\n    See https://valkey-io.github.io/commands/spop/ for more details.\n    To pop a single member, see `spop`.\n\n    Args:\n        key (TEncodable): The key of the set.\n        count (int): The count of the elements to pop from the set.\n\n    Returns:\n        Set[bytes]: A set of popped elements will be returned depending on the set's length.\n            If `key` does not exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n            {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n        &gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n            Set()\n    \"\"\"\n    return cast(\n        Set[bytes], await self._execute_command(RequestType.SPop, [key, str(count)])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.srandmember","title":"<code>srandmember(key)</code>  <code>async</code>","text":"<p>Returns a random element from the set value stored at 'key'.</p> <p>See https://valkey.io/commands/srandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the set member.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random element from the set, or None if 'key' does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.srandmember(b\"my_set\")\n    b\"member1\"  # \"member1\" is a random member of \"my_set\".\n&gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n    None  # \"non_existing_set\" is not an existing key, so None was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random element from the set value stored at 'key'.\n\n    See https://valkey.io/commands/srandmember for more details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the set member.\n\n    Returns:\n        Optional[bytes]: A random element from the set, or None if 'key' does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.srandmember(b\"my_set\")\n            b\"member1\"  # \"member1\" is a random member of \"my_set\".\n        &gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n            None  # \"non_existing_set\" is not an existing key, so None was returned.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.SRandMember, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.srandmember_count","title":"<code>srandmember_count(key, count)</code>  <code>async</code>","text":"<p>Returns one or more random elements from the set value stored at 'key'.</p> <p>See https://valkey.io/commands/srandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of members from the set. If the set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n    [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n&gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n    []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Returns one or more random elements from the set value stored at 'key'.\n\n    See https://valkey.io/commands/srandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[bytes]: A list of members from the set.\n            If the set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n            [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n        &gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n            []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.SRandMember, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.srem","title":"<code>srem(key, members)</code>  <code>async</code>","text":"<p>Remove specified members from the set stored at <code>key</code>. Specified members that are not a member of this set are ignored. See https://valkey.io/commands/srem/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which members will be removed.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to remove from the set stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the set, excluding non-existing members. If <code>key</code> does not exist, it is treated as an empty set and this command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n    2\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srem(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Remove specified members from the set stored at `key`.\n    Specified members that are not a member of this set are ignored.\n    See https://valkey.io/commands/srem/ for details.\n\n    Args:\n        key (TEncodable): The key from which members will be removed.\n        members (List[TEncodable]): A list of members to remove from the set stored at `key`.\n\n    Returns:\n        int: The number of members that were removed from the set, excluding non-existing members.\n            If `key` does not exist, it is treated as an empty set and this command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n            2\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SRem, [key] + members))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sscan","title":"<code>sscan(key, cursor, match=None, count=None)</code>  <code>async</code>","text":"<p>Iterates incrementally over a set.</p> <p>See https://valkey.io/commands/sscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a subset of the set then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the set. <code>COUNT</code> could be ignored until the set is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the set held by <code>key</code>. The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code> returned on the last iteration of the set. The second element is always an <code>Array</code> of the subset of the set held in <code>key</code>.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.sscan--assume-key-contains-a-set-with-130-members","title":"Assume \"key\" contains a set with 130 members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor:  48\nMembers: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\nCursor: 24\nMembers: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\nCursor: 0\nMembers: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a set.\n\n    See https://valkey.io/commands/sscan for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a\n            subset of the set then there could be a case where the result is empty although there are items that\n            match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n            only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the set.\n            `COUNT` could be ignored until the set is large enough for the `SCAN` commands to represent the results\n            as compact single-allocation packed encoding.\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the set held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the set. The second element is always an `Array` of the subset of the\n            set held in `key`.\n\n    Examples:\n        # Assume \"key\" contains a set with 130 members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor:  48\n        Members: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\n        Cursor: 24\n        Members: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\n        Cursor: 0\n        Members: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.SScan, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.strlen","title":"<code>strlen(key)</code>  <code>async</code>","text":"<p>Get the length of the string value stored at <code>key</code>. See https://valkey.io/commands/strlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its length.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the string value stored at <code>key</code>. If <code>key</code> does not exist, it is treated as an empty string and 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n&gt;&gt;&gt; await client.strlen(\"key\")\n    5  # Indicates that the length of the string value stored at `key` is 5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def strlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Get the length of the string value stored at `key`.\n    See https://valkey.io/commands/strlen/ for more details.\n\n    Args:\n        key (TEncodable): The key to return its length.\n\n    Returns:\n        int: The length of the string value stored at `key`.\n            If `key` does not exist, it is treated as an empty string and 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n        &gt;&gt;&gt; await client.strlen(\"key\")\n            5  # Indicates that the length of the string value stored at `key` is 5.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(int, await self._execute_command(RequestType.Strlen, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sunion","title":"<code>sunion(keys)</code>  <code>async</code>","text":"<p>Gets the union of all the given sets.</p> <p>See https://valkey.io/commands/sunion for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of members which are present in at least one of the given sets. If none of the sets exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n    {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n&gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n    {b\"member1\", b\"member2\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sunion(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Gets the union of all the given sets.\n\n    See https://valkey.io/commands/sunion for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets.\n\n    Returns:\n        Set[bytes]: A set of members which are present in at least one of the given sets.\n            If none of the sets exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n            {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n        &gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n            {b\"member1\", b\"member2\"}\n    \"\"\"\n    return cast(Set[bytes], await self._execute_command(RequestType.SUnion, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.sunionstore","title":"<code>sunionstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the members of the union of all given sets specified by <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sunionstore for more details.</p> Note <p>When in cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys from which to retrieve the set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n&gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n    2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sunionstore(\n    self,\n    destination: TEncodable,\n    keys: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Stores the members of the union of all given sets specified by `keys` into a new set at `destination`.\n\n    See https://valkey.io/commands/sunionstore for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n        &gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n            2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SUnionStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.touch","title":"<code>touch(keys)</code>  <code>async</code>","text":"<p>Updates the last access time of specified keys.</p> <p>See https://valkey.io/commands/touch/ for details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys to update last access time.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were updated, a key is ignored if it doesn't exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n&gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n&gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n    2  # Last access time of 2 keys has been updated.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def touch(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Updates the last access time of specified keys.\n\n    See https://valkey.io/commands/touch/ for details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The keys to update last access time.\n\n    Returns:\n        int: The number of keys that were updated, a key is ignored if it doesn't exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n        &gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n        &gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n            2  # Last access time of 2 keys has been updated.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Touch, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.try_get_pubsub_message","title":"<code>try_get_pubsub_message()</code>","text":"<p>Tries to return the next pubsub message. Throws WrongConfiguration in cases: 1. No pubsub subscriptions are configured for the client 2. Callback is configured with the pubsub subsciptions</p> <p>See https://valkey.io/docs/topics/pubsub/ for more details.</p> <p>Returns:</p> Type Description <code>Optional[PubSubMsg]</code> <p>Optional[PubSubMsg]: The next pubsub message or None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>def try_get_pubsub_message(self) -&gt; Optional[PubSubMsg]:\n    \"\"\"\n    Tries to return the next pubsub message.\n    Throws WrongConfiguration in cases:\n    1. No pubsub subscriptions are configured for the client\n    2. Callback is configured with the pubsub subsciptions\n\n    See https://valkey.io/docs/topics/pubsub/ for more details.\n\n    Returns:\n        Optional[PubSubMsg]: The next pubsub message or None\n\n    Examples:\n        &gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.ttl","title":"<code>ttl(key)</code>  <code>async</code>","text":"<p>Returns the remaining time to live of <code>key</code> that has a timeout. See https://valkey.io/commands/ttl/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its timeout.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TTL in seconds, -2 if <code>key</code> does not exist or -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ttl(\"my_key\")\n    3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n&gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n    -2  # Returns -2 for a non-existing key.\n&gt;&gt;&gt; await client.ttl(\"key\")\n    -1  # Indicates that \"key: has no has no associated expire.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def ttl(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the remaining time to live of `key` that has a timeout.\n    See https://valkey.io/commands/ttl/ for more details.\n\n    Args:\n        key (TEncodable): The key to return its timeout.\n\n    Returns:\n        int: TTL in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.ttl(\"my_key\")\n            3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n        &gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n            -2  # Returns -2 for a non-existing key.\n        &gt;&gt;&gt; await client.ttl(\"key\")\n            -1  # Indicates that \"key: has no has no associated expire.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.TTL, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.type","title":"<code>type(key)</code>  <code>async</code>","text":"<p>Returns the bytes string representation of the type of the value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/type/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to check its data type.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>If the key exists, the type of the stored value is returned.</p> <code>bytes</code> <p>Otherwise, a b\"none\" bytes string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.type(\"key\")\n    b'string'\n&gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n&gt;&gt;&gt; await client.type(\"key\")\n    b'list'\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def type(self, key: TEncodable) -&gt; bytes:\n    \"\"\"\n    Returns the bytes string representation of the type of the value stored at `key`.\n\n    See https://valkey.io/commands/type/ for more details.\n\n    Args:\n        key (TEncodable): The key to check its data type.\n\n    Returns:\n        bytes: If the key exists, the type of the stored value is returned.\n        Otherwise, a b\"none\" bytes string is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.type(\"key\")\n            b'string'\n        &gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n        &gt;&gt;&gt; await client.type(\"key\")\n            b'list'\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.Type, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.unlink","title":"<code>unlink(keys)</code>  <code>async</code>","text":"<p>Unlink (delete) multiple keys from the database. A key is ignored if it does not exist. This command, similar to DEL, removes specified keys and ignores non-existent ones. However, this command does not block the server, while DEL does. See https://valkey.io/commands/unlink/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to unlink.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were unlinked.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n    3  # Indicates that all three keys were unlinked from the database.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def unlink(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Unlink (delete) multiple keys from the database.\n    A key is ignored if it does not exist.\n    This command, similar to DEL, removes specified keys and ignores non-existent ones.\n    However, this command does not block the server, while [DEL](https://valkey.io/commands/del) does.\n    See https://valkey.io/commands/unlink/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The list of keys to unlink.\n\n    Returns:\n        int: The number of keys that were unlinked.\n\n    Examples:\n        &gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n            3  # Indicates that all three keys were unlinked from the database.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Unlink, keys))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.watch","title":"<code>watch(keys)</code>  <code>async</code>","text":"<p>Marks the given keys to be watched for conditional execution of a transaction. Transactions will only execute commands if the watched keys are not modified before execution of the transaction.</p> <p>See https://valkey.io/commands/watch for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys to watch.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.watch(\"sampleKey\")\n    'OK'\n&gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n&gt;&gt;&gt; await client.exec(transaction)\n    'OK' # Executes successfully and keys are unwatched.\n</code></pre> <pre><code>&gt;&gt;&gt; await client.watch(\"sampleKey\")\n    'OK'\n&gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n&gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n    'OK'\n&gt;&gt;&gt; await client.exec(transaction)\n    None  # None is returned when the watched key is modified before transaction execution.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def watch(self, keys: List[TEncodable]) -&gt; TOK:\n    \"\"\"\n    Marks the given keys to be watched for conditional execution of a transaction. Transactions\n    will only execute commands if the watched keys are not modified before execution of the\n    transaction.\n\n    See https://valkey.io/commands/watch for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The keys to watch.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.watch(\"sampleKey\")\n            'OK'\n        &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n        &gt;&gt;&gt; await client.exec(transaction)\n            'OK' # Executes successfully and keys are unwatched.\n\n        &gt;&gt;&gt; await client.watch(\"sampleKey\")\n            'OK'\n        &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n        &gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n            'OK'\n        &gt;&gt;&gt; await client.exec(transaction)\n            None  # None is returned when the watched key is modified before transaction execution.\n    \"\"\"\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.Watch, keys),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xack","title":"<code>xack(key, group_name, ids)</code>  <code>async</code>","text":"<p>Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group. This command should be called on pending messages so that such messages do not get processed again by the consumer group.</p> <p>See https://valkey.io/commands/xack for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>The stream entry IDs to acknowledge and consume for the given consumer group.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of messages that were successfully acknowledged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n    {\n        \"mystream\": {\n            \"1-0\": [[\"field1\", \"value1\"]],\n        }\n    }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n&gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n    1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xack(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    ids: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group.\n    This command should be called on pending messages so that such messages do not get processed again by the\n    consumer group.\n\n    See https://valkey.io/commands/xack for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        ids (List[TEncodable]): The stream entry IDs to acknowledge and consume for the given consumer group.\n\n    Returns:\n        int: The number of messages that were successfully acknowledged.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n            {\n                \"mystream\": {\n                    \"1-0\": [[\"field1\", \"value1\"]],\n                }\n            }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n        &gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n            1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n    \"\"\"\n    args: List[TEncodable] = [key, group_name]\n    args.extend(ids)\n    return cast(\n        int,\n        await self._execute_command(RequestType.XAck, [key, group_name] + ids),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xadd","title":"<code>xadd(key, values, options=None)</code>  <code>async</code>","text":"<p>Adds an entry to the specified stream stored at <code>key</code>. If the <code>key</code> doesn't exist, the stream is created.</p> <p>See https://valkey.io/commands/xadd for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>values</code> <code>List[Tuple[TEncodable, TEncodable]]</code> <p>Field-value pairs to be added to the entry.</p> required <code>options</code> <code>Optional[StreamAddOptions]</code> <p>Additional options for adding entries to the stream. Default to None. See <code>StreamAddOptions</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>Optional[bytes]</code> <p>The id of the added entry, or None if <code>options.make_stream</code> is set to False and no stream with the matching <code>key</code> exists.</p> Example <p>await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])     b\"1615957011958-0\"  # Example stream entry ID. await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))     None  # The key doesn't exist, therefore, None is returned. await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))     b\"0-1\"  # Returns the stream id.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xadd(\n    self,\n    key: TEncodable,\n    values: List[Tuple[TEncodable, TEncodable]],\n    options: Optional[StreamAddOptions] = None,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Adds an entry to the specified stream stored at `key`. If the `key` doesn't exist, the stream is created.\n\n    See https://valkey.io/commands/xadd for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        values (List[Tuple[TEncodable, TEncodable]]): Field-value pairs to be added to the entry.\n        options (Optional[StreamAddOptions]): Additional options for adding entries to the stream. Default to None. See `StreamAddOptions`.\n\n    Returns:\n        bytes: The id of the added entry, or None if `options.make_stream` is set to False and no stream with the matching `key` exists.\n\n    Example:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])\n            b\"1615957011958-0\"  # Example stream entry ID.\n        &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))\n            None  # The key doesn't exist, therefore, None is returned.\n        &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))\n            b\"0-1\"  # Returns the stream id.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    if options:\n        args.extend(options.to_args())\n    else:\n        args.append(\"*\")\n    args.extend([field for pair in values for field in pair])\n\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.XAdd, args)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim","title":"<code>xautoclaim(key, group_name, consumer_name, min_idle_time_ms, start, count=None)</code>  <code>async</code>","text":"<p>Transfers ownership of pending stream entries that match the specified criteria.</p> <p>See https://valkey.io/commands/xautoclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>Filters the claimed entries to those that have been idle for more than the specified value.</p> required <code>start</code> <code>TEncodable</code> <p>Filters the claimed entries to those that have an ID equal or greater than the specified value.</p> required <code>count</code> <code>Optional[int]</code> <p>Limits the number of claimed entries to the specified value.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]</code> <p>List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements: - A stream ID to be used as the start argument for the next call to <code>XAUTOCLAIM</code>. This ID is equivalent to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was scanned. - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a 2D list of the field-value pairs in the format <code>[[field1, value1], [field2, value2], ...]</code>. - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are deleted from the Pending Entries List.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim--valkey-version-700","title":"Valkey version &lt; 7.0.0:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [\n        b\"0-0\",\n        {\n            b\"1-1\": [\n                [b\"field1\", b\"value1\"],\n                [b\"field2\", b\"value2\"],\n            ]\n        }\n    ]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned.\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim--valkey-version-700-and-above","title":"Valkey version 7.0.0 and above:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [\n        b\"0-0\",\n        {\n            b\"1-1\": [\n                [b\"field1\", b\"value1\"],\n                [b\"field2\", b\"value2\"],\n            ]\n        },\n        [b\"1-2\"]\n    ]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n    # exists in the stream.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xautoclaim(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    min_idle_time_ms: int,\n    start: TEncodable,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]:\n    \"\"\"\n    Transfers ownership of pending stream entries that match the specified criteria.\n\n    See https://valkey.io/commands/xautoclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name.\n        min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n            value.\n        start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n        count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n    Returns:\n        List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements:\n            - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n            to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n            scanned.\n            - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a\n            2D list of the field-value pairs in the format `[[field1, value1], [field2, value2], ...]`.\n            - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n            message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n            deleted from the Pending Entries List.\n\n    Examples:\n        # Valkey version &lt; 7.0.0:\n        &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [\n                b\"0-0\",\n                {\n                    b\"1-1\": [\n                        [b\"field1\", b\"value1\"],\n                        [b\"field2\", b\"value2\"],\n                    ]\n                }\n            ]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned.\n\n        # Valkey version 7.0.0 and above:\n        &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [\n                b\"0-0\",\n                {\n                    b\"1-1\": [\n                        [b\"field1\", b\"value1\"],\n                        [b\"field2\", b\"value2\"],\n                    ]\n                },\n                [b\"1-2\"]\n            ]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n            # exists in the stream.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [\n        key,\n        group_name,\n        consumer_name,\n        str(min_idle_time_ms),\n        start,\n    ]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]],\n        await self._execute_command(RequestType.XAutoClaim, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim_just_id","title":"<code>xautoclaim_just_id(key, group_name, consumer_name, min_idle_time_ms, start, count=None)</code>  <code>async</code>","text":"<p>Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID argument to further specify that the return value should contain a list of claimed IDs without their field-value info.</p> <p>See https://valkey.io/commands/xautoclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>Filters the claimed entries to those that have been idle for more than the specified value.</p> required <code>start</code> <code>TEncodable</code> <p>Filters the claimed entries to those that have an ID equal or greater than the specified value.</p> required <code>count</code> <code>Optional[int]</code> <p>Limits the number of claimed entries to the specified value.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: A list containing the following elements: - A stream ID to be used as the start argument for the next call to <code>XAUTOCLAIM</code>. This ID is equivalent to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was scanned. - A list of the IDs for the claimed entries. - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are deleted from the Pending Entries List.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim_just_id--valkey-version-700","title":"Valkey version &lt; 7.0.0:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [b\"0-0\", [b\"1-1\"]]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned.\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xautoclaim_just_id--valkey-version-700-and-above","title":"Valkey version 7.0.0 and above:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n    # exists in the stream.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xautoclaim_just_id(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    min_idle_time_ms: int,\n    start: TEncodable,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID\n    argument to further specify that the return value should contain a list of claimed IDs without their\n    field-value info.\n\n    See https://valkey.io/commands/xautoclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name.\n        min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n            value.\n        start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n        count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: A list containing the following elements:\n            - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n            to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n            scanned.\n            - A list of the IDs for the claimed entries.\n            - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n            message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n            deleted from the Pending Entries List.\n\n    Examples:\n        # Valkey version &lt; 7.0.0:\n        &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [b\"0-0\", [b\"1-1\"]]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned.\n\n        # Valkey version 7.0.0 and above:\n        &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n            # exists in the stream.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [\n        key,\n        group_name,\n        consumer_name,\n        str(min_idle_time_ms),\n        start,\n    ]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    args.append(\"JUSTID\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.XAutoClaim, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xclaim","title":"<code>xclaim(key, group, consumer, min_idle_time_ms, ids, options=None)</code>  <code>async</code>","text":"<p>Changes the ownership of a pending message.</p> <p>See https://valkey.io/commands/xclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer</code> <code>TEncodable</code> <p>The group consumer.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>The minimum idle time for the message to be claimed.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>A array of entry ids.</p> required <code>options</code> <code>Optional[StreamClaimOptions]</code> <p>Stream claim options.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, List[List[bytes]]]</code> <p>Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.xclaim--read-messages-from-streamid-for-consumer1","title":"read messages from streamId for consumer1","text":"<pre><code>&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }\n    # \"1-0\" is now read, and we can assign the pending messages to consumer2\n&gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n    {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xclaim(\n    self,\n    key: TEncodable,\n    group: TEncodable,\n    consumer: TEncodable,\n    min_idle_time_ms: int,\n    ids: List[TEncodable],\n    options: Optional[StreamClaimOptions] = None,\n) -&gt; Mapping[bytes, List[List[bytes]]]:\n    \"\"\"\n    Changes the ownership of a pending message.\n\n    See https://valkey.io/commands/xclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group (TEncodable): The consumer group name.\n        consumer (TEncodable): The group consumer.\n        min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n        ids (List[TEncodable]): A array of entry ids.\n        options (Optional[StreamClaimOptions]): Stream claim options.\n\n    Returns:\n        Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format\n            {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.\n\n    Examples:\n        # read messages from streamId for consumer1\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }\n            # \"1-0\" is now read, and we can assign the pending messages to consumer2\n        &gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n            {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n    \"\"\"\n\n    args = [key, group, consumer, str(min_idle_time_ms), *ids]\n\n    if options:\n        args.extend(options.to_args())\n\n    return cast(\n        Mapping[bytes, List[List[bytes]]],\n        await self._execute_command(RequestType.XClaim, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xclaim_just_id","title":"<code>xclaim_just_id(key, group, consumer, min_idle_time_ms, ids, options=None)</code>  <code>async</code>","text":"<p>Changes the ownership of a pending message. This function returns a List with only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.</p> <p>See https://valkey.io/commands/xclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer</code> <code>TEncodable</code> <p>The group consumer.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>The minimum idle time for the message to be claimed.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>A array of entry ids.</p> required <code>options</code> <code>Optional[StreamClaimOptions]</code> <p>Stream claim options.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A List of message ids claimed by the consumer.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.xclaim_just_id--read-messages-from-streamid-for-consumer1","title":"read messages from streamId for consumer1","text":"<pre><code>&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }\n    # \"1-0\" is now read, and we can assign the pending messages to consumer2\n&gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n    [b\"1-0\"]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xclaim_just_id(\n    self,\n    key: TEncodable,\n    group: TEncodable,\n    consumer: TEncodable,\n    min_idle_time_ms: int,\n    ids: List[TEncodable],\n    options: Optional[StreamClaimOptions] = None,\n) -&gt; List[bytes]:\n    \"\"\"\n    Changes the ownership of a pending message. This function returns a List with\n    only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.\n\n    See https://valkey.io/commands/xclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group (TEncodable): The consumer group name.\n        consumer (TEncodable): The group consumer.\n        min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n        ids (List[TEncodable]): A array of entry ids.\n        options (Optional[StreamClaimOptions]): Stream claim options.\n\n    Returns:\n        List[bytes]: A List of message ids claimed by the consumer.\n\n    Examples:\n        # read messages from streamId for consumer1\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }\n            # \"1-0\" is now read, and we can assign the pending messages to consumer2\n        &gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n            [b\"1-0\"]\n    \"\"\"\n\n    args = [\n        key,\n        group,\n        consumer,\n        str(min_idle_time_ms),\n        *ids,\n        StreamClaimOptions.JUST_ID_VALKEY_API,\n    ]\n\n    if options:\n        args.extend(options.to_args())\n\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.XClaim, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xdel","title":"<code>xdel(key, ids)</code>  <code>async</code>","text":"<p>Removes the specified entries by id from a stream, and returns the number of entries deleted.</p> <p>See https://valkey.io/commands/xdel for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>An array of entry ids.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of entries removed from the stream. This number may be less than the number of entries in <code>ids</code>, if the specified <code>ids</code> don't exist in the stream.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n    2  # Stream marked 2 entries as deleted.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xdel(self, key: TEncodable, ids: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Removes the specified entries by id from a stream, and returns the number of entries deleted.\n\n    See https://valkey.io/commands/xdel for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        ids (List[TEncodable]): An array of entry ids.\n\n    Returns:\n        int: The number of entries removed from the stream. This number may be less than the number of entries in\n            `ids`, if the specified `ids` don't exist in the stream.\n\n    Examples:\n        &gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n            2  # Stream marked 2 entries as deleted.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    args.extend(ids)\n    return cast(\n        int,\n        await self._execute_command(RequestType.XDel, [key] + ids),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xgroup_create","title":"<code>xgroup_create(key, group_name, group_id, options=None)</code>  <code>async</code>","text":"<p>Creates a new consumer group uniquely identified by <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-create for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The newly created consumer group name.</p> required <code>group_id</code> <code>TEncodable</code> <p>The stream entry ID that specifies the last delivered entry in the stream from the new group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.</p> required <code>options</code> <code>Optional[StreamGroupOptions]</code> <p>Options for creating the stream group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n    OK\n    # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n    # the most recent entry. The stream was created with length 0 if it did not already exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_create(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    group_id: TEncodable,\n    options: Optional[StreamGroupOptions] = None,\n) -&gt; TOK:\n    \"\"\"\n    Creates a new consumer group uniquely identified by `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-create for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The newly created consumer group name.\n        group_id (TEncodable): The stream entry ID that specifies the last delivered entry in the stream from the new\n            group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.\n        options (Optional[StreamGroupOptions]): Options for creating the stream group.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n            OK\n            # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n            # the most recent entry. The stream was created with length 0 if it did not already exist.\n    \"\"\"\n    args: List[TEncodable] = [key, group_name, group_id]\n    if options is not None:\n        args.extend(options.to_args())\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.XGroupCreate, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xgroup_create_consumer","title":"<code>xgroup_create_consumer(key, group_name, consumer_name)</code>  <code>async</code>","text":"<p>Creates a consumer named <code>consumer_name</code> in the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-createconsumer for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The newly created consumer.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the consumer is created. Otherwise, returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n    True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_create_consumer(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Creates a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-createconsumer for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The newly created consumer.\n\n    Returns:\n        bool: True if the consumer is created. Otherwise, returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n            True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(\n            RequestType.XGroupCreateConsumer, [key, group_name, consumer_name]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xgroup_del_consumer","title":"<code>xgroup_del_consumer(key, group_name, consumer_name)</code>  <code>async</code>","text":"<p>Deletes a consumer named <code>consumer_name</code> in the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-delconsumer for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer to delete.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of pending messages the <code>consumer</code> had before it was deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n    5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_del_consumer(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Deletes a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-delconsumer for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer to delete.\n\n    Returns:\n        int: The number of pending messages the `consumer` had before it was deleted.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n            5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.XGroupDelConsumer, [key, group_name, consumer_name]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xgroup_destroy","title":"<code>xgroup_destroy(key, group_name)</code>  <code>async</code>","text":"<p>Destroys the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-destroy for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the consumer group was destroyed. Otherwise, returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n    True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_destroy(self, key: TEncodable, group_name: TEncodable) -&gt; bool:\n    \"\"\"\n    Destroys the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-destroy for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name to delete.\n\n    Returns:\n        bool: True if the consumer group was destroyed. Otherwise, returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n            True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.XGroupDestroy, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xgroup_set_id","title":"<code>xgroup_set_id(key, group_name, stream_id, entries_read=None)</code>  <code>async</code>","text":"<p>Set the last delivered ID for a consumer group.</p> <p>See https://valkey.io/commands/xgroup-setid for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>stream_id</code> <code>TEncodable</code> <p>The stream entry ID that should be set as the last delivered ID for the consumer group.</p> required <code>entries_read</code> <code>Optional[int]</code> <p>(Optional[int]): A value representing the number of stream entries already read by the group. This option can only be specified if you are using Valkey version 7.0.0 or above.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n    OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_set_id(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    stream_id: TEncodable,\n    entries_read: Optional[int] = None,\n) -&gt; TOK:\n    \"\"\"\n    Set the last delivered ID for a consumer group.\n\n    See https://valkey.io/commands/xgroup-setid for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        stream_id (TEncodable): The stream entry ID that should be set as the last delivered ID for the consumer group.\n        entries_read: (Optional[int]): A value representing the number of stream entries already read by the\n            group. This option can only be specified if you are using Valkey version 7.0.0 or above.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n            OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n    \"\"\"\n    args: List[TEncodable] = [key, group_name, stream_id]\n    if entries_read is not None:\n        args.extend([\"ENTRIESREAD\", str(entries_read)])\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.XGroupSetId, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xinfo_consumers","title":"<code>xinfo_consumers(key, group_name)</code>  <code>async</code>","text":"<p>Returns the list of all consumers and their attributes for the given consumer group of the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-consumers for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <p>Returns:</p> Type Description <code>List[Mapping[bytes, Union[bytes, int]]]</code> <p>List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a consumer for the given consumer group of the stream at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n    [\n        {\n            b\"name\": b\"Alice\",\n            b\"pending\": 1,\n            b\"idle\": 9104628,\n            b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n        },\n        {\n            b\"name\": b\"Bob\",\n            b\"pending\": 1,\n            b\"idle\": 83841983,\n            b\"inactive\": 993841998,\n        }\n    ]\n    # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_consumers(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n) -&gt; List[Mapping[bytes, Union[bytes, int]]]:\n    \"\"\"\n    Returns the list of all consumers and their attributes for the given consumer group of the stream stored at\n    `key`.\n\n    See https://valkey.io/commands/xinfo-consumers for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n\n    Returns:\n        List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a\n            consumer for the given consumer group of the stream at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n            [\n                {\n                    b\"name\": b\"Alice\",\n                    b\"pending\": 1,\n                    b\"idle\": 9104628,\n                    b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n                },\n                {\n                    b\"name\": b\"Bob\",\n                    b\"pending\": 1,\n                    b\"idle\": 83841983,\n                    b\"inactive\": 993841998,\n                }\n            ]\n            # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n    \"\"\"\n    return cast(\n        List[Mapping[bytes, Union[bytes, int]]],\n        await self._execute_command(RequestType.XInfoConsumers, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xinfo_groups","title":"<code>xinfo_groups(key)</code>  <code>async</code>","text":"<p>Returns the list of all consumer groups and their attributes for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-groups for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Type Description <code>List[Mapping[bytes, Union[bytes, int, None]]]</code> <p>List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the attributes of a consumer group for the stream at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n    [\n        {\n            b\"name\": b\"mygroup\",\n            b\"consumers\": 2,\n            b\"pending\": 2,\n            b\"last-delivered-id\": b\"1638126030001-0\",\n            b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n            b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n        },\n        {\n            b\"name\": b\"some-other-group\",\n            b\"consumers\": 1,\n            b\"pending\": 0,\n            b\"last-delivered-id\": b\"1638126028070-0\",\n            b\"entries-read\": 1,\n            b\"lag\": 1,\n        }\n    ]\n    # The list of consumer groups and their attributes for stream \"my_stream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_groups(\n    self,\n    key: TEncodable,\n) -&gt; List[Mapping[bytes, Union[bytes, int, None]]]:\n    \"\"\"\n    Returns the list of all consumer groups and their attributes for the stream stored at `key`.\n\n    See https://valkey.io/commands/xinfo-groups for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the\n            attributes of a consumer group for the stream at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n            [\n                {\n                    b\"name\": b\"mygroup\",\n                    b\"consumers\": 2,\n                    b\"pending\": 2,\n                    b\"last-delivered-id\": b\"1638126030001-0\",\n                    b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n                    b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n                },\n                {\n                    b\"name\": b\"some-other-group\",\n                    b\"consumers\": 1,\n                    b\"pending\": 0,\n                    b\"last-delivered-id\": b\"1638126028070-0\",\n                    b\"entries-read\": 1,\n                    b\"lag\": 1,\n                }\n            ]\n            # The list of consumer groups and their attributes for stream \"my_stream\".\n    \"\"\"\n    return cast(\n        List[Mapping[bytes, Union[bytes, int, None]]],\n        await self._execute_command(RequestType.XInfoGroups, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xinfo_stream","title":"<code>xinfo_stream(key)</code>  <code>async</code>","text":"<p>Returns information about the stream stored at <code>key</code>. To get more detailed information, use <code>xinfo_stream_full</code>.</p> <p>See https://valkey.io/commands/xinfo-stream for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Name Type Description <code>TXInfoStreamResponse</code> <code>TXInfoStreamResponse</code> <p>A mapping of stream information for the given <code>key</code>. See the example for a sample response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n    {\n        b\"length\": 4,\n        b\"radix-tree-keys\": 1L,\n        b\"radix-tree-nodes\": 2L,\n        b\"last-generated-id\": b\"1719877599564-0\",\n        b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n        b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n        b\"groups\": 1L,\n        b\"first-entry\": [\n            b\"1719710679916-0\",\n            [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n        ],\n        b\"last-entry\": [\n            b\"1719877599564-0\",\n            [b\"field1\", b\"value1\"],\n        ],\n    }\n    # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n    # the stream is empty.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_stream(\n    self,\n    key: TEncodable,\n) -&gt; TXInfoStreamResponse:\n    \"\"\"\n    Returns information about the stream stored at `key`. To get more detailed information, use `xinfo_stream_full`.\n\n    See https://valkey.io/commands/xinfo-stream for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        TXInfoStreamResponse: A mapping of stream information for the given `key`. See the example for a sample\n            response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n            {\n                b\"length\": 4,\n                b\"radix-tree-keys\": 1L,\n                b\"radix-tree-nodes\": 2L,\n                b\"last-generated-id\": b\"1719877599564-0\",\n                b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                b\"groups\": 1L,\n                b\"first-entry\": [\n                    b\"1719710679916-0\",\n                    [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                ],\n                b\"last-entry\": [\n                    b\"1719877599564-0\",\n                    [b\"field1\", b\"value1\"],\n                ],\n            }\n            # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n            # the stream is empty.\n    \"\"\"\n    return cast(\n        TXInfoStreamResponse,\n        await self._execute_command(RequestType.XInfoStream, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xinfo_stream_full","title":"<code>xinfo_stream_full(key, count=None)</code>  <code>async</code>","text":"<p>Returns verbose information about the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-stream for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of stream and PEL entries that are returned. A value of <code>0</code> means that all entries will be returned. If not provided, defaults to <code>10</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TXInfoStreamFullResponse</code> <code>TXInfoStreamFullResponse</code> <p>A mapping of detailed stream information for the given <code>key</code>. See the example for a sample response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n    {\n        b\"length\": 4,\n        b\"radix-tree-keys\": 1L,\n        b\"radix-tree-nodes\": 2L,\n        b\"last-generated-id\": b\"1719877599564-0\",\n        b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n        b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries\": [\n            [\n                b\"1719710679916-0\",\n                [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n            ],\n            [\n                b\"1719877599564-0\":\n                [b\"field1\", b\"value1\"],\n            ]\n        ],\n        b\"groups\": [\n            {\n                b\"name\": b\"mygroup\",\n                b\"last-delivered-id\": b\"1719710688676-0\",\n                b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                b\"pel-count\": 2,\n                b\"pending\": [\n                    [\n                        b\"1719710679916-0\",\n                        b\"Alice\",\n                        1719710707260,\n                        1,\n                    ],\n                    [\n                        b\"1719710688676-0\",\n                        b\"Alice\",\n                        1719710718373,\n                        1,\n                    ],\n                ],\n                b\"consumers\": [\n                    {\n                        b\"name\": b\"Alice\",\n                        b\"seen-time\": 1719710718373,\n                        b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                        b\"pel-count\": 2,\n                        b\"pending\": [\n                            [\n                                b\"1719710679916-0\",\n                                1719710707260,\n                                1\n                            ],\n                            [\n                                b\"1719710688676-0\",\n                                1719710718373,\n                                1\n                            ]\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\n    # Detailed stream information for \"my_stream\".\n</code></pre> <p>Since: Valkey version 6.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_stream_full(\n    self,\n    key: TEncodable,\n    count: Optional[int] = None,\n) -&gt; TXInfoStreamFullResponse:\n    \"\"\"\n    Returns verbose information about the stream stored at `key`.\n\n    See https://valkey.io/commands/xinfo-stream for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        count (Optional[int]): The number of stream and PEL entries that are returned. A value of `0` means that all\n            entries will be returned. If not provided, defaults to `10`.\n\n    Returns:\n        TXInfoStreamFullResponse: A mapping of detailed stream information for the given `key`. See the example for\n            a sample response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n            {\n                b\"length\": 4,\n                b\"radix-tree-keys\": 1L,\n                b\"radix-tree-nodes\": 2L,\n                b\"last-generated-id\": b\"1719877599564-0\",\n                b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries\": [\n                    [\n                        b\"1719710679916-0\",\n                        [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                    ],\n                    [\n                        b\"1719877599564-0\":\n                        [b\"field1\", b\"value1\"],\n                    ]\n                ],\n                b\"groups\": [\n                    {\n                        b\"name\": b\"mygroup\",\n                        b\"last-delivered-id\": b\"1719710688676-0\",\n                        b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                        b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                        b\"pel-count\": 2,\n                        b\"pending\": [\n                            [\n                                b\"1719710679916-0\",\n                                b\"Alice\",\n                                1719710707260,\n                                1,\n                            ],\n                            [\n                                b\"1719710688676-0\",\n                                b\"Alice\",\n                                1719710718373,\n                                1,\n                            ],\n                        ],\n                        b\"consumers\": [\n                            {\n                                b\"name\": b\"Alice\",\n                                b\"seen-time\": 1719710718373,\n                                b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                                b\"pel-count\": 2,\n                                b\"pending\": [\n                                    [\n                                        b\"1719710679916-0\",\n                                        1719710707260,\n                                        1\n                                    ],\n                                    [\n                                        b\"1719710688676-0\",\n                                        1719710718373,\n                                        1\n                                    ]\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }\n            # Detailed stream information for \"my_stream\".\n\n    Since: Valkey version 6.0.0.\n    \"\"\"\n    args = [key, \"FULL\"]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        TXInfoStreamFullResponse,\n        await self._execute_command(RequestType.XInfoStream, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xlen","title":"<code>xlen(key)</code>  <code>async</code>","text":"<p>Returns the number of entries in the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xlen for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of entries in the stream. If <code>key</code> does not exist, returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n&gt;&gt;&gt; await client.xlen(\"mystream\")\n    2  # There are 2 entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the number of entries in the stream stored at `key`.\n\n    See https://valkey.io/commands/xlen for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        int: The number of entries in the stream. If `key` does not exist, returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n        &gt;&gt;&gt; await client.xlen(\"mystream\")\n            2  # There are 2 entries in \"mystream\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.XLen, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xpending","title":"<code>xpending(key, group_name)</code>  <code>async</code>","text":"<p>Returns stream message summary information for pending messages for the given consumer group.</p> <p>See https://valkey.io/commands/xpending for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <p>Returns:</p> Type Description <code>List[Union[int, bytes, List[List[bytes]], None]]</code> <p>List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the format <code>[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]</code>, where: - <code>num_group_messages</code>: The total number of pending messages for this consumer group. - <code>start_id</code>: The smallest ID among the pending messages. - <code>end_id</code>: The greatest ID among the pending messages. - <code>[[consumer_name, num_consumer_messages]]</code>: A 2D list of every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</p> <p>If there are no pending messages for the given consumer group, <code>[0, None, None, None]</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n    [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xpending(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n) -&gt; List[Union[int, bytes, List[List[bytes]], None]]:\n    \"\"\"\n    Returns stream message summary information for pending messages for the given consumer group.\n\n    See https://valkey.io/commands/xpending for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n\n    Returns:\n        List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the\n            format `[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]`, where:\n            - `num_group_messages`: The total number of pending messages for this consumer group.\n            - `start_id`: The smallest ID among the pending messages.\n            - `end_id`: The greatest ID among the pending messages.\n            - `[[consumer_name, num_consumer_messages]]`: A 2D list of every consumer in the consumer group with at\n            least one pending message, and the number of pending messages it has.\n\n            If there are no pending messages for the given consumer group, `[0, None, None, None]` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n            [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n    \"\"\"\n    return cast(\n        List[Union[int, bytes, List[List[bytes]], None]],\n        await self._execute_command(RequestType.XPending, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xpending_range","title":"<code>xpending_range(key, group_name, start, end, count, options=None)</code>  <code>async</code>","text":"<p>Returns an extended form of stream message information for pending messages matching a given range of IDs.</p> <p>See https://valkey.io/commands/xpending for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>count</code> <code>int</code> <p>Limits the number of messages returned.</p> required <code>options</code> <code>Optional[StreamPendingOptions]</code> <p>The stream pending options.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[List[Union[bytes, int]]]</code> <p>List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended message information with the format <code>[[id, consumer_name, time_elapsed, num_delivered]]</code>, where: - <code>id</code>: The ID of the message. - <code>consumer_name</code>: The name of the consumer that fetched the message and has still to acknowledge it. We call it the current owner of the message. - <code>time_elapsed</code>: The number of milliseconds that elapsed since the last time this message was delivered to this consumer. - <code>num_delivered</code>: The number of times this message was delivered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n    [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n    # Extended stream entry information for the pending entries associated with \"my_consumer\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xpending_range(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    start: StreamRangeBound,\n    end: StreamRangeBound,\n    count: int,\n    options: Optional[StreamPendingOptions] = None,\n) -&gt; List[List[Union[bytes, int]]]:\n    \"\"\"\n    Returns an extended form of stream message information for pending messages matching a given range of IDs.\n\n    See https://valkey.io/commands/xpending for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        count (int): Limits the number of messages returned.\n        options (Optional[StreamPendingOptions]): The stream pending options.\n\n    Returns:\n        List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended\n            message information with the format `[[id, consumer_name, time_elapsed, num_delivered]]`, where:\n            - `id`: The ID of the message.\n            - `consumer_name`: The name of the consumer that fetched the message and has still to acknowledge it. We\n            call it the current owner of the message.\n            - `time_elapsed`: The number of milliseconds that elapsed since the last time this message was delivered\n            to this consumer.\n            - `num_delivered`: The number of times this message was delivered.\n\n    Examples:\n        &gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n            [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n            # Extended stream entry information for the pending entries associated with \"my_consumer\".\n    \"\"\"\n    args = _create_xpending_range_args(key, group_name, start, end, count, options)\n    return cast(\n        List[List[Union[bytes, int]]],\n        await self._execute_command(RequestType.XPending, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xrange","title":"<code>xrange(key, start, end, count=None)</code>  <code>async</code>","text":"<p>Returns stream entries matching a given range of IDs.</p> <p>See https://valkey.io/commands/xrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>count</code> <code>Optional[int]</code> <p>An optional argument specifying the maximum count of stream entries to return. If <code>count</code> is not provided, all stream entries in the range will be returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[List[bytes]]]]</code> <p>Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the range arguments are not applicable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n    {\n        b\"0-1\": [[b\"field1\", b\"value1\"]],\n        b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n    }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xrange(\n    self,\n    key: TEncodable,\n    start: StreamRangeBound,\n    end: StreamRangeBound,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n    \"\"\"\n    Returns stream entries matching a given range of IDs.\n\n    See https://valkey.io/commands/xrange for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n            If `count` is not provided, all stream entries in the range will be returned.\n\n    Returns:\n        Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n            list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n            arguments are not applicable.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n            {\n                b\"0-1\": [[b\"field1\", b\"value1\"]],\n                b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n            }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n    \"\"\"\n    args: List[TEncodable] = [key, start.to_arg(), end.to_arg()]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[Mapping[bytes, List[List[bytes]]]],\n        await self._execute_command(RequestType.XRange, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xread","title":"<code>xread(keys_and_ids, options=None)</code>  <code>async</code>","text":"<p>Reads entries from the given streams.</p> <p>See https://valkey.io/commands/xread for more details.</p> Note <p>When in cluster mode, all keys in <code>keys_and_ids</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys_and_ids</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A mapping of keys and entry IDs to read from.</p> required <code>options</code> <code>Optional[StreamReadOptions]</code> <p>Options detailing how to read the stream.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]</code> <p>Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs, to a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. None will be returned under the following conditions: - All key-ID pairs in <code>keys_and_ids</code> have either a non-existing key or a non-existing ID, or there are no entries after the given ID. - The <code>BLOCK</code> option is specified and the timeout is hit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n    {\n        b\"mystream\": {\n            b\"0-1\": [[b\"field1\", b\"value1\"]],\n            b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n        }\n    }\n    # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n    # 1000ms if there is no stream data.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xread(\n    self,\n    keys_and_ids: Mapping[TEncodable, TEncodable],\n    options: Optional[StreamReadOptions] = None,\n) -&gt; Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]:\n    \"\"\"\n    Reads entries from the given streams.\n\n    See https://valkey.io/commands/xread for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n    Args:\n        keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of keys and entry IDs to read from.\n        options (Optional[StreamReadOptions]): Options detailing how to read the stream.\n\n    Returns:\n        Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs,\n            to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n            None will be returned under the following conditions:\n            - All key-ID pairs in `keys_and_ids` have either a non-existing key or a non-existing ID, or there are no entries after the given ID.\n            - The `BLOCK` option is specified and the timeout is hit.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n            {\n                b\"mystream\": {\n                    b\"0-1\": [[b\"field1\", b\"value1\"]],\n                    b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                }\n            }\n            # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n            # 1000ms if there is no stream data.\n    \"\"\"\n    args: List[TEncodable] = [] if options is None else options.to_args()\n    args.append(\"STREAMS\")\n    args.extend([key for key in keys_and_ids.keys()])\n    args.extend([value for value in keys_and_ids.values()])\n\n    return cast(\n        Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]],\n        await self._execute_command(RequestType.XRead, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xreadgroup","title":"<code>xreadgroup(keys_and_ids, group_name, consumer_name, options=None)</code>  <code>async</code>","text":"<p>Reads entries from the given streams owned by a consumer group.</p> <p>See https://valkey.io/commands/xreadgroup for more details.</p> Note <p>When in cluster mode, all keys in <code>keys_and_ids</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys_and_ids</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A mapping of stream keys to stream entry IDs to read from. Use the special entry ID of <code>\"&gt;\"</code> to receive only new messages.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name. The consumer will be auto-created if it does not already exist.</p> required <code>options</code> <code>Optional[StreamReadGroupOptions]</code> <p>Options detailing how to read the stream.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]</code> <p>Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of stream IDs, to a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xreadgroup(\n    self,\n    keys_and_ids: Mapping[TEncodable, TEncodable],\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    options: Optional[StreamReadGroupOptions] = None,\n) -&gt; Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]:\n    \"\"\"\n    Reads entries from the given streams owned by a consumer group.\n\n    See https://valkey.io/commands/xreadgroup for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n    Args:\n        keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of stream keys to stream entry IDs to read from.\n            Use the special entry ID of `\"&gt;\"` to receive only new messages.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name. The consumer will be auto-created if it does not already exist.\n        options (Optional[StreamReadGroupOptions]): Options detailing how to read the stream.\n\n    Returns:\n        Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of\n            stream IDs, to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n            Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n    \"\"\"\n    args: List[TEncodable] = [\"GROUP\", group_name, consumer_name]\n    if options is not None:\n        args.extend(options.to_args())\n\n    args.append(\"STREAMS\")\n    args.extend([key for key in keys_and_ids.keys()])\n    args.extend([value for value in keys_and_ids.values()])\n\n    return cast(\n        Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]],\n        await self._execute_command(RequestType.XReadGroup, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xrevrange","title":"<code>xrevrange(key, end, start, count=None)</code>  <code>async</code>","text":"<p>Returns stream entries matching a given range of IDs in reverse order. Equivalent to <code>XRANGE</code> but returns the entries in reverse order.</p> <p>See https://valkey.io/commands/xrevrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>count</code> <code>Optional[int]</code> <p>An optional argument specifying the maximum count of stream entries to return. If <code>count</code> is not provided, all stream entries in the range will be returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[List[bytes]]]]</code> <p>Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the range arguments are not applicable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n    {\n        \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n        \"0-1\": [[\"field1\", \"value1\"]],\n    }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xrevrange(\n    self,\n    key: TEncodable,\n    end: StreamRangeBound,\n    start: StreamRangeBound,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n    \"\"\"\n    Returns stream entries matching a given range of IDs in reverse order. Equivalent to `XRANGE` but returns the\n    entries in reverse order.\n\n    See https://valkey.io/commands/xrevrange for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n            If `count` is not provided, all stream entries in the range will be returned.\n\n    Returns:\n        Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n            list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n            arguments are not applicable.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n            {\n                \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n                \"0-1\": [[\"field1\", \"value1\"]],\n            }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n    \"\"\"\n    args: List[TEncodable] = [key, end.to_arg(), start.to_arg()]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[Mapping[bytes, List[List[bytes]]]],\n        await self._execute_command(RequestType.XRevRange, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.xtrim","title":"<code>xtrim(key, options)</code>  <code>async</code>","text":"<p>Trims the stream stored at <code>key</code> by evicting older entries.</p> <p>See https://valkey.io/commands/xtrim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>options</code> <code>StreamTrimOptions</code> <p>Options detailing how to trim the stream. See <code>StreamTrimOptions</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TThe number of entries deleted from the stream. If <code>key</code> doesn't exist, 0 is returned.</p> Example <p>await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\")) await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))     1 # One entry was deleted from the stream.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xtrim(\n    self,\n    key: TEncodable,\n    options: StreamTrimOptions,\n) -&gt; int:\n    \"\"\"\n    Trims the stream stored at `key` by evicting older entries.\n\n    See https://valkey.io/commands/xtrim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        options (StreamTrimOptions): Options detailing how to trim the stream. See `StreamTrimOptions`.\n\n    Returns:\n        int: TThe number of entries deleted from the stream. If `key` doesn't exist, 0 is returned.\n\n    Example:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))\n            1 # One entry was deleted from the stream.\n    \"\"\"\n    args = [key]\n    if options:\n        args.extend(options.to_args())\n\n    return cast(int, await self._execute_command(RequestType.XTrim, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zadd","title":"<code>zadd(key, members_scores, existing_options=None, update_condition=None, changed=False)</code>  <code>async</code>","text":"<p>Adds members with their scores to the sorted set stored at <code>key</code>. If a member is already a part of the sorted set, its score is updated.</p> <p>See https://valkey.io/commands/zadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members_scores</code> <code>Mapping[TEncodable, float]</code> <p>A mapping of members to their corresponding scores.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling existing members. - NX: Only add new elements. - XX: Only update existing elements.</p> <code>None</code> <code>update_condition</code> <code>Optional[UpdateOptions]</code> <p>Options for updating scores. - GT: Only update scores greater than the current values. - LT: Only update scores less than the current values.</p> <code>None</code> <code>changed</code> <code>bool</code> <p>Modify the return value to return the number of changed elements, instead of the number of new elements added.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements added to the sorted set.</p> <code>int</code> <p>If <code>changed</code> is set, returns the number of elements updated in the sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n    2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n&gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n    2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zadd(\n    self,\n    key: TEncodable,\n    members_scores: Mapping[TEncodable, float],\n    existing_options: Optional[ConditionalChange] = None,\n    update_condition: Optional[UpdateOptions] = None,\n    changed: bool = False,\n) -&gt; int:\n    \"\"\"\n    Adds members with their scores to the sorted set stored at `key`.\n    If a member is already a part of the sorted set, its score is updated.\n\n    See https://valkey.io/commands/zadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members_scores (Mapping[TEncodable, float]): A mapping of members to their corresponding scores.\n        existing_options (Optional[ConditionalChange]): Options for handling existing members.\n            - NX: Only add new elements.\n            - XX: Only update existing elements.\n        update_condition (Optional[UpdateOptions]): Options for updating scores.\n            - GT: Only update scores greater than the current values.\n            - LT: Only update scores less than the current values.\n        changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n    Returns:\n        int: The number of elements added to the sorted set.\n        If `changed` is set, returns the number of elements updated in the sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n            2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n        &gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n            2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if update_condition:\n        args.append(update_condition.value)\n\n    if changed:\n        args.append(\"CH\")\n\n    if existing_options and update_condition:\n        if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n            raise ValueError(\n                \"The GT, LT and NX options are mutually exclusive. \"\n                f\"Cannot choose both {update_condition.value} and NX.\"\n            )\n\n    members_scores_list = [\n        str(item) for pair in members_scores.items() for item in pair[::-1]\n    ]\n    args += members_scores_list\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZAdd, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zadd_incr","title":"<code>zadd_incr(key, member, increment, existing_options=None, update_condition=None)</code>  <code>async</code>","text":"<p>Increments the score of member in the sorted set stored at <code>key</code> by <code>increment</code>. If <code>member</code> does not exist in the sorted set, it is added with <code>increment</code> as its score (as if its previous score was 0.0). If <code>key</code> does not exist, a new sorted set with the specified member as its sole member is created.</p> <p>See https://valkey.io/commands/zadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>A member in the sorted set to increment.</p> required <code>increment</code> <code>float</code> <p>The score to increment the member.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling the member's existence. - NX: Only increment a member that doesn't exist. - XX: Only increment an existing member.</p> <code>None</code> <code>update_condition</code> <code>Optional[UpdateOptions]</code> <p>Options for updating the score. - GT: Only increment the score of the member if the new score will be greater than the current score. - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The score of the member.</p> <code>Optional[float]</code> <p>If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n    5.0\n&gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zadd_incr(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n    increment: float,\n    existing_options: Optional[ConditionalChange] = None,\n    update_condition: Optional[UpdateOptions] = None,\n) -&gt; Optional[float]:\n    \"\"\"\n    Increments the score of member in the sorted set stored at `key` by `increment`.\n    If `member` does not exist in the sorted set, it is added with `increment` as its score (as if its previous score was 0.0).\n    If `key` does not exist, a new sorted set with the specified member as its sole member is created.\n\n    See https://valkey.io/commands/zadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): A member in the sorted set to increment.\n        increment (float): The score to increment the member.\n        existing_options (Optional[ConditionalChange]): Options for handling the member's existence.\n            - NX: Only increment a member that doesn't exist.\n            - XX: Only increment an existing member.\n        update_condition (Optional[UpdateOptions]): Options for updating the score.\n            - GT: Only increment the score of the member if the new score will be greater than the current score.\n            - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.\n\n    Returns:\n        Optional[float]: The score of the member.\n        If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n            5.0\n        &gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n            None\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if update_condition:\n        args.append(update_condition.value)\n\n    args.append(\"INCR\")\n\n    if existing_options and update_condition:\n        if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n            raise ValueError(\n                \"The GT, LT and NX options are mutually exclusive. \"\n                f\"Cannot choose both {update_condition.value} and NX.\"\n            )\n\n    args += [str(increment), member]\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.ZAdd, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zcard","title":"<code>zcard(key)</code>  <code>async</code>","text":"<p>Returns the cardinality (number of elements) of the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zcard/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted set.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n    3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n    0\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zcard(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the cardinality (number of elements) of the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zcard/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n\n    Returns:\n        int: The number of elements in the sorted set.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n            3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n            0\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.ZCard, [key]))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zcount","title":"<code>zcount(key, min_score, max_score)</code>  <code>async</code>","text":"<p>Returns the number of members in the sorted set stored at <code>key</code> with scores between <code>min_score</code> and <code>max_score</code>.</p> <p>See https://valkey.io/commands/zcount/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The minimum score to count from. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <code>max_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The maximum score to count up to. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the specified score range.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <code>int</code> <p>If <code>max_score</code> &lt; <code>min_score</code>, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n    2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n    1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zcount(\n    self,\n    key: TEncodable,\n    min_score: Union[InfBound, ScoreBoundary],\n    max_score: Union[InfBound, ScoreBoundary],\n) -&gt; int:\n    \"\"\"\n    Returns the number of members in the sorted set stored at `key` with scores between `min_score` and `max_score`.\n\n    See https://valkey.io/commands/zcount/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_score (Union[InfBound, ScoreBoundary]): The minimum score to count from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n        max_score (Union[InfBound, ScoreBoundary]): The maximum score to count up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n\n    Returns:\n        int: The number of members in the specified score range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n        If `max_score` &lt; `min_score`, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n            2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n            1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n    \"\"\"\n    score_min = (\n        min_score.value[\"score_arg\"]\n        if type(min_score) == InfBound\n        else min_score.value\n    )\n    score_max = (\n        max_score.value[\"score_arg\"]\n        if type(max_score) == InfBound\n        else max_score.value\n    )\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZCount, [key, score_min, score_max]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zdiff","title":"<code>zdiff(keys)</code>  <code>async</code>","text":"<p>Returns the difference between the first sorted set and all the successive sorted sets. To get the elements with their scores, see <code>zdiff_withscores</code>.</p> <p>When in Cluster mode, all keys must map to the same hash slot.</p> <p>See https://valkey.io/commands/zdiff for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements representing the difference between the sorted sets. If the first key does not exist, it is treated as an empty sorted set, and the command returns an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n&gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n    [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiff(self, keys: List[TEncodable]) -&gt; List[bytes]:\n    \"\"\"\n    Returns the difference between the first sorted set and all the successive sorted sets.\n    To get the elements with their scores, see `zdiff_withscores`.\n\n    When in Cluster mode, all keys must map to the same hash slot.\n\n    See https://valkey.io/commands/zdiff for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: A list of elements representing the difference between the sorted sets.\n            If the first key does not exist, it is treated as an empty sorted set, and the command returns an\n            empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n        &gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n            [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZDiff, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zdiff_withscores","title":"<code>zdiff_withscores(keys)</code>  <code>async</code>","text":"<p>Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores. When in Cluster mode, all keys must map to the same hash slot.</p> <p>See https://valkey.io/commands/zdiff for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted sets. If the first <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n&gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n    {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiff_withscores(self, keys: List[TEncodable]) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores.\n    When in Cluster mode, all keys must map to the same hash slot.\n\n    See https://valkey.io/commands/zdiff for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted\n            sets.\n            If the first `key` does not exist, it is treated as an empty sorted set, and the command returns an\n            empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n        &gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n            {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n    \"\"\"\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(\n            RequestType.ZDiff, [str(len(keys))] + keys + [\"WITHSCORES\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zdiffstore","title":"<code>zdiffstore(destination, keys)</code>  <code>async</code>","text":"<p>Calculates the difference between the first sorted set and all the successive sorted sets at <code>keys</code> and stores the difference as a sorted set to <code>destination</code>, overwriting it if it already exists. Non-existent keys are treated as empty sets. See https://valkey.io/commands/zdiffstore for more details.</p> Note <p>When in Cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key for the resulting sorted set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n    2  # Indicates that two elements have been added to the sorted set at \"key1\".\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n    1  # Indicates that one element has been added to the sorted set at \"key2\".\n&gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n    ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Calculates the difference between the first sorted set and all the successive sorted sets at `keys` and stores\n    the difference as a sorted set to `destination`, overwriting it if it already exists. Non-existent keys are\n    treated as empty sets.\n    See https://valkey.io/commands/zdiffstore for more details.\n\n    Note:\n        When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key for the resulting sorted set.\n        keys (List[TEncodable]): The keys of the sorted sets to compare.\n\n    Returns:\n        int: The number of members in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            2  # Indicates that two elements have been added to the sorted set at \"key1\".\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n            1  # Indicates that one element has been added to the sorted set at \"key2\".\n        &gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n            ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZDiffStore, [destination, str(len(keys))] + keys\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zincrby","title":"<code>zincrby(key, increment, member)</code>  <code>async</code>","text":"<p>Increments the score of <code>member</code> in the sorted set stored at <code>key</code> by <code>increment</code>. If <code>member</code> does not exist in the sorted set, it is added with <code>increment</code> as its score. If <code>key</code> does not exist, a new sorted set is created with the specified member as its sole member.</p> <p>See https://valkey.io/commands/zincrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>increment</code> <code>float</code> <p>The score increment.</p> required <code>member</code> <code>TEncodable</code> <p>A member of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The new score of <code>member</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n    11.7  # The member existed in the set before score was altered, the new score is 11.7.\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n    10.0 # Negative increment, decrements the score.\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n    5.5  # A new member is added to the sorted set with the score being 5.5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zincrby(\n    self, key: TEncodable, increment: float, member: TEncodable\n) -&gt; float:\n    \"\"\"\n    Increments the score of `member` in the sorted set stored at `key` by `increment`.\n    If `member` does not exist in the sorted set, it is added with `increment` as its score.\n    If `key` does not exist, a new sorted set is created with the specified member as its sole member.\n\n    See https://valkey.io/commands/zincrby/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        increment (float): The score increment.\n        member (TEncodable): A member of the sorted set.\n\n    Returns:\n        float: The new score of `member`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n            11.7  # The member existed in the set before score was altered, the new score is 11.7.\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n            10.0 # Negative increment, decrements the score.\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n            5.5  # A new member is added to the sorted set with the score being 5.5.\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(\n            RequestType.ZIncrBy, [key, str(increment), member]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zinter","title":"<code>zinter(keys)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and returns a list of intersecting elements. To get the scores as well, see <code>zinter_withscores</code>. To store the result in a key as a sorted set, see <code>zinterstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinter/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: The resulting array of intersecting elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n    [b'member1']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinter(\n    self,\n    keys: List[TEncodable],\n) -&gt; List[bytes]:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and returns a list of intersecting elements.\n    To get the scores as well, see `zinter_withscores`.\n    To store the result in a key as a sorted set, see `zinterstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinter/ for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: The resulting array of intersecting elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n            [b'member1']\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZInter, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zinter_withscores","title":"<code>zinter_withscores(keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and returns a sorted set of intersecting elements with scores. To get the elements only, see <code>zinter</code>. To store the result in a key as a sorted set, see <code>zinterstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinter/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: The resulting sorted set with scores.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n    {b'member1': 20}  # \"member1\" with score of 20 is the result\n&gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n    {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinter_withscores(\n    self,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and returns a sorted set of intersecting elements with scores.\n    To get the elements only, see `zinter`.\n    To store the result in a key as a sorted set, see `zinterstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinter/ for more details.\n\n    Args:\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        Mapping[bytes, float]: The resulting sorted set with scores.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n            {b'member1': 20}  # \"member1\" with score of 20 is the result\n        &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n            {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n    args.append(\"WITHSCORES\")\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZInter, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zintercard","title":"<code>zintercard(keys, limit=None)</code>  <code>async</code>","text":"<p>Returns the cardinality of the intersection of the sorted sets specified by <code>keys</code>. When provided with the optional <code>limit</code> argument, if the intersection cardinality reaches <code>limit</code> partway through the computation, the algorithm will exit early and yield <code>limit</code> as the cardinality.</p> <p>See https://valkey.io/commands/zintercard for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets to intersect.</p> required <code>limit</code> <code>Optional[int]</code> <p>An optional argument that can be used to specify a maximum number for the intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.</p> <code>None</code> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The cardinality of the intersection of the given sorted sets, or the <code>limit</code> if reached.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n&gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n    2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n&gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n    1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zintercard(\n    self, keys: List[TEncodable], limit: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Returns the cardinality of the intersection of the sorted sets specified by `keys`. When provided with the\n    optional `limit` argument, if the intersection cardinality reaches `limit` partway through the computation, the\n    algorithm will exit early and yield `limit` as the cardinality.\n\n    See https://valkey.io/commands/zintercard for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets to intersect.\n        limit (Optional[int]): An optional argument that can be used to specify a maximum number for the\n            intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Returns:\n        int: The cardinality of the intersection of the given sorted sets, or the `limit` if reached.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n        &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n            2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n        &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n            1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(len(keys))] + keys\n    if limit is not None:\n        args.extend([\"LIMIT\", str(limit)])\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZInterCard, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zinterstore","title":"<code>zinterstore(destination, keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created. To get the result directly, see <code>zinter_withscores</code>.</p> <p>When in cluster mode, <code>destination</code> and all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinterstore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination sorted set.</p> required <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n&gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n    1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinterstore(\n    self,\n    destination: TEncodable,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; int:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n    To get the result directly, see `zinter_withscores`.\n\n    When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinterstore/ for more details.\n\n    Args:\n        destination (TEncodable): The key of the destination sorted set.\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n        &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n            1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZInterStore, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zlexcount","title":"<code>zlexcount(key, min_lex, max_lex)</code>  <code>async</code>","text":"<p>Returns the number of members in the sorted set stored at <code>key</code> with lexicographical values between <code>min_lex</code> and <code>max_lex</code>.</p> <p>See https://valkey.io/commands/zlexcount/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The minimum lexicographical value to count from. Can be an instance of InfBound representing positive/negative infinity, or LexBoundary representing a specific lexicographical value and inclusivity.</p> required <code>max_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The maximum lexicographical to count up to. Can be an instance of InfBound representing positive/negative infinity, or LexBoundary representing a specific lexicographical value and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the specified lexicographical range. If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns <code>0</code>. If <code>max_lex &lt; min_lex</code>, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n    2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n    1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zlexcount(\n    self,\n    key: TEncodable,\n    min_lex: Union[InfBound, LexBoundary],\n    max_lex: Union[InfBound, LexBoundary],\n) -&gt; int:\n    \"\"\"\n    Returns the number of members in the sorted set stored at `key` with lexicographical values between `min_lex` and `max_lex`.\n\n    See https://valkey.io/commands/zlexcount/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_lex (Union[InfBound, LexBoundary]): The minimum lexicographical value to count from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or LexBoundary representing a specific lexicographical value and inclusivity.\n        max_lex (Union[InfBound, LexBoundary]): The maximum lexicographical to count up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or LexBoundary representing a specific lexicographical value and inclusivity.\n\n    Returns:\n        int: The number of members in the specified lexicographical range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n            If `max_lex &lt; min_lex`, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n            2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n            1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n    \"\"\"\n    min_lex_arg = (\n        min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n    )\n    max_lex_arg = (\n        max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZLexCount, [key, min_lex_arg, max_lex_arg]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zmpop","title":"<code>zmpop(keys, filter, count=None)</code>  <code>async</code>","text":"<p>Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order that they are given.</p> <p>The optional <code>count</code> argument can be used to specify the number of elements to pop, and is set to 1 by default.</p> <p>The number of popped elements is the minimum from the sorted set's cardinality and <code>count</code>.</p> <p>See https://valkey.io/commands/zmpop for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>filter</code> <code>ScoreFilter</code> <p>The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop members with the lowest/highest scores accordingly.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of elements to pop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, Mapping[bytes, float]]]]</code> <p>Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from which elements were popped, and a member-score mapping of the popped elements. If no members could be popped, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n&gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n    [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zmpop(\n    self,\n    keys: List[TEncodable],\n    filter: ScoreFilter,\n    count: Optional[int] = None,\n) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n    \"\"\"\n    Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n    that they are given.\n\n    The optional `count` argument can be used to specify the number of elements to pop, and is\n    set to 1 by default.\n\n    The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n    See https://valkey.io/commands/zmpop for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        filter (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n            members with the lowest/highest scores accordingly.\n        count (Optional[int]): The number of elements to pop.\n\n    Returns:\n        Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n            which elements were popped, and a member-score mapping of the popped elements. If no members could be\n            popped, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n        &gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n            [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))] + keys + [filter.value]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[List[Union[bytes, Mapping[bytes, float]]]],\n        await self._execute_command(RequestType.ZMPop, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zmscore","title":"<code>zmscore(key, members)</code>  <code>async</code>","text":"<p>Returns the scores associated with the specified <code>members</code> in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zmscore for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members in the sorted set.</p> required <p>Returns:</p> Type Description <code>List[Optional[float]]</code> <p>List[Optional[float]]: A list of scores corresponding to <code>members</code>. If a member does not exist in the sorted set, the corresponding value in the list will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n    [1.0, None, 3.0]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zmscore(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; List[Optional[float]]:\n    \"\"\"\n    Returns the scores associated with the specified `members` in the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zmscore for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): A list of members in the sorted set.\n\n    Returns:\n        List[Optional[float]]: A list of scores corresponding to `members`.\n            If a member does not exist in the sorted set, the corresponding value in the list will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n            [1.0, None, 3.0]\n    \"\"\"\n    return cast(\n        List[Optional[float]],\n        await self._execute_command(RequestType.ZMScore, [key] + members),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zpopmax","title":"<code>zpopmax(key, count=None)</code>  <code>async</code>","text":"<p>Removes and returns the members with the highest scores from the sorted set stored at <code>key</code>. If <code>count</code> is provided, up to <code>count</code> members with the highest scores are removed and returned. Otherwise, only one member with the highest score is removed and returned.</p> <p>See https://valkey.io/commands/zpopmax for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>Optional[int]</code> <p>Specifies the quantity of members to pop. If not specified, pops one member.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n    {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n&gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n    {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zpopmax(\n    self, key: TEncodable, count: Optional[int] = None\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Removes and returns the members with the highest scores from the sorted set stored at `key`.\n    If `count` is provided, up to `count` members with the highest scores are removed and returned.\n    Otherwise, only one member with the highest score is removed and returned.\n\n    See https://valkey.io/commands/zpopmax for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n        If `count` is higher than the sorted set's cardinality, returns all members and their scores, ordered from highest to lowest.\n\n    Returns:\n        Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.\n        If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n            {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n        &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n            {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n    \"\"\"\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(\n            RequestType.ZPopMax, [key, str(count)] if count else [key]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zpopmin","title":"<code>zpopmin(key, count=None)</code>  <code>async</code>","text":"<p>Removes and returns the members with the lowest scores from the sorted set stored at <code>key</code>. If <code>count</code> is provided, up to <code>count</code> members with the lowest scores are removed and returned. Otherwise, only one member with the lowest score is removed and returned.</p> <p>See https://valkey.io/commands/zpopmin for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>Optional[int]</code> <p>Specifies the quantity of members to pop. If not specified, pops one member.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n    {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n&gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n    {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zpopmin(\n    self, key: TEncodable, count: Optional[int] = None\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Removes and returns the members with the lowest scores from the sorted set stored at `key`.\n    If `count` is provided, up to `count` members with the lowest scores are removed and returned.\n    Otherwise, only one member with the lowest score is removed and returned.\n\n    See https://valkey.io/commands/zpopmin for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n        If `count` is higher than the sorted set's cardinality, returns all members and their scores.\n\n    Returns:\n        Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.\n        If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n            {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n        &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n            {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count)] if count else [key]\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZPopMin, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrandmember","title":"<code>zrandmember(key)</code>  <code>async</code>","text":"<p>Returns a random member from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random member from the sorted set. If the sorted set does not exist or is empty, the response will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n    b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n    None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random member from the sorted set stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n\n    Returns:\n        Optional[bytes]: A random member from the sorted set.\n            If the sorted set does not exist or is empty, the response will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n            b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n            None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.ZRandMember, [key]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrandmember_count","title":"<code>zrandmember_count(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to the absolute value of <code>count</code> random members from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of members from the sorted set. If the sorted set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n    [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n    []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieves up to the absolute value of `count` random members from the sorted set stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[bytes]: A list of members from the sorted set.\n            If the sorted set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n            [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n            []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count)]\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZRandMember, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrandmember_withscores","title":"<code>zrandmember_withscores(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to the absolute value of <code>count</code> random members along with their scores from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[List[Union[bytes, float]]]</code> <p>List[List[Union[bytes, float]]]: A list of <code>[member, score]</code> lists, where <code>member</code> is a random member from the sorted set and <code>score</code> is the associated score. If the sorted set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n    [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n&gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n    []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember_withscores(\n    self, key: TEncodable, count: int\n) -&gt; List[List[Union[bytes, float]]]:\n    \"\"\"\n    Retrieves up to the absolute value of `count` random members along with their scores from the sorted set\n    stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[List[Union[bytes, float]]]: A list of `[member, score]` lists, where `member` is a random member from\n            the sorted set and `score` is the associated score.\n            If the sorted set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n            [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n        &gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n            []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count), \"WITHSCORES\"]\n    return cast(\n        List[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.ZRandMember, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrange","title":"<code>zrange(key, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Returns the specified range of elements in the sorted set stored at <code>key</code>.</p> <p>ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.</p> <p>See https://valkey.io/commands/zrange/ for more details.</p> <p>To get the elements with their scores, see zrange_withscores.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByLex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by lexicographical order, use RangeByLex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements within the specified range.</p> <code>List[bytes]</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n    [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n    [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrange(\n    self,\n    key: TEncodable,\n    range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n    reverse: bool = False,\n) -&gt; List[bytes]:\n    \"\"\"\n    Returns the specified range of elements in the sorted set stored at `key`.\n\n    ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.\n\n    See https://valkey.io/commands/zrange/ for more details.\n\n    To get the elements with their scores, see zrange_withscores.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by lexicographical order, use RangeByLex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        List[bytes]: A list of elements within the specified range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty array.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n            [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n    \"\"\"\n    args = _create_zrange_args(key, range_query, reverse, with_scores=False)\n\n    return cast(List[bytes], await self._execute_command(RequestType.ZRange, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrange_withscores","title":"<code>zrange_withscores(key, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Returns the specified range of elements with their scores in the sorted set stored at <code>key</code>. Similar to ZRANGE but with a WITHSCORE flag.</p> <p>See https://valkey.io/commands/zrange/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes , float]: A map of elements and their scores within the specified range.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n    {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n</code></pre> <p>await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))         {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrange_withscores(\n    self,\n    key: TEncodable,\n    range_query: Union[RangeByIndex, RangeByScore],\n    reverse: bool = False,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Returns the specified range of elements with their scores in the sorted set stored at `key`.\n    Similar to ZRANGE but with a WITHSCORE flag.\n\n    See https://valkey.io/commands/zrange/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        range_query (Union[RangeByIndex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        Mapping[bytes , float]: A map of elements and their scores within the specified range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n            {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n       &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.\n    \"\"\"\n    args = _create_zrange_args(key, range_query, reverse, with_scores=True)\n\n    return cast(\n        Mapping[bytes, float], await self._execute_command(RequestType.ZRange, args)\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrangestore","title":"<code>zrangestore(destination, source, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Stores a specified range of elements from the sorted set at <code>source</code>, into a new sorted set at <code>destination</code>. If <code>destination</code> doesn't exist, a new sorted set is created; if it exists, it's overwritten.</p> <p>ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.</p> <p>See https://valkey.io/commands/zrangestore for more details.</p> Note <p>When in Cluster mode, <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key for the destination sorted set.</p> required <code>source</code> <code>TEncodable</code> <p>The key of the source sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByLex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by lexicographical order, use RangeByLex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n    3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n&gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n    2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrangestore(\n    self,\n    destination: TEncodable,\n    source: TEncodable,\n    range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n    reverse: bool = False,\n) -&gt; int:\n    \"\"\"\n    Stores a specified range of elements from the sorted set at `source`, into a new sorted set at `destination`. If\n    `destination` doesn't exist, a new sorted set is created; if it exists, it's overwritten.\n\n    ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical\n    order.\n\n    See https://valkey.io/commands/zrangestore for more details.\n\n    Note:\n        When in Cluster mode, `source` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key for the destination sorted set.\n        source (TEncodable): The key of the source sorted set.\n        range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by lexicographical order, use RangeByLex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        int: The number of elements in the resulting sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n            3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n        &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n    \"\"\"\n    args = _create_zrange_args(source, range_query, reverse, False, destination)\n\n    return cast(int, await self._execute_command(RequestType.ZRangeStore, args))\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrank","title":"<code>zrank(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code>, with scores ordered from low to high.</p> <p>See https://valkey.io/commands/zrank for more details.</p> <p>To get the rank of <code>member</code> with its score, see <code>zrank_withscore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>Optional[int]</code> <p>Optional[int]: The rank of <code>member</code> in the sorted set.</p> <code>Optional[int]</code> <p>If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, None will be returned.</p> <code>Examples</code> <code>Optional[int]</code> <code>Optional[int]</code> <p>await client.zrank(\"my_sorted_set\", \"member2\") 1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".</p> <code>Optional[int]</code> <p>await client.zrank(\"my_sorted_set\", \"non_existing_member\") None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrank(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; Optional[int]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key`, with scores ordered from low to high.\n\n    See https://valkey.io/commands/zrank for more details.\n\n    To get the rank of `member` with its score, see `zrank_withscore`.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[int]: The rank of `member` in the sorted set.\n        If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n        Examples:\n        &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"member2\")\n            1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"non_existing_member\")\n            None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n    \"\"\"\n    return cast(\n        Optional[int], await self._execute_command(RequestType.ZRank, [key, member])\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrank_withscore","title":"<code>zrank_withscore(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code> with its score, where scores are ordered from the lowest to highest.</p> <p>See https://valkey.io/commands/zrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[int, float]]]</code> <p>Optional[List[Union[int, float]]]: A list containing the rank and score of <code>member</code> in the sorted set.</p> <code>Optional[List[Union[int, float]]]</code> <p>If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n    [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n    None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n</code></pre> <p>Since: Valkey version 7.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrank_withscore(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; Optional[List[Union[int, float]]]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the lowest to highest.\n\n    See https://valkey.io/commands/zrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[List[Union[int, float]]]: A list containing the rank and score of `member` in the sorted set.\n        If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n            [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n            None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n\n    Since: Valkey version 7.2.0.\n    \"\"\"\n    return cast(\n        Optional[List[Union[int, float]]],\n        await self._execute_command(RequestType.ZRank, [key, member, \"WITHSCORE\"]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrem","title":"<code>zrem(key, members)</code>  <code>async</code>","text":"<p>Removes the specified members from the sorted set stored at <code>key</code>. Specified members that are not a member of this set are ignored.</p> <p>See https://valkey.io/commands/zrem/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to remove from the sorted set.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the sorted set, not including non-existing members.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n    2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n&gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrem(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Removes the specified members from the sorted set stored at `key`.\n    Specified members that are not a member of this set are ignored.\n\n    See https://valkey.io/commands/zrem/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): A list of members to remove from the sorted set.\n\n    Returns:\n        int: The number of members that were removed from the sorted set, not including non-existing members.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n            2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n        &gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZRem, [key] + members),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zremrangebylex","title":"<code>zremrangebylex(key, min_lex, max_lex)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with a lexicographical order between <code>min_lex</code> and <code>max_lex</code>.</p> <p>See https://valkey.io/commands/zremrangebylex/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The minimum bound of the lexicographical range. Can be an instance of <code>InfBound</code> representing positive/negative infinity, or <code>LexBoundary</code> representing a specific lex and inclusivity.</p> required <code>max_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The maximum bound of the lexicographical range. Can be an instance of <code>InfBound</code> representing positive/negative infinity, or <code>LexBoundary</code> representing a specific lex and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the sorted set. If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns <code>0</code>. If <code>min_lex</code> is greater than <code>max_lex</code>, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n    4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebylex(\n    self,\n    key: TEncodable,\n    min_lex: Union[InfBound, LexBoundary],\n    max_lex: Union[InfBound, LexBoundary],\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with a lexicographical order between `min_lex` and\n    `max_lex`.\n\n    See https://valkey.io/commands/zremrangebylex/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_lex (Union[InfBound, LexBoundary]): The minimum bound of the lexicographical range.\n            Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n            representing a specific lex and inclusivity.\n        max_lex (Union[InfBound, LexBoundary]): The maximum bound of the lexicographical range.\n            Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n            representing a specific lex and inclusivity.\n\n    Returns:\n        int: The number of members that were removed from the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n            If `min_lex` is greater than `max_lex`, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n            4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    min_lex_arg = (\n        min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n    )\n    max_lex_arg = (\n        max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByLex, [key, min_lex_arg, max_lex_arg]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zremrangebyrank","title":"<code>zremrangebyrank(key, start, end)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with rank between <code>start</code> and <code>end</code>. Both <code>start</code> and <code>end</code> are zero-based indexes with 0 being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.</p> <p>See https://valkey.io/commands/zremrangebyrank/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements that were removed. If <code>start</code> exceeds the end of the sorted set, or if <code>start</code> is greater than <code>end</code>, <code>0</code> is returned. If <code>end</code> exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set. If <code>key</code> does not exist, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n    5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n    0  # Indicates that nothing was removed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebyrank(\n    self,\n    key: TEncodable,\n    start: int,\n    end: int,\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with rank between `start` and `end`.\n    Both `start` and `end` are zero-based indexes with 0 being the element with the lowest score.\n    These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.\n\n    See https://valkey.io/commands/zremrangebyrank/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        int: The number of elements that were removed.\n            If `start` exceeds the end of the sorted set, or if `start` is greater than `end`, `0` is returned.\n            If `end` exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set.\n            If `key` does not exist, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n            5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n            0  # Indicates that nothing was removed.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByRank, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zremrangebyscore","title":"<code>zremrangebyscore(key, min_score, max_score)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with a score between <code>min_score</code> and <code>max_score</code>.</p> <p>See https://valkey.io/commands/zremrangebyscore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The minimum score to remove from. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <code>max_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The maximum score to remove up to. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <p>Returns:     int: The number of members that were removed from the sorted set.     If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.     If <code>min_score</code> is greater than <code>max_score</code>, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n    2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebyscore(\n    self,\n    key: TEncodable,\n    min_score: Union[InfBound, ScoreBoundary],\n    max_score: Union[InfBound, ScoreBoundary],\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with a score between `min_score` and `max_score`.\n\n    See https://valkey.io/commands/zremrangebyscore/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_score (Union[InfBound, ScoreBoundary]): The minimum score to remove from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n        max_score (Union[InfBound, ScoreBoundary]): The maximum score to remove up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n    Returns:\n        int: The number of members that were removed from the sorted set.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n        If `min_score` is greater than `max_score`, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n            2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    score_min = (\n        min_score.value[\"score_arg\"]\n        if type(min_score) == InfBound\n        else min_score.value\n    )\n    score_max = (\n        max_score.value[\"score_arg\"]\n        if type(max_score) == InfBound\n        else max_score.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByScore, [key, score_min, score_max]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrevrank","title":"<code>zrevrank(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code>, where scores are ordered from the highest to lowest, starting from <code>0</code>.</p> <p>To get the rank of <code>member</code> with its score, see <code>zrevrank_withscore</code>.</p> <p>See https://valkey.io/commands/zrevrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The rank of <code>member</code> in the sorted set, where ranks are ordered from high to low based on scores. If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n    2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrevrank(self, key: TEncodable, member: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key`, where scores are ordered from the highest to\n    lowest, starting from `0`.\n\n    To get the rank of `member` with its score, see `zrevrank_withscore`.\n\n    See https://valkey.io/commands/zrevrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[int]: The rank of `member` in the sorted set, where ranks are ordered from high to low based on scores.\n            If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n            2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ZRevRank, [key, member]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zrevrank_withscore","title":"<code>zrevrank_withscore(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code> with its score, where scores are ordered from the highest to lowest, starting from <code>0</code>.</p> <p>See https://valkey.io/commands/zrevrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[int, float]]]</code> <p>Optional[List[Union[int, float]]]: A list containing the rank (as <code>int</code>) and score (as <code>float</code>) of <code>member</code> in the sorted set, where ranks are ordered from high to low based on scores. If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n    [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n</code></pre> <p>Since: Valkey version 7.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrevrank_withscore(\n    self, key: TEncodable, member: TEncodable\n) -&gt; Optional[List[Union[int, float]]]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the\n    highest to lowest, starting from `0`.\n\n    See https://valkey.io/commands/zrevrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[List[Union[int, float]]]: A list containing the rank (as `int`) and score (as `float`) of `member`\n            in the sorted set, where ranks are ordered from high to low based on scores.\n            If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n            [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n\n    Since: Valkey version 7.2.0.\n    \"\"\"\n    return cast(\n        Optional[List[Union[int, float]]],\n        await self._execute_command(\n            RequestType.ZRevRank, [key, member, \"WITHSCORE\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zscan","title":"<code>zscan(key, cursor, match=None, count=None, no_scores=False)</code>  <code>async</code>","text":"<p>Iterates incrementally over a sorted set.</p> <p>See https://valkey.io/commands/zscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return only a subset of the sorted set then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the sorted set. <code>COUNT</code> could be ignored until the sorted set is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <code>no_scores</code> <code>bool</code> <p>If <code>True</code>, the command will not return scores associated with the members. Since Valkey \"8.0.0\".</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the sorted set held by <code>key</code>.</p> <code>List[Union[bytes, List[bytes]]]</code> <p>The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code></p> <code>List[Union[bytes, List[bytes]]]</code> <p>returned on the last iteration of the sorted set. The second element is always an <code>Array</code> of the subset</p> <code>List[Union[bytes, List[bytes]]]</code> <p>of the sorted set held in <code>key</code>. The <code>Array</code> in the second element is a flattened series of</p> <code>List[Union[bytes, List[bytes]]]</code> <p><code>String</code> pairs, where the value is at even indices and the score is at odd indices.</p> <code>List[Union[bytes, List[bytes]]]</code> <p>If <code>no_scores</code> is set to<code>True</code>, the second element will only contain the members without scores.</p> <p>Examples:</p>"},{"location":"python/core/#glide.async_commands.CoreCommands.zscan--assume-key-contains-a-sorted-set-with-multiple-members","title":"Assume \"key\" contains a sorted set with multiple members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 123\nMembers: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\nCursor: 47\nMembers: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\nCursor: 0\nMembers: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zscan--using-no-score","title":"Using no-score","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n...     new_cursor = str(result[0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 123\nMembers: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\nCursor: 47\nMembers: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\nCursor: 0\nMembers: [b'value 55', b'value 24', b'value 90', b'value 113']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    no_scores: bool = False,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a sorted set.\n\n    See https://valkey.io/commands/zscan for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return\n            only a subset of the sorted set then there could be a case where the result is empty although there are\n            items that match the pattern specified. This is due to the default `COUNT` being `10` which indicates\n            that it will only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the\n            sorted set. `COUNT` could be ignored until the sorted set is large enough for the `SCAN` commands to\n            represent the results as compact single-allocation packed encoding.\n        no_scores (bool): If `True`, the command will not return scores associated with the members. Since Valkey \"8.0.0\".\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the sorted set held by `key`.\n        The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n        returned on the last iteration of the sorted set. The second element is always an `Array` of the subset\n        of the sorted set held in `key`. The `Array` in the second element is a flattened series of\n        `String` pairs, where the value is at even indices and the score is at odd indices.\n        If `no_scores` is set to`True`, the second element will only contain the members without scores.\n\n    Examples:\n        # Assume \"key\" contains a sorted set with multiple members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 123\n        Members: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\n        Cursor: 47\n        Members: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\n        Cursor: 0\n        Members: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n\n        # Using no-score\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n        ...     new_cursor = str(result[0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 123\n        Members: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\n        Cursor: 47\n        Members: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\n        Cursor: 0\n        Members: [b'value 55', b'value 24', b'value 90', b'value 113']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n    if no_scores:\n        args.append(\"NOSCORES\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.ZScan, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zscore","title":"<code>zscore(key, member)</code>  <code>async</code>","text":"<p>Returns the score of <code>member</code> in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zscore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose score is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The score of the member.</p> <code>Optional[float]</code> <p>If <code>member</code> does not exist in the sorted set, None is returned.</p> <code>Optional[float]</code> <p>If <code>key</code> does not exist,  None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n    10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n&gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zscore(self, key: TEncodable, member: TEncodable) -&gt; Optional[float]:\n    \"\"\"\n    Returns the score of `member` in the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zscore/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose score is to be retrieved.\n\n    Returns:\n        Optional[float]: The score of the member.\n        If `member` does not exist in the sorted set, None is returned.\n        If `key` does not exist,  None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n            10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n        &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n            None\n    \"\"\"\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.ZScore, [key, member]),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zunion","title":"<code>zunion(keys)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and returns a list of union elements. To get the scores as well, see <code>zunion_withscores</code>. To store the result in a key as a sorted set, see <code>zunionstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunion/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: The resulting array of union elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n    [b'member1', b'member2']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunion(\n    self,\n    keys: List[TEncodable],\n) -&gt; List[bytes]:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and returns a list of union elements.\n    To get the scores as well, see `zunion_withscores`.\n    To store the result in a key as a sorted set, see `zunionstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunion/ for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: The resulting array of union elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n            [b'member1', b'member2']\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZUnion, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zunion_withscores","title":"<code>zunion_withscores(keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and returns a sorted set of union elements with scores. To get the elements only, see <code>zunion</code>. To store the result in a key as a sorted set, see <code>zunionstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunion/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: The resulting sorted set with scores.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n    {b'member1': 20, b'member2': 8.2}\n&gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n    {b'member1': 10.5, b'member2': 8.2}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunion_withscores(\n    self,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and returns a sorted set of union elements with scores.\n    To get the elements only, see `zunion`.\n    To store the result in a key as a sorted set, see `zunionstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunion/ for more details.\n\n    Args:\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        Mapping[bytes, float]: The resulting sorted set with scores.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n            {b'member1': 20, b'member2': 8.2}\n        &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n            {b'member1': 10.5, b'member2': 8.2}\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n    args.append(\"WITHSCORES\")\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZUnion, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.CoreCommands.zunionstore","title":"<code>zunionstore(destination, keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created. To get the result directly, see <code>zunion_withscores</code>.</p> <p>When in cluster mode, <code>destination</code> and all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunionstore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination sorted set.</p> required <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 20, b'member2': 8.2}\n&gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n    2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 10.5, b'member2': 8.2}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunionstore(\n    self,\n    destination: TEncodable,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; int:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n    To get the result directly, see `zunion_withscores`.\n\n    When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunionstore/ for more details.\n\n    Args:\n        destination (TEncodable): The key of the destination sorted set.\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 20, b'member2': 8.2}\n        &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n            2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 10.5, b'member2': 8.2}\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZUnionStore, args),\n    )\n</code></pre>"},{"location":"python/core/#glide.async_commands.core.ExpirySet.__init__","title":"<code>__init__(expiry_type, value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>-</code> <code>expiry_type (ExpiryType</code> <p>The expiry type.</p> required <code>-</code> <code>value (Optional[Union[int, datetime, timedelta]]</code> <p>The value of the expiration type. The type of expiration determines the type of expiration value: - SEC: Union[int, timedelta] - MILLSEC: Union[int, timedelta] - UNIX_SEC: Union[int, datetime] - UNIX_MILLSEC: Union[int, datetime] - KEEP_TTL: Type[None]</p> required Source code in <code>glide/async_commands/core.py</code> <pre><code>def __init__(\n    self,\n    expiry_type: ExpiryType,\n    value: Optional[Union[int, datetime, timedelta]],\n) -&gt; None:\n    \"\"\"\n    Args:\n        - expiry_type (ExpiryType): The expiry type.\n        - value (Optional[Union[int, datetime, timedelta]]): The value of the expiration type. The type of expiration\n            determines the type of expiration value:\n            - SEC: Union[int, timedelta]\n            - MILLSEC: Union[int, timedelta]\n            - UNIX_SEC: Union[int, datetime]\n            - UNIX_MILLSEC: Union[int, datetime]\n            - KEEP_TTL: Type[None]\n    \"\"\"\n    self.set_expiry_type_and_value(expiry_type, value)\n</code></pre>"},{"location":"python/core/#glide.async_commands.core.ExpiryGetEx.__init__","title":"<code>__init__(expiry_type, value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>-</code> <code>expiry_type (ExpiryType</code> <p>The expiry type.</p> required <code>-</code> <code>value (Optional[Union[int, datetime, timedelta]]</code> <p>The value of the expiration type. The type of expiration determines the type of expiration value: - SEC: Union[int, timedelta] - MILLSEC: Union[int, timedelta] - UNIX_SEC: Union[int, datetime] - UNIX_MILLSEC: Union[int, datetime] - PERSIST: Type[None]</p> required Source code in <code>glide/async_commands/core.py</code> <pre><code>def __init__(\n    self,\n    expiry_type: ExpiryTypeGetEx,\n    value: Optional[Union[int, datetime, timedelta]],\n) -&gt; None:\n    \"\"\"\n    Args:\n        - expiry_type (ExpiryType): The expiry type.\n        - value (Optional[Union[int, datetime, timedelta]]): The value of the expiration type. The type of expiration\n            determines the type of expiration value:\n            - SEC: Union[int, timedelta]\n            - MILLSEC: Union[int, timedelta]\n            - UNIX_SEC: Union[int, datetime]\n            - UNIX_MILLSEC: Union[int, datetime]\n            - PERSIST: Type[None]\n    \"\"\"\n    self.set_expiry_type_and_value(expiry_type, value)\n</code></pre>"},{"location":"python/core_commands/","title":"Core commands","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>glide/async_commands/core.py</code> <pre><code>class CoreCommands(Protocol):\n    async def _execute_command(\n        self,\n        request_type: RequestType.ValueType,\n        args: List[TEncodable],\n        route: Optional[Route] = ...,\n    ) -&gt; TResult: ...\n\n    async def _execute_transaction(\n        self,\n        commands: List[Tuple[RequestType.ValueType, List[TEncodable]]],\n        route: Optional[Route] = None,\n    ) -&gt; List[TResult]: ...\n\n    async def _execute_script(\n        self,\n        hash: str,\n        keys: Optional[List[TEncodable]] = None,\n        args: Optional[List[TEncodable]] = None,\n        route: Optional[Route] = None,\n    ) -&gt; TResult: ...\n\n    async def _cluster_scan(\n        self,\n        cursor: ClusterScanCursor,\n        match: Optional[TEncodable] = ...,\n        count: Optional[int] = ...,\n        type: Optional[ObjectType] = ...,\n    ) -&gt; TResult: ...\n\n    async def set(\n        self,\n        key: TEncodable,\n        value: TEncodable,\n        conditional_set: Optional[ConditionalChange] = None,\n        expiry: Optional[ExpirySet] = None,\n        return_old_value: bool = False,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Set the given key with the given value. Return value is dependent on the passed options.\n        See https://valkey.io/commands/set/ for more details.\n\n        Args:\n            key (TEncodable): the key to store.\n            value (TEncodable): the value to store with the given key.\n            conditional_set (Optional[ConditionalChange], optional): set the key only if the given condition is met.\n                Equivalent to [`XX` | `NX`] in the Valkey API. Defaults to None.\n            expiry (Optional[ExpirySet], optional): set expiriation to the given key.\n                Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `KEEPTTL`] in the Valkey API. Defaults to None.\n            return_old_value (bool, optional): Return the old value stored at key, or None if key did not exist.\n                An error is returned and SET aborted if the value stored at key is not a string.\n                Equivalent to `GET` in the Valkey API. Defaults to False.\n\n        Returns:\n            Optional[bytes]:\n                If the value is successfully set, return OK.\n                If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None.\n                If return_old_value is set, return the old value as a bytes string.\n\n        Example:\n            &gt;&gt;&gt; await client.set(b\"key\", b\"value\")\n                'OK'\n            &gt;&gt;&gt; await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))\n                'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds.\n            &gt;&gt;&gt; await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)\n                b'new_value' # Returns the old value of \"key\".\n            &gt;&gt;&gt; await client.get(\"key\")\n                b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.\n        \"\"\"\n        args = [key, value]\n        if conditional_set:\n            args.append(conditional_set.value)\n        if return_old_value:\n            args.append(\"GET\")\n        if expiry is not None:\n            args.extend(expiry.get_cmd_args())\n        return cast(Optional[bytes], await self._execute_command(RequestType.Set, args))\n\n    async def get(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Get the value associated with the given key, or null if no such value exists.\n        See https://valkey.io/commands/get/ for details.\n\n        Args:\n            key (TEncodable): The key to retrieve from the database.\n\n        Returns:\n            Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.\n\n        Example:\n            &gt;&gt;&gt; await client.get(\"key\")\n                b'value'\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(Optional[bytes], await self._execute_command(RequestType.Get, args))\n\n    async def getdel(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Gets a value associated with the given string `key` and deletes the key.\n\n        See https://valkey.io/commands/getdel for more details.\n\n        Args:\n            key (TEncodable): The `key` to retrieve from the database.\n\n        Returns:\n            Optional[bytes]: If `key` exists, returns the `value` of `key`. Otherwise, returns `None`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.getdel(\"key\")\n                b'value'\n            &gt;&gt;&gt; await client.getdel(\"key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.GetDel, [key])\n        )\n\n    async def getrange(self, key: TEncodable, start: int, end: int) -&gt; bytes:\n        \"\"\"\n        Returns the substring of the value stored at `key`, determined by the offsets `start` and `end` (both are inclusive).\n        Negative offsets can be used in order to provide an offset starting from the end of the value.\n        So `-1` means the last character, `-2` the penultimate and so forth.\n\n        If `key` does not exist, an empty byte string is returned. If `start` or `end`\n        are out of range, returns the substring within the valid range of the value.\n\n        See https://valkey.io/commands/getrange/ for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            start (int): The starting offset.\n            end (int): The ending offset.\n\n        Returns:\n            bytes: A substring extracted from the value stored at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n            &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n                b\"This\"\n            &gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n                b\"ing\"  # extracted last 3 characters of a string\n            &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n                b\"This is a string\"\n            &gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n                b\"\"\n        \"\"\"\n        return cast(\n            bytes,\n            await self._execute_command(\n                RequestType.GetRange, [key, str(start), str(end)]\n            ),\n        )\n\n    async def append(self, key: TEncodable, value: TEncodable) -&gt; int:\n        \"\"\"\n        Appends a value to a key.\n        If `key` does not exist it is created and set as an empty string, so `APPEND` will be similar to `SET` in this special case.\n\n        See https://valkey.io/commands/append for more details.\n\n        Args:\n            key (TEncodable): The key to which the value will be appended.\n            value (TEncodable): The value to append.\n\n        Returns:\n            int: The length of the stored value after appending `value`.\n\n        Examples:\n            &gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n                5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n            &gt;&gt;&gt; await client.append(\"key\", \" world\")\n                11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n            &gt;&gt;&gt; await client.get(\"key\")\n                b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Append, [key, value]))\n\n    async def strlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Get the length of the string value stored at `key`.\n        See https://valkey.io/commands/strlen/ for more details.\n\n        Args:\n            key (TEncodable): The key to return its length.\n\n        Returns:\n            int: The length of the string value stored at `key`.\n                If `key` does not exist, it is treated as an empty string and 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n            &gt;&gt;&gt; await client.strlen(\"key\")\n                5  # Indicates that the length of the string value stored at `key` is 5.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(int, await self._execute_command(RequestType.Strlen, args))\n\n    async def rename(self, key: TEncodable, new_key: TEncodable) -&gt; TOK:\n        \"\"\"\n        Renames `key` to `new_key`.\n        If `newkey` already exists it is overwritten.\n        See https://valkey.io/commands/rename/ for more details.\n\n        Note:\n            When in cluster mode, both `key` and `newkey` must map to the same hash slot.\n\n        Args:\n            key (TEncodable) : The key to rename.\n            new_key (TEncodable) : The new name of the key.\n\n        Returns:\n            OK: If the `key` was successfully renamed, return \"OK\". If `key` does not exist, an error is thrown.\n        \"\"\"\n        return cast(\n            TOK, await self._execute_command(RequestType.Rename, [key, new_key])\n        )\n\n    async def renamenx(self, key: TEncodable, new_key: TEncodable) -&gt; bool:\n        \"\"\"\n        Renames `key` to `new_key` if `new_key` does not yet exist.\n\n        See https://valkey.io/commands/renamenx for more details.\n\n        Note:\n            When in cluster mode, both `key` and `new_key` must map to the same hash slot.\n\n        Args:\n            key (TEncodable): The key to rename.\n            new_key (TEncodable): The new key name.\n\n        Returns:\n            bool: True if `key` was renamed to `new_key`, or False if `new_key` already exists.\n\n        Examples:\n            &gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n                True  # \"old_key\" was renamed to \"new_key\"\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.RenameNX, [key, new_key]),\n        )\n\n    async def delete(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Delete one or more keys from the database. A key is ignored if it does not exist.\n        See https://valkey.io/commands/del/ for details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): A list of keys to be deleted from the database.\n\n        Returns:\n            int: The number of keys that were deleted.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.delete([\"key\"])\n                1 # Indicates that the key was successfully deleted.\n            &gt;&gt;&gt; await client.delete([\"key\"])\n                0 # No keys we're deleted since \"key\" doesn't exist.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Del, keys))\n\n    async def incr(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Increments the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n        operation.\n        See https://valkey.io/commands/incr/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n\n        Returns:\n            int: The value of `key` after the increment.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incr(\"key\")\n                11\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Incr, [key]))\n\n    async def incrby(self, key: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Increments the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n        the operation. See https://valkey.io/commands/incrby/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n          amount (int) : The amount to increment.\n\n        Returns:\n            int: The value of key after the increment.\n\n        Example:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incrby(\"key\" , 5)\n                15\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.IncrBy, [key, str(amount)])\n        )\n\n    async def incrbyfloat(self, key: TEncodable, amount: float) -&gt; float:\n        \"\"\"\n        Increment the string representing a floating point number stored at `key` by `amount`.\n        By using a negative increment value, the value stored at the `key` is decremented.\n        If the key does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/incrbyfloat/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n          amount (float) : The amount to increment.\n\n        Returns:\n            float: The value of key after the increment.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n                15.55\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(RequestType.IncrByFloat, [key, str(amount)]),\n        )\n\n    async def setrange(self, key: TEncodable, offset: int, value: TEncodable) -&gt; int:\n        \"\"\"\n        Overwrites part of the string stored at `key`, starting at the specified\n        `offset`, for the entire length of `value`.\n        If the `offset` is larger than the current length of the string at `key`,\n        the string is padded with zero bytes to make `offset` fit. Creates the `key`\n        if it doesn't exist.\n\n        See https://valkey.io/commands/setrange for more details.\n\n        Args:\n            key (TEncodable): The key of the string to update.\n            offset (int): The position in the string where `value` should be written.\n            value (TEncodable): The value written with `offset`.\n\n        Returns:\n            int: The length of the string stored at `key` after it was modified.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n            &gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n                11  # The length of the string stored at `key` after it was modified.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.SetRange, [key, str(offset), value]\n            ),\n        )\n\n    async def mset(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n        \"\"\"\n        Set multiple keys to multiple values in a single atomic operation.\n        See https://valkey.io/commands/mset/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when keys in `key_value_map` map to different hash slots.\n\n        Args:\n            key_value_map (Mapping[TEncodable, TEncodable]): A map of key value pairs.\n\n        Returns:\n            OK: a simple OK response.\n\n        Example:\n            &gt;&gt;&gt; await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})\n                'OK'\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in key_value_map.items():\n            parameters.extend(pair)\n        return cast(TOK, await self._execute_command(RequestType.MSet, parameters))\n\n    async def msetnx(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; bool:\n        \"\"\"\n        Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or\n        more keys already exist, the entire operation fails.\n\n        Note:\n            When in cluster mode, all keys in `key_value_map` must map to the same hash slot.\n\n        See https://valkey.io/commands/msetnx/ for more details.\n\n        Args:\n            key_value_map (Mapping[TEncodable, TEncodable]): A key-value map consisting of keys and their respective values to set.\n\n        Returns:\n            bool: True if all keys were set. False if no key was set.\n\n        Examples:\n            &gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n                True\n            &gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n                False\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in key_value_map.items():\n            parameters.extend(pair)\n        return cast(\n            bool,\n            await self._execute_command(RequestType.MSetNX, parameters),\n        )\n\n    async def mget(self, keys: List[TEncodable]) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Retrieve the values of multiple keys.\n        See https://valkey.io/commands/mget/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): A list of keys to retrieve values for.\n\n        Returns:\n            List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,\n            its corresponding value in the list will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n            &gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n            &gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n                [b'value1' , b'value2']\n        \"\"\"\n        return cast(\n            List[Optional[bytes]], await self._execute_command(RequestType.MGet, keys)\n        )\n\n    async def decr(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Decrement the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n        operation.\n        See https://valkey.io/commands/decr/ for more details.\n\n        Args:\n          key (TEncodable): The key to increment its value.\n\n        Returns:\n            int: The value of key after the decrement.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.decr(\"key\")\n                9\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Decr, [key]))\n\n    async def decrby(self, key: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Decrements the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n        the operation.\n        See https://valkey.io/commands/decrby/ for more details.\n\n        Args:\n          key (TEncodable): The key to decrement its value.\n          amount (int) : The amount to decrement.\n\n        Returns:\n            int: The value of key after the decrement.\n\n        Example:\n            &gt;&gt;&gt; await client.set(\"key\", \"10\")\n            &gt;&gt;&gt; await client.decrby(\"key\" , 5)\n                5\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.DecrBy, [key, str(amount)])\n        )\n\n    async def touch(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Updates the last access time of specified keys.\n\n        See https://valkey.io/commands/touch/ for details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The keys to update last access time.\n\n        Returns:\n            int: The number of keys that were updated, a key is ignored if it doesn't exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n            &gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n            &gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n                2  # Last access time of 2 keys has been updated.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Touch, keys))\n\n    async def hset(\n        self,\n        key: TEncodable,\n        field_value_map: Mapping[TEncodable, TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Sets the specified fields to their respective values in the hash stored at `key`.\n        See https://valkey.io/commands/hset/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field_value_map (Mapping[TEncodable, TEncodable]): A field-value map consisting of fields and their corresponding values\n            to be set in the hash stored at the specified key.\n\n        Returns:\n            int: The number of fields that were added to the hash.\n\n        Example:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})\n                2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".\n        \"\"\"\n        field_value_list: List[TEncodable] = [key]\n        for pair in field_value_map.items():\n            field_value_list.extend(pair)\n        return cast(\n            int,\n            await self._execute_command(RequestType.HSet, field_value_list),\n        )\n\n    async def hget(self, key: TEncodable, field: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Retrieves the value associated with `field` in the hash stored at `key`.\n        See https://valkey.io/commands/hget/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field whose value should be retrieved.\n\n        Returns:\n            Optional[bytes]: The value associated `field` in the hash.\n            Returns None if `field` is not presented in the hash or `key` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n            &gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n                b\"value\"\n            &gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.HGet, [key, field]),\n        )\n\n    async def hsetnx(\n        self,\n        key: TEncodable,\n        field: TEncodable,\n        value: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Sets `field` in the hash stored at `key` to `value`, only if `field` does not yet exist.\n        If `key` does not exist, a new key holding a hash is created.\n        If `field` already exists, this operation has no effect.\n        See https://valkey.io/commands/hsetnx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field to set the value for.\n            value (TEncodable): The value to set.\n\n        Returns:\n            bool: True if the field was set, False if the field already existed and was not set.\n\n        Examples:\n            &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n                True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n            &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n                False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.HSetNX, [key, field, value]),\n        )\n\n    async def hincrby(self, key: TEncodable, field: TEncodable, amount: int) -&gt; int:\n        \"\"\"\n        Increment or decrement the value of a `field` in the hash stored at `key` by the specified amount.\n        By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n        If `field` or `key` does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/hincrby/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n            amount (int): The amount by which to increment or decrement the field's value.\n                Use a negative value to decrement.\n\n        Returns:\n            int: The value of the specified field in the hash stored at `key` after the increment or decrement.\n\n        Examples:\n            &gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n                5\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.HIncrBy, [key, field, str(amount)]),\n        )\n\n    async def hincrbyfloat(\n        self, key: TEncodable, field: TEncodable, amount: float\n    ) -&gt; float:\n        \"\"\"\n        Increment or decrement the floating-point value stored at `field` in the hash stored at `key` by the specified\n        amount.\n        By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n        If `field` or `key` does not exist, it is set to 0 before performing the operation.\n        See https://valkey.io/commands/hincrbyfloat/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n            amount (float): The amount by which to increment or decrement the field's value.\n                Use a negative value to decrement.\n\n        Returns:\n            float: The value of the specified field in the hash stored at `key` after the increment as a string.\n\n        Examples:\n            &gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n                \"2.5\"\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(\n                RequestType.HIncrByFloat, [key, field, str(amount)]\n            ),\n        )\n\n    async def hexists(self, key: TEncodable, field: TEncodable) -&gt; bool:\n        \"\"\"\n        Check if a field exists in the hash stored at `key`.\n        See https://valkey.io/commands/hexists/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field to check in the hash stored at `key`.\n\n        Returns:\n            bool: Returns 'True' if the hash contains the specified field. If the hash does not contain the field,\n                or if the key does not exist, it returns 'False'.\n\n        Examples:\n            &gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n                True\n            &gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n                False\n        \"\"\"\n        return cast(\n            bool, await self._execute_command(RequestType.HExists, [key, field])\n        )\n\n    async def hgetall(self, key: TEncodable) -&gt; Dict[bytes, bytes]:\n        \"\"\"\n        Returns all fields and values of the hash stored at `key`.\n        See https://valkey.io/commands/hgetall/ for details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by\n            its value.\n            If `key` does not exist, it returns an empty dictionary.\n\n        Examples:\n            &gt;&gt;&gt; await client.hgetall(\"my_hash\")\n                {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n        \"\"\"\n        return cast(\n            Dict[bytes, bytes], await self._execute_command(RequestType.HGetAll, [key])\n        )\n\n    async def hmget(\n        self, key: TEncodable, fields: List[TEncodable]\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Retrieve the values associated with specified fields in the hash stored at `key`.\n        See https://valkey.io/commands/hmget/ for details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            fields (List[TEncodable]): The list of fields in the hash stored at `key` to retrieve from the database.\n\n        Returns:\n            List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.\n            For every field that does not exist in the hash, a null value is returned.\n            If `key` does not exist, it is treated as an empty hash, and the function returns a list of null values.\n\n        Examples:\n            &gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n                [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n        \"\"\"\n        return cast(\n            List[Optional[bytes]],\n            await self._execute_command(RequestType.HMGet, [key] + fields),\n        )\n\n    async def hdel(self, key: TEncodable, fields: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Remove specified fields from the hash stored at `key`.\n        See https://valkey.io/commands/hdel/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            fields (List[TEncodable]): The list of fields to remove from the hash stored at `key`.\n\n        Returns:\n            int: The number of fields that were removed from the hash, excluding specified but non-existing fields.\n            If `key` does not exist, it is treated as an empty hash, and the function returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n                2  # Indicates that two fields were successfully removed from the hash.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.HDel, [key] + fields))\n\n    async def hlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the number of fields contained in the hash stored at `key`.\n\n        See https://valkey.io/commands/hlen/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            int: The number of fields in the hash, or 0 when the key does not exist.\n            If `key` holds a value that is not a hash, an error is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.hlen(\"my_hash\")\n                3\n            &gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n                0\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.HLen, [key]))\n\n    async def hvals(self, key: TEncodable) -&gt; List[bytes]:\n        \"\"\"\n        Returns all values in the hash stored at `key`.\n\n        See https://valkey.io/commands/hvals/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            List[bytes]: A list of values in the hash, or an empty list when the key does not exist.\n\n        Examples:\n           &gt;&gt;&gt; await client.hvals(\"my_hash\")\n               [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(List[bytes], await self._execute_command(RequestType.HVals, [key]))\n\n    async def hkeys(self, key: TEncodable) -&gt; List[bytes]:\n        \"\"\"\n        Returns all field names in the hash stored at `key`.\n\n        See https://valkey.io/commands/hkeys/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hkeys(\"my_hash\")\n                [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(List[bytes], await self._execute_command(RequestType.HKeys, [key]))\n\n    async def hrandfield(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random field name from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n\n        Returns:\n            Optional[bytes]: A random field name from the hash stored at `key`.\n            If the hash does not exist or is empty, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n                b\"field1\"  # A random field name stored in the hash \"my_hash\".\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.HRandField, [key])\n        )\n\n    async def hrandfield_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieves up to `count` random field names from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            count (int): The number of field names to return.\n                If `count` is positive, returns unique elements.\n                If `count` is negative, allows for duplicates elements.\n\n        Returns:\n            List[bytes]: A list of random field names from the hash.\n            If the hash does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n                [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n            &gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n                []  # Empty list\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.HRandField, [key, str(count)]),\n        )\n\n    async def hrandfield_withvalues(\n        self, key: TEncodable, count: int\n    ) -&gt; List[List[bytes]]:\n        \"\"\"\n        Retrieves up to `count` random field names along with their values from the hash value stored at `key`.\n\n        See https://valkey.io/commands/hrandfield for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            count (int): The number of field names to return.\n                If `count` is positive, returns unique elements.\n                If `count` is negative, allows for duplicates elements.\n\n        Returns:\n            List[List[bytes]]: A list of `[field_name, value]` lists, where `field_name` is a random field name from the\n            hash and `value` is the associated value of the field name.\n            If the hash does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n                [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n        \"\"\"\n        return cast(\n            List[List[bytes]],\n            await self._execute_command(\n                RequestType.HRandField, [key, str(count), \"WITHVALUES\"]\n            ),\n        )\n\n    async def hstrlen(self, key: TEncodable, field: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the string length of the value associated with `field` in the hash stored at `key`.\n\n        See https://valkey.io/commands/hstrlen/ for more details.\n\n        Args:\n            key (TEncodable): The key of the hash.\n            field (TEncodable): The field in the hash.\n\n        Returns:\n            int: The string length or 0 if `field` or `key` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n            &gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n                5\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.HStrlen, [key, field]),\n        )\n\n    async def lpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Insert all the specified values at the head of the list stored at `key`.\n        `elements` are inserted one after the other to the head of the list, from the leftmost element\n        to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n        See https://valkey.io/commands/lpush/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operations.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n                3 # Indicates that the new length of the list is 3 after the push operation.\n            &gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n                1\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.LPush, [key] + elements)\n        )\n\n    async def lpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the head of the list stored at `key`, only if `key` exists and holds a list.\n        If `key` is not a list, this performs no operation.\n\n        See https://valkey.io/commands/lpushx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operation.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n                3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n            &gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n                0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.LPushX, [key] + elements)\n        )\n\n    async def lpop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Remove and return the first elements of the list stored at `key`.\n        The command pops a single element from the beginning of the list.\n        See https://valkey.io/commands/lpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            Optional[bytes]: The value of the first element.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpop(\"my_list\")\n                b\"value1\"\n            &gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.LPop, [key]),\n        )\n\n    async def lpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Remove and return up to `count` elements from the list stored at `key`, depending on the list's length.\n        See https://valkey.io/commands/lpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of elements to pop from the list.\n\n        Returns:\n            Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n                [b\"value1\", b\"value2\"]\n            &gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n                None\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.LPop, [key, str(count)]),\n        )\n\n    async def blpop(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Pops an element from the head of the first list that is non-empty, with the given keys being checked in the\n        order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n        See https://valkey.io/commands/blpop for details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BLPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the lists to pop from.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n                popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n                [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.BLPop, keys + [str(timeout)]),\n        )\n\n    async def lmpop(\n        self,\n        keys: List[TEncodable],\n        direction: ListDirection,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n        \"\"\"\n        Pops one or more elements from the first non-empty list from the provided `keys`.\n\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/lmpop/ for details.\n\n        Args:\n            keys (List[TEncodable]): An array of keys of lists.\n            direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n        Returns:\n            Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n            &gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n               {b\"testKey\": [b\"three\", b\"two\"]}\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(len(keys)), *keys, direction.value]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[Mapping[bytes, List[bytes]]],\n            await self._execute_command(RequestType.LMPop, args),\n        )\n\n    async def blmpop(\n        self,\n        keys: List[TEncodable],\n        direction: ListDirection,\n        timeout: float,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n        \"\"\"\n        Blocks the connection until it pops one or more elements from the first non-empty list from the provided `keys`.\n\n        `BLMPOP` is the blocking variant of `LMPOP`.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BLMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/blmpop/ for details.\n\n        Args:\n            keys (List[TEncodable]): An array of keys of lists.\n            direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n            count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n        Returns:\n            Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n            &gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n               {b\"testKey\": [b\"three\", b\"two\"]}\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(timeout), str(len(keys)), *keys, direction.value]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[Mapping[bytes, List[bytes]]],\n            await self._execute_command(RequestType.BLMPop, args),\n        )\n\n    async def lrange(self, key: TEncodable, start: int, end: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieve the specified elements of the list stored at `key` within the given range.\n        The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n        element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list,\n        with -1 being the last element of the list, -2 being the penultimate, and so on.\n        See https://valkey.io/commands/lrange/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            List[bytes]: A list of elements within the specified range.\n            If `start` exceeds the `end` of the list, or if `start` is greater than `end`, an empty list will be returned.\n            If `end` exceeds the actual end of the list, the range will stop at the actual end of the list.\n            If `key` does not exist an empty list will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n                [b\"value1\", b\"value2\", b\"value3\"]\n            &gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n                [b\"value2\", b\"value3\"]\n            &gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n                []\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(\n                RequestType.LRange, [key, str(start), str(end)]\n            ),\n        )\n\n    async def lindex(\n        self,\n        key: TEncodable,\n        index: int,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns the element at `index` in the list stored at `key`.\n\n        The index is zero-based, so 0 means the first element, 1 the second element and so on.\n        Negative indices can be used to designate elements starting at the tail of the list.\n        Here, -1 means the last element, -2 means the penultimate and so forth.\n\n        See https://valkey.io/commands/lindex/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            index (int): The index of the element in the list to retrieve.\n\n        Returns:\n            Optional[bytes]: The element at `index` in the list stored at `key`.\n                If `index` is out of range or if `key` does not exist, None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n                b'value1'  # Returns the first element in the list stored at 'my_list'.\n            &gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n                b'value3'  # Returns the last element in the list stored at 'my_list'.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.LIndex, [key, str(index)]),\n        )\n\n    async def lset(self, key: TEncodable, index: int, element: TEncodable) -&gt; TOK:\n        \"\"\"\n        Sets the list element at `index` to `element`.\n\n        The index is zero-based, so `0` means the first element, `1` the second element and so on.\n        Negative indices can be used to designate elements starting at the tail of the list.\n        Here, `-1` means the last element, `-2` means the penultimate and so forth.\n\n        See https://valkey.io/commands/lset/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            index (int): The index of the element in the list to be set.\n            element (TEncodable): The new element to set at the specified index.\n\n        Returns:\n            TOK: A simple `OK` response.\n\n        Examples:\n            &gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n                OK\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.LSet, [key, str(index), element]),\n        )\n\n    async def rpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the tail of the list stored at `key`.\n        `elements` are inserted one after the other to the tail of the list, from the leftmost element\n        to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n        See https://valkey.io/commands/rpush/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operations.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n                3 # Indicates that the new length of the list is 3 after the push operation.\n            &gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n                1\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.RPush, [key] + elements)\n        )\n\n    async def rpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Inserts all the specified values at the tail of the list stored at `key`, only if `key` exists and holds a list.\n        If `key` is not a list, this performs no operation.\n\n        See https://valkey.io/commands/rpushx/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n        Returns:\n            int: The length of the list after the push operation.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n                3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n            &gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n                0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.RPushX, [key] + elements)\n        )\n\n    async def rpop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Removes and returns the last elements of the list stored at `key`.\n        The command pops a single element from the end of the list.\n        See https://valkey.io/commands/rpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            Optional[bytes]: The value of the last element.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpop(\"my_list\")\n                b\"value1\"\n            &gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.RPop, [key]),\n        )\n\n    async def rpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Removes and returns up to `count` elements from the list stored at `key`, depending on the list's length.\n        See https://valkey.io/commands/rpop/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of elements to pop from the list.\n\n        Returns:\n            Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n                [b\"value1\", b\"value2\"]\n            &gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n                None\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.RPop, [key, str(count)]),\n        )\n\n    async def brpop(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[bytes]]:\n        \"\"\"\n        Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the\n        order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n        See https://valkey.io/commands/brpop for details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BRPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the lists to pop from.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n                popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n                [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n        \"\"\"\n        return cast(\n            Optional[List[bytes]],\n            await self._execute_command(RequestType.BRPop, keys + [str(timeout)]),\n        )\n\n    async def linsert(\n        self,\n        key: TEncodable,\n        position: InsertPosition,\n        pivot: TEncodable,\n        element: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Inserts `element` in the list at `key` either before or after the `pivot`.\n\n        See https://valkey.io/commands/linsert/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            position (InsertPosition): The relative position to insert into - either `InsertPosition.BEFORE` or\n                `InsertPosition.AFTER` the `pivot`.\n            pivot (TEncodable): An element of the list.\n            element (TEncodable): The new element to insert.\n\n        Returns:\n            int: The list length after a successful insert operation.\n                If the `key` doesn't exist returns `-1`.\n                If the `pivot` wasn't found, returns `0`.\n\n        Examples:\n            &gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n                3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.LInsert, [key, position.value, pivot, element]\n            ),\n        )\n\n    async def lmove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        where_from: ListDirection,\n        where_to: ListDirection,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Atomically pops and removes the left/right-most element to the list stored at `source`\n        depending on `where_from`, and pushes the element at the first/last element of the list\n        stored at `destination` depending on `where_to`.\n\n        When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n        See https://valkey.io/commands/lmove/ for details.\n\n        Args:\n            source (TEncodable): The key to the source list.\n            destination (TEncodable): The key to the destination list.\n            where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n\n        Returns:\n            Optional[bytes]: The popped element, or None if `source` does not exist.\n\n        Examples:\n            &gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n            &gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n            &gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n                b\"one\"\n            &gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n                [b\"two\"]\n            &gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n                [b\"one\", b\"three\", b\"four\"]\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(\n                RequestType.LMove,\n                [source, destination, where_from.value, where_to.value],\n            ),\n        )\n\n    async def blmove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        where_from: ListDirection,\n        where_to: ListDirection,\n        timeout: float,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Blocks the connection until it pops atomically and removes the left/right-most element to the\n        list stored at `source` depending on `where_from`, and pushes the element at the first/last element\n        of the list stored at `destination` depending on `where_to`.\n        `BLMOVE` is the blocking variant of `LMOVE`.\n\n        Notes:\n            1. When in cluster mode, both `source` and `destination` must map to the same hash slot.\n            2. `BLMOVE` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/blmove/ for details.\n\n        Args:\n            source (TEncodable): The key to the source list.\n            destination (TEncodable): The key to the destination list.\n            where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n\n        Returns:\n            Optional[bytes]: The popped element, or None if `source` does not exist or if the operation timed-out.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n            &gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n            &gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n                b\"one\"\n            &gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n                [b\"two\"]\n            &gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n                [b\"one\", b\"three\", bb\"four\"]\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(\n                RequestType.BLMove,\n                [source, destination, where_from.value, where_to.value, str(timeout)],\n            ),\n        )\n\n    async def sadd(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Add specified members to the set stored at `key`.\n        Specified members that are already a member of this set are ignored.\n        If `key` does not exist, a new set is created before adding `members`.\n        See https://valkey.io/commands/sadd/ for more details.\n\n        Args:\n            key (TEncodable): The key where members will be added to its set.\n            members (List[TEncodable]): A list of members to add to the set stored at `key`.\n\n        Returns:\n            int: The number of members that were added to the set, excluding members already present.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n                2\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SAdd, [key] + members))\n\n    async def srem(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Remove specified members from the set stored at `key`.\n        Specified members that are not a member of this set are ignored.\n        See https://valkey.io/commands/srem/ for details.\n\n        Args:\n            key (TEncodable): The key from which members will be removed.\n            members (List[TEncodable]): A list of members to remove from the set stored at `key`.\n\n        Returns:\n            int: The number of members that were removed from the set, excluding non-existing members.\n                If `key` does not exist, it is treated as an empty set and this command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n                2\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SRem, [key] + members))\n\n    async def smembers(self, key: TEncodable) -&gt; Set[bytes]:\n        \"\"\"\n        Retrieve all the members of the set value stored at `key`.\n        See https://valkey.io/commands/smembers/ for details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the set members.\n\n        Returns:\n            Set[bytes]: A set of all members of the set.\n                If `key` does not exist an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.smembers(\"my_set\")\n                {b\"member1\", b\"member2\", b\"member3\"}\n        \"\"\"\n        return cast(\n            Set[bytes], await self._execute_command(RequestType.SMembers, [key])\n        )\n\n    async def scard(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Retrieve the set cardinality (number of elements) of the set stored at `key`.\n        See https://valkey.io/commands/scard/ for details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the number of set members.\n\n        Returns:\n            int: The cardinality (number of elements) of the set, or 0 if the key does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.scard(\"my_set\")\n                3\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.SCard, [key]))\n\n    async def spop(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Removes and returns one random member from the set stored at `key`.\n\n        See https://valkey-io.github.io/commands/spop/ for more details.\n        To pop multiple members, see `spop_count`.\n\n        Args:\n            key (TEncodable): The key of the set.\n\n        Returns:\n            Optional[bytes]: The value of the popped member.\n            If `key` does not exist, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.spop(\"my_set\")\n                b\"value1\" # Removes and returns a random member from the set \"my_set\".\n            &gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n                None\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.SPop, [key])\n        )\n\n    async def spop_count(self, key: TEncodable, count: int) -&gt; Set[bytes]:\n        \"\"\"\n        Removes and returns up to `count` random members from the set stored at `key`, depending on the set's length.\n\n        See https://valkey-io.github.io/commands/spop/ for more details.\n        To pop a single member, see `spop`.\n\n        Args:\n            key (TEncodable): The key of the set.\n            count (int): The count of the elements to pop from the set.\n\n        Returns:\n            Set[bytes]: A set of popped elements will be returned depending on the set's length.\n                If `key` does not exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n                {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n            &gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n                Set()\n        \"\"\"\n        return cast(\n            Set[bytes], await self._execute_command(RequestType.SPop, [key, str(count)])\n        )\n\n    async def sismember(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Returns if `member` is a member of the set stored at `key`.\n\n        See https://valkey.io/commands/sismember/ for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            member (TEncodable): The member to check for existence in the set.\n\n        Returns:\n            bool: True if the member exists in the set, False otherwise.\n            If `key` doesn't exist, it is treated as an empty set and the command returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n                True  # Indicates that \"member1\" exists in the set \"my_set\".\n            &gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n                False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.SIsMember, [key, member]),\n        )\n\n    async def smove(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        member: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Moves `member` from the set at `source` to the set at `destination`, removing it from the source set. Creates a\n        new destination set if needed. The operation is atomic.\n\n        See https://valkey.io/commands/smove for more details.\n\n        Note:\n            When in cluster mode, `source` and `destination` must map to the same hash slot.\n\n        Args:\n            source (TEncodable): The key of the set to remove the element from.\n            destination (TEncodable): The key of the set to add the element to.\n            member (TEncodable): The set element to move.\n\n        Returns:\n            bool: True on success, or False if the `source` set does not exist or the element is not a member of the source set.\n\n        Examples:\n            &gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n                True  # \"member1\" was moved from \"set1\" to \"set2\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(\n                RequestType.SMove, [source, destination, member]\n            ),\n        )\n\n    async def sunion(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Gets the union of all the given sets.\n\n        See https://valkey.io/commands/sunion for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets.\n\n        Returns:\n            Set[bytes]: A set of members which are present in at least one of the given sets.\n                If none of the sets exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n                {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n            &gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n                {b\"member1\", b\"member2\"}\n        \"\"\"\n        return cast(Set[bytes], await self._execute_command(RequestType.SUnion, keys))\n\n    async def sunionstore(\n        self,\n        destination: TEncodable,\n        keys: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Stores the members of the union of all given sets specified by `keys` into a new set at `destination`.\n\n        See https://valkey.io/commands/sunionstore for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n            &gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n                2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SUnionStore, [destination] + keys),\n        )\n\n    async def sdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Stores the difference between the first set and all the successive sets in `keys` into a new set at\n        `destination`.\n\n        See https://valkey.io/commands/sdiffstore for more details.\n\n        Note:\n            When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys of the sets to diff.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n            &gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n                1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SDiffStore, [destination] + keys),\n        )\n\n    async def sinter(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Gets the intersection of all the given sets.\n\n        See https://valkey.io/commands/sinter for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets.\n\n        Returns:\n            Set[bytes]: A set of members which are present in all given sets.\n                If one or more sets do no exist, an empty set will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n                 {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n            &gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n                None\n        \"\"\"\n        return cast(Set[bytes], await self._execute_command(RequestType.SInter, keys))\n\n    async def sinterstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Stores the members of the intersection of all given sets specified by `keys` into a new set at `destination`.\n\n        See https://valkey.io/commands/sinterstore for more details.\n\n        Note:\n            When in Cluster mode, all `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination set.\n            keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n        Returns:\n            int: The number of elements in the resulting set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n            &gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n                1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.SInterStore, [destination] + keys),\n        )\n\n    async def sintercard(\n        self, keys: List[TEncodable], limit: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Gets the cardinality of the intersection of all the given sets.\n        Optionally, a `limit` can be specified to stop the computation early if the intersection cardinality reaches the specified limit.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/sintercard for more details.\n\n        Args:\n            keys (List[TEncodable]): A list of keys representing the sets to intersect.\n            limit (Optional[int]): An optional limit to the maximum number of intersecting elements to count.\n                If specified, the computation stops as soon as the cardinality reaches this limit.\n\n        Returns:\n            int: The number of elements in the resulting set of the intersection.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n            &gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n            &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n            2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n\n            &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n            1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        if limit is not None:\n            args += [\"LIMIT\", str(limit)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.SInterCard, args),\n        )\n\n    async def sdiff(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n        \"\"\"\n        Computes the difference between the first set and all the successive sets in `keys`.\n\n        See https://valkey.io/commands/sdiff for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sets to diff\n\n        Returns:\n            Set[bytes]: A set of elements representing the difference between the sets.\n                If any of the keys in `keys` do not exist, they are treated as empty sets.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n            &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n            &gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n                {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n        \"\"\"\n        return cast(\n            Set[bytes],\n            await self._execute_command(RequestType.SDiff, keys),\n        )\n\n    async def smismember(\n        self, key: TEncodable, members: List[TEncodable]\n    ) -&gt; List[bool]:\n        \"\"\"\n        Checks whether each member is contained in the members of the set stored at `key`.\n\n        See https://valkey.io/commands/smismember for more details.\n\n        Args:\n            key (TEncodable): The key of the set to check.\n            members (List[TEncodable]): A list of members to check for existence in the set.\n\n        Returns:\n            List[bool]: A list of bool values, each indicating if the respective member exists in the set.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n            &gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n                [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n        \"\"\"\n        return cast(\n            List[bool],\n            await self._execute_command(RequestType.SMIsMember, [key] + members),\n        )\n\n    async def ltrim(self, key: TEncodable, start: int, end: int) -&gt; TOK:\n        \"\"\"\n        Trim an existing list so that it will contain only the specified range of elements specified.\n        The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n        element and so on.\n        These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last\n        element of the list, -2 being the penultimate, and so on.\n        See https://valkey.io/commands/ltrim/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n                If `start` exceeds the end of the list, or if `start` is greater than `end`, the result will be an empty list\n                (which causes `key` to be removed).\n                If `end` exceeds the actual end of the list, it will be treated like the last element of the list.\n                If `key` does not exist, \"OK\" will be returned without changes to the database.\n\n        Examples:\n            &gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n                \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.LTrim, [key, str(start), str(end)]),\n        )\n\n    async def lrem(self, key: TEncodable, count: int, element: TEncodable) -&gt; int:\n        \"\"\"\n        Removes the first `count` occurrences of elements equal to `element` from the list stored at `key`.\n        If `count` is positive, it removes elements equal to `element` moving from head to tail.\n        If `count` is negative, it removes elements equal to `element` moving from tail to head.\n        If `count` is 0 or greater than the occurrences of elements equal to `element`, it removes all elements\n        equal to `element`.\n        See https://valkey.io/commands/lrem/ for more details.\n\n        Args:\n            key (TEncodable): The key of the list.\n            count (int): The count of occurrences of elements equal to `element` to remove.\n            element (TEncodable): The element to remove from the list.\n\n        Returns:\n            int: The number of removed elements.\n                If `key` does not exist, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n                2  # Removes the first 2 occurrences of \"value\" in the list.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.LRem, [key, str(count), element]),\n        )\n\n    async def llen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Get the length of the list stored at `key`.\n        See https://valkey.io/commands/llen/ for details.\n\n        Args:\n            key (TEncodable): The key of the list.\n\n        Returns:\n            int: The length of the list at the specified key.\n                If `key` does not exist, it is interpreted as an empty list and 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.llen(\"my_list\")\n                3  # Indicates that there are 3 elements in the list.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.LLen, [key]))\n\n    async def exists(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Returns the number of keys in `keys` that exist in the database.\n        See https://valkey.io/commands/exists/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The list of keys to check.\n\n        Returns:\n            int: The number of keys that exist. If the same existing key is mentioned in `keys` multiple times,\n                it will be counted multiple times.\n\n        Examples:\n            &gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n                3  # Indicates that all three keys exist in the database.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Exists, keys))\n\n    async def unlink(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Unlink (delete) multiple keys from the database.\n        A key is ignored if it does not exist.\n        This command, similar to DEL, removes specified keys and ignores non-existent ones.\n        However, this command does not block the server, while [DEL](https://valkey.io/commands/del) does.\n        See https://valkey.io/commands/unlink/ for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The list of keys to unlink.\n\n        Returns:\n            int: The number of keys that were unlinked.\n\n        Examples:\n            &gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n                3  # Indicates that all three keys were unlinked from the database.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.Unlink, keys))\n\n    async def expire(\n        self,\n        key: TEncodable,\n        seconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` in seconds. After the timeout has expired, the key will automatically be deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        If `seconds` is a non-positive number, the key will be deleted rather than expired.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/expire/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            seconds (int): The timeout in seconds.\n            option (ExpireOptions, optional): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n                True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n        \"\"\"\n        args: List[TEncodable] = (\n            [key, str(seconds)] if option is None else [key, str(seconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.Expire, args))\n\n    async def expireat(\n        self,\n        key: TEncodable,\n        unix_seconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the\n        number of seconds.\n        A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n        deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/expireat/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            unix_seconds (int): The timeout in an absolute Unix timestamp.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n                True\n        \"\"\"\n        args = (\n            [key, str(unix_seconds)]\n            if option is None\n            else [key, str(unix_seconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.ExpireAt, args))\n\n    async def pexpire(\n        self,\n        key: TEncodable,\n        milliseconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` in milliseconds. After the timeout has expired, the key will automatically be deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        If `milliseconds` is a non-positive number, the key will be deleted rather than expired.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/pexpire/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            milliseconds (int): The timeout in milliseconds.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n                True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n        \"\"\"\n        args = (\n            [key, str(milliseconds)]\n            if option is None\n            else [key, str(milliseconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.PExpire, args))\n\n    async def pexpireat(\n        self,\n        key: TEncodable,\n        unix_milliseconds: int,\n        option: Optional[ExpireOptions] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Sets a timeout on `key` using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead\n        of specifying the number of milliseconds.\n        A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n        deleted.\n        If `key` already has an existing expire set, the time to live is updated to the new value.\n        The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n        See https://valkey.io/commands/pexpireat/ for more details.\n\n        Args:\n            key (TEncodable): The key to set a timeout on.\n            unix_milliseconds (int): The timeout in an absolute Unix timestamp in milliseconds.\n            option (Optional[ExpireOptions]): The expire option.\n\n        Returns:\n            bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n                skipped due to the provided arguments).\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n                True\n        \"\"\"\n        args = (\n            [key, str(unix_milliseconds)]\n            if option is None\n            else [key, str(unix_milliseconds), option.value]\n        )\n        return cast(bool, await self._execute_command(RequestType.PExpireAt, args))\n\n    async def expiretime(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the absolute Unix timestamp (since January 1, 1970) at which\n        the given `key` will expire, in seconds.\n        To get the expiration with millisecond precision, use `pexpiretime`.\n\n        See https://valkey.io/commands/expiretime/ for details.\n\n        Args:\n            key (TEncodable): The `key` to determine the expiration value of.\n\n        Returns:\n            int: The expiration Unix timestamp in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                -2 # 'my_key' doesn't exist.\n            &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                -1 # 'my_key' has no associate expiration.\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            &gt;&gt;&gt; await client.expiretime(\"my_key\")\n                1718614954\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.ExpireTime, [key]))\n\n    async def pexpiretime(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the absolute Unix timestamp (since January 1, 1970) at which\n        the given `key` will expire, in milliseconds.\n\n        See https://valkey.io/commands/pexpiretime/ for details.\n\n        Args:\n            key (TEncodable): The `key` to determine the expiration value of.\n\n        Returns:\n            int: The expiration Unix timestamp in milliseconds, -2 if `key` does not exist, or -1 if `key` exists but has no associated expiration.\n\n        Examples:\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                -2 # 'my_key' doesn't exist.\n            &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                -1 # 'my_key' has no associate expiration.\n            &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n                1718615446670\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.PExpireTime, [key]))\n\n    async def ttl(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the remaining time to live of `key` that has a timeout.\n        See https://valkey.io/commands/ttl/ for more details.\n\n        Args:\n            key (TEncodable): The key to return its timeout.\n\n        Returns:\n            int: TTL in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.ttl(\"my_key\")\n                3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n            &gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n                -2  # Returns -2 for a non-existing key.\n            &gt;&gt;&gt; await client.ttl(\"key\")\n                -1  # Indicates that \"key: has no has no associated expire.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.TTL, [key]))\n\n    async def pttl(\n        self,\n        key: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Returns the remaining time to live of `key` that has a timeout, in milliseconds.\n        See https://valkey.io/commands/pttl for more details.\n\n        Args:\n            key (TEncodable): The key to return its timeout.\n\n        Returns:\n            int: TTL in milliseconds. -2 if `key` does not exist, -1 if `key` exists but has no associated expire.\n\n        Examples:\n            &gt;&gt;&gt; await client.pttl(\"my_key\")\n                5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n            &gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n                -2  # Indicates that the key \"non_existing_key\" does not exist.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PTTL, [key]),\n        )\n\n    async def persist(\n        self,\n        key: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Remove the existing timeout on `key`, turning the key from volatile (a key with an expire set) to\n        persistent (a key that will never expire as no timeout is associated).\n\n        See https://valkey.io/commands/persist/ for more details.\n\n        Args:\n            key (TEncodable): The key to remove the existing timeout on.\n\n        Returns:\n            bool: False if `key` does not exist or does not have an associated timeout, True if the timeout has been removed.\n\n        Examples:\n            &gt;&gt;&gt; await client.persist(\"my_key\")\n                True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.Persist, [key]),\n        )\n\n    async def type(self, key: TEncodable) -&gt; bytes:\n        \"\"\"\n        Returns the bytes string representation of the type of the value stored at `key`.\n\n        See https://valkey.io/commands/type/ for more details.\n\n        Args:\n            key (TEncodable): The key to check its data type.\n\n        Returns:\n            bytes: If the key exists, the type of the stored value is returned.\n            Otherwise, a b\"none\" bytes string is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            &gt;&gt;&gt; await client.type(\"key\")\n                b'string'\n            &gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n            &gt;&gt;&gt; await client.type(\"key\")\n                b'list'\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.Type, [key]))\n\n    async def xadd(\n        self,\n        key: TEncodable,\n        values: List[Tuple[TEncodable, TEncodable]],\n        options: Optional[StreamAddOptions] = None,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Adds an entry to the specified stream stored at `key`. If the `key` doesn't exist, the stream is created.\n\n        See https://valkey.io/commands/xadd for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            values (List[Tuple[TEncodable, TEncodable]]): Field-value pairs to be added to the entry.\n            options (Optional[StreamAddOptions]): Additional options for adding entries to the stream. Default to None. See `StreamAddOptions`.\n\n        Returns:\n            bytes: The id of the added entry, or None if `options.make_stream` is set to False and no stream with the matching `key` exists.\n\n        Example:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])\n                b\"1615957011958-0\"  # Example stream entry ID.\n            &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))\n                None  # The key doesn't exist, therefore, None is returned.\n            &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))\n                b\"0-1\"  # Returns the stream id.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        if options:\n            args.extend(options.to_args())\n        else:\n            args.append(\"*\")\n        args.extend([field for pair in values for field in pair])\n\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.XAdd, args)\n        )\n\n    async def xdel(self, key: TEncodable, ids: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Removes the specified entries by id from a stream, and returns the number of entries deleted.\n\n        See https://valkey.io/commands/xdel for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            ids (List[TEncodable]): An array of entry ids.\n\n        Returns:\n            int: The number of entries removed from the stream. This number may be less than the number of entries in\n                `ids`, if the specified `ids` don't exist in the stream.\n\n        Examples:\n            &gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n                2  # Stream marked 2 entries as deleted.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        args.extend(ids)\n        return cast(\n            int,\n            await self._execute_command(RequestType.XDel, [key] + ids),\n        )\n\n    async def xtrim(\n        self,\n        key: TEncodable,\n        options: StreamTrimOptions,\n    ) -&gt; int:\n        \"\"\"\n        Trims the stream stored at `key` by evicting older entries.\n\n        See https://valkey.io/commands/xtrim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            options (StreamTrimOptions): Options detailing how to trim the stream. See `StreamTrimOptions`.\n\n        Returns:\n            int: TThe number of entries deleted from the stream. If `key` doesn't exist, 0 is returned.\n\n        Example:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))\n                1 # One entry was deleted from the stream.\n        \"\"\"\n        args = [key]\n        if options:\n            args.extend(options.to_args())\n\n        return cast(int, await self._execute_command(RequestType.XTrim, args))\n\n    async def xlen(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the number of entries in the stream stored at `key`.\n\n        See https://valkey.io/commands/xlen for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            int: The number of entries in the stream. If `key` does not exist, returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n            &gt;&gt;&gt; await client.xlen(\"mystream\")\n                2  # There are 2 entries in \"mystream\".\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.XLen, [key]),\n        )\n\n    async def xrange(\n        self,\n        key: TEncodable,\n        start: StreamRangeBound,\n        end: StreamRangeBound,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n        \"\"\"\n        Returns stream entries matching a given range of IDs.\n\n        See https://valkey.io/commands/xrange for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n                If `count` is not provided, all stream entries in the range will be returned.\n\n        Returns:\n            Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n                list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n                arguments are not applicable.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n                {\n                    b\"0-1\": [[b\"field1\", b\"value1\"]],\n                    b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n        \"\"\"\n        args: List[TEncodable] = [key, start.to_arg(), end.to_arg()]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[Mapping[bytes, List[List[bytes]]]],\n            await self._execute_command(RequestType.XRange, args),\n        )\n\n    async def xrevrange(\n        self,\n        key: TEncodable,\n        end: StreamRangeBound,\n        start: StreamRangeBound,\n        count: Optional[int] = None,\n    ) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n        \"\"\"\n        Returns stream entries matching a given range of IDs in reverse order. Equivalent to `XRANGE` but returns the\n        entries in reverse order.\n\n        See https://valkey.io/commands/xrevrange for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n                If `count` is not provided, all stream entries in the range will be returned.\n\n        Returns:\n            Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n                list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n                arguments are not applicable.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n                {\n                    \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n                    \"0-1\": [[\"field1\", \"value1\"]],\n                }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n        \"\"\"\n        args: List[TEncodable] = [key, end.to_arg(), start.to_arg()]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[Mapping[bytes, List[List[bytes]]]],\n            await self._execute_command(RequestType.XRevRange, args),\n        )\n\n    async def xread(\n        self,\n        keys_and_ids: Mapping[TEncodable, TEncodable],\n        options: Optional[StreamReadOptions] = None,\n    ) -&gt; Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]:\n        \"\"\"\n        Reads entries from the given streams.\n\n        See https://valkey.io/commands/xread for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n        Args:\n            keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of keys and entry IDs to read from.\n            options (Optional[StreamReadOptions]): Options detailing how to read the stream.\n\n        Returns:\n            Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs,\n                to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n                None will be returned under the following conditions:\n                - All key-ID pairs in `keys_and_ids` have either a non-existing key or a non-existing ID, or there are no entries after the given ID.\n                - The `BLOCK` option is specified and the timeout is hit.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n            &gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n                {\n                    b\"mystream\": {\n                        b\"0-1\": [[b\"field1\", b\"value1\"]],\n                        b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                    }\n                }\n                # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n                # 1000ms if there is no stream data.\n        \"\"\"\n        args: List[TEncodable] = [] if options is None else options.to_args()\n        args.append(\"STREAMS\")\n        args.extend([key for key in keys_and_ids.keys()])\n        args.extend([value for value in keys_and_ids.values()])\n\n        return cast(\n            Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]],\n            await self._execute_command(RequestType.XRead, args),\n        )\n\n    async def xgroup_create(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        group_id: TEncodable,\n        options: Optional[StreamGroupOptions] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Creates a new consumer group uniquely identified by `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-create for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The newly created consumer group name.\n            group_id (TEncodable): The stream entry ID that specifies the last delivered entry in the stream from the new\n                group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.\n            options (Optional[StreamGroupOptions]): Options for creating the stream group.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n                OK\n                # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n                # the most recent entry. The stream was created with length 0 if it did not already exist.\n        \"\"\"\n        args: List[TEncodable] = [key, group_name, group_id]\n        if options is not None:\n            args.extend(options.to_args())\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.XGroupCreate, args),\n        )\n\n    async def xgroup_destroy(self, key: TEncodable, group_name: TEncodable) -&gt; bool:\n        \"\"\"\n        Destroys the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-destroy for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name to delete.\n\n        Returns:\n            bool: True if the consumer group was destroyed. Otherwise, returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n                True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.XGroupDestroy, [key, group_name]),\n        )\n\n    async def xgroup_create_consumer(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n    ) -&gt; bool:\n        \"\"\"\n        Creates a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-createconsumer for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The newly created consumer.\n\n        Returns:\n            bool: True if the consumer is created. Otherwise, returns False.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n                True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(\n                RequestType.XGroupCreateConsumer, [key, group_name, consumer_name]\n            ),\n        )\n\n    async def xgroup_del_consumer(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Deletes a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n        See https://valkey.io/commands/xgroup-delconsumer for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer to delete.\n\n        Returns:\n            int: The number of pending messages the `consumer` had before it was deleted.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n                5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.XGroupDelConsumer, [key, group_name, consumer_name]\n            ),\n        )\n\n    async def xgroup_set_id(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        stream_id: TEncodable,\n        entries_read: Optional[int] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Set the last delivered ID for a consumer group.\n\n        See https://valkey.io/commands/xgroup-setid for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            stream_id (TEncodable): The stream entry ID that should be set as the last delivered ID for the consumer group.\n            entries_read: (Optional[int]): A value representing the number of stream entries already read by the\n                group. This option can only be specified if you are using Valkey version 7.0.0 or above.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n                OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n        \"\"\"\n        args: List[TEncodable] = [key, group_name, stream_id]\n        if entries_read is not None:\n            args.extend([\"ENTRIESREAD\", str(entries_read)])\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.XGroupSetId, args),\n        )\n\n    async def xreadgroup(\n        self,\n        keys_and_ids: Mapping[TEncodable, TEncodable],\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        options: Optional[StreamReadGroupOptions] = None,\n    ) -&gt; Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]:\n        \"\"\"\n        Reads entries from the given streams owned by a consumer group.\n\n        See https://valkey.io/commands/xreadgroup for more details.\n\n        Note:\n            When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n        Args:\n            keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of stream keys to stream entry IDs to read from.\n                Use the special entry ID of `\"&gt;\"` to receive only new messages.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name. The consumer will be auto-created if it does not already exist.\n            options (Optional[StreamReadGroupOptions]): Options detailing how to read the stream.\n\n        Returns:\n            Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of\n                stream IDs, to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n                Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n        \"\"\"\n        args: List[TEncodable] = [\"GROUP\", group_name, consumer_name]\n        if options is not None:\n            args.extend(options.to_args())\n\n        args.append(\"STREAMS\")\n        args.extend([key for key in keys_and_ids.keys()])\n        args.extend([value for value in keys_and_ids.values()])\n\n        return cast(\n            Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]],\n            await self._execute_command(RequestType.XReadGroup, args),\n        )\n\n    async def xack(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        ids: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group.\n        This command should be called on pending messages so that such messages do not get processed again by the\n        consumer group.\n\n        See https://valkey.io/commands/xack for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            ids (List[TEncodable]): The stream entry IDs to acknowledge and consume for the given consumer group.\n\n        Returns:\n            int: The number of messages that were successfully acknowledged.\n\n        Examples:\n            &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n            &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n                {\n                    \"mystream\": {\n                        \"1-0\": [[\"field1\", \"value1\"]],\n                    }\n                }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n            &gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n                1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n        \"\"\"\n        args: List[TEncodable] = [key, group_name]\n        args.extend(ids)\n        return cast(\n            int,\n            await self._execute_command(RequestType.XAck, [key, group_name] + ids),\n        )\n\n    async def xpending(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n    ) -&gt; List[Union[int, bytes, List[List[bytes]], None]]:\n        \"\"\"\n        Returns stream message summary information for pending messages for the given consumer group.\n\n        See https://valkey.io/commands/xpending for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n\n        Returns:\n            List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the\n                format `[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]`, where:\n                - `num_group_messages`: The total number of pending messages for this consumer group.\n                - `start_id`: The smallest ID among the pending messages.\n                - `end_id`: The greatest ID among the pending messages.\n                - `[[consumer_name, num_consumer_messages]]`: A 2D list of every consumer in the consumer group with at\n                least one pending message, and the number of pending messages it has.\n\n                If there are no pending messages for the given consumer group, `[0, None, None, None]` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n                [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n        \"\"\"\n        return cast(\n            List[Union[int, bytes, List[List[bytes]], None]],\n            await self._execute_command(RequestType.XPending, [key, group_name]),\n        )\n\n    async def xpending_range(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        start: StreamRangeBound,\n        end: StreamRangeBound,\n        count: int,\n        options: Optional[StreamPendingOptions] = None,\n    ) -&gt; List[List[Union[bytes, int]]]:\n        \"\"\"\n        Returns an extended form of stream message information for pending messages matching a given range of IDs.\n\n        See https://valkey.io/commands/xpending for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            start (StreamRangeBound): The starting stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MinId` to start with the minimum available ID.\n            end (StreamRangeBound): The ending stream ID bound for the range.\n                - Use `IdBound` to specify a stream ID.\n                - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n                - Use `MaxId` to end with the maximum available ID.\n            count (int): Limits the number of messages returned.\n            options (Optional[StreamPendingOptions]): The stream pending options.\n\n        Returns:\n            List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended\n                message information with the format `[[id, consumer_name, time_elapsed, num_delivered]]`, where:\n                - `id`: The ID of the message.\n                - `consumer_name`: The name of the consumer that fetched the message and has still to acknowledge it. We\n                call it the current owner of the message.\n                - `time_elapsed`: The number of milliseconds that elapsed since the last time this message was delivered\n                to this consumer.\n                - `num_delivered`: The number of times this message was delivered.\n\n        Examples:\n            &gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n                [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n                # Extended stream entry information for the pending entries associated with \"my_consumer\".\n        \"\"\"\n        args = _create_xpending_range_args(key, group_name, start, end, count, options)\n        return cast(\n            List[List[Union[bytes, int]]],\n            await self._execute_command(RequestType.XPending, args),\n        )\n\n    async def xclaim(\n        self,\n        key: TEncodable,\n        group: TEncodable,\n        consumer: TEncodable,\n        min_idle_time_ms: int,\n        ids: List[TEncodable],\n        options: Optional[StreamClaimOptions] = None,\n    ) -&gt; Mapping[bytes, List[List[bytes]]]:\n        \"\"\"\n        Changes the ownership of a pending message.\n\n        See https://valkey.io/commands/xclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group (TEncodable): The consumer group name.\n            consumer (TEncodable): The group consumer.\n            min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n            ids (List[TEncodable]): A array of entry ids.\n            options (Optional[StreamClaimOptions]): Stream claim options.\n\n        Returns:\n            Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format\n                {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.\n\n        Examples:\n            # read messages from streamId for consumer1\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }\n                # \"1-0\" is now read, and we can assign the pending messages to consumer2\n            &gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n                {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n        \"\"\"\n\n        args = [key, group, consumer, str(min_idle_time_ms), *ids]\n\n        if options:\n            args.extend(options.to_args())\n\n        return cast(\n            Mapping[bytes, List[List[bytes]]],\n            await self._execute_command(RequestType.XClaim, args),\n        )\n\n    async def xclaim_just_id(\n        self,\n        key: TEncodable,\n        group: TEncodable,\n        consumer: TEncodable,\n        min_idle_time_ms: int,\n        ids: List[TEncodable],\n        options: Optional[StreamClaimOptions] = None,\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Changes the ownership of a pending message. This function returns a List with\n        only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.\n\n        See https://valkey.io/commands/xclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group (TEncodable): The consumer group name.\n            consumer (TEncodable): The group consumer.\n            min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n            ids (List[TEncodable]): A array of entry ids.\n            options (Optional[StreamClaimOptions]): Stream claim options.\n\n        Returns:\n            List[bytes]: A List of message ids claimed by the consumer.\n\n        Examples:\n            # read messages from streamId for consumer1\n            &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n                {\n                    b\"mystream\": {\n                        b\"1-0\": [[b\"field1\", b\"value1\"]],\n                    }\n                }\n                # \"1-0\" is now read, and we can assign the pending messages to consumer2\n            &gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n                [b\"1-0\"]\n        \"\"\"\n\n        args = [\n            key,\n            group,\n            consumer,\n            str(min_idle_time_ms),\n            *ids,\n            StreamClaimOptions.JUST_ID_VALKEY_API,\n        ]\n\n        if options:\n            args.extend(options.to_args())\n\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.XClaim, args),\n        )\n\n    async def xautoclaim(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        min_idle_time_ms: int,\n        start: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]:\n        \"\"\"\n        Transfers ownership of pending stream entries that match the specified criteria.\n\n        See https://valkey.io/commands/xautoclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name.\n            min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n                value.\n            start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n            count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n        Returns:\n            List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements:\n                - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n                to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n                scanned.\n                - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a\n                2D list of the field-value pairs in the format `[[field1, value1], [field2, value2], ...]`.\n                - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n                message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n                deleted from the Pending Entries List.\n\n        Examples:\n            # Valkey version &lt; 7.0.0:\n            &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [\n                    b\"0-0\",\n                    {\n                        b\"1-1\": [\n                            [b\"field1\", b\"value1\"],\n                            [b\"field2\", b\"value2\"],\n                        ]\n                    }\n                ]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned.\n\n            # Valkey version 7.0.0 and above:\n            &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [\n                    b\"0-0\",\n                    {\n                        b\"1-1\": [\n                            [b\"field1\", b\"value1\"],\n                            [b\"field2\", b\"value2\"],\n                        ]\n                    },\n                    [b\"1-2\"]\n                ]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n                # exists in the stream.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [\n            key,\n            group_name,\n            consumer_name,\n            str(min_idle_time_ms),\n            start,\n        ]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]],\n            await self._execute_command(RequestType.XAutoClaim, args),\n        )\n\n    async def xautoclaim_just_id(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n        consumer_name: TEncodable,\n        min_idle_time_ms: int,\n        start: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID\n        argument to further specify that the return value should contain a list of claimed IDs without their\n        field-value info.\n\n        See https://valkey.io/commands/xautoclaim for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n            consumer_name (TEncodable): The consumer name.\n            min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n                value.\n            start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n            count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: A list containing the following elements:\n                - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n                to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n                scanned.\n                - A list of the IDs for the claimed entries.\n                - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n                message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n                deleted from the Pending Entries List.\n\n        Examples:\n            # Valkey version &lt; 7.0.0:\n            &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [b\"0-0\", [b\"1-1\"]]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned.\n\n            # Valkey version 7.0.0 and above:\n            &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n                [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n                # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n                # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n                # exists in the stream.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [\n            key,\n            group_name,\n            consumer_name,\n            str(min_idle_time_ms),\n            start,\n        ]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        args.append(\"JUSTID\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.XAutoClaim, args),\n        )\n\n    async def xinfo_groups(\n        self,\n        key: TEncodable,\n    ) -&gt; List[Mapping[bytes, Union[bytes, int, None]]]:\n        \"\"\"\n        Returns the list of all consumer groups and their attributes for the stream stored at `key`.\n\n        See https://valkey.io/commands/xinfo-groups for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the\n                attributes of a consumer group for the stream at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n                [\n                    {\n                        b\"name\": b\"mygroup\",\n                        b\"consumers\": 2,\n                        b\"pending\": 2,\n                        b\"last-delivered-id\": b\"1638126030001-0\",\n                        b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n                        b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n                    },\n                    {\n                        b\"name\": b\"some-other-group\",\n                        b\"consumers\": 1,\n                        b\"pending\": 0,\n                        b\"last-delivered-id\": b\"1638126028070-0\",\n                        b\"entries-read\": 1,\n                        b\"lag\": 1,\n                    }\n                ]\n                # The list of consumer groups and their attributes for stream \"my_stream\".\n        \"\"\"\n        return cast(\n            List[Mapping[bytes, Union[bytes, int, None]]],\n            await self._execute_command(RequestType.XInfoGroups, [key]),\n        )\n\n    async def xinfo_consumers(\n        self,\n        key: TEncodable,\n        group_name: TEncodable,\n    ) -&gt; List[Mapping[bytes, Union[bytes, int]]]:\n        \"\"\"\n        Returns the list of all consumers and their attributes for the given consumer group of the stream stored at\n        `key`.\n\n        See https://valkey.io/commands/xinfo-consumers for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            group_name (TEncodable): The consumer group name.\n\n        Returns:\n            List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a\n                consumer for the given consumer group of the stream at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n                [\n                    {\n                        b\"name\": b\"Alice\",\n                        b\"pending\": 1,\n                        b\"idle\": 9104628,\n                        b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n                    },\n                    {\n                        b\"name\": b\"Bob\",\n                        b\"pending\": 1,\n                        b\"idle\": 83841983,\n                        b\"inactive\": 993841998,\n                    }\n                ]\n                # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n        \"\"\"\n        return cast(\n            List[Mapping[bytes, Union[bytes, int]]],\n            await self._execute_command(RequestType.XInfoConsumers, [key, group_name]),\n        )\n\n    async def xinfo_stream(\n        self,\n        key: TEncodable,\n    ) -&gt; TXInfoStreamResponse:\n        \"\"\"\n        Returns information about the stream stored at `key`. To get more detailed information, use `xinfo_stream_full`.\n\n        See https://valkey.io/commands/xinfo-stream for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n\n        Returns:\n            TXInfoStreamResponse: A mapping of stream information for the given `key`. See the example for a sample\n                response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n                {\n                    b\"length\": 4,\n                    b\"radix-tree-keys\": 1L,\n                    b\"radix-tree-nodes\": 2L,\n                    b\"last-generated-id\": b\"1719877599564-0\",\n                    b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                    b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"groups\": 1L,\n                    b\"first-entry\": [\n                        b\"1719710679916-0\",\n                        [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                    ],\n                    b\"last-entry\": [\n                        b\"1719877599564-0\",\n                        [b\"field1\", b\"value1\"],\n                    ],\n                }\n                # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n                # the stream is empty.\n        \"\"\"\n        return cast(\n            TXInfoStreamResponse,\n            await self._execute_command(RequestType.XInfoStream, [key]),\n        )\n\n    async def xinfo_stream_full(\n        self,\n        key: TEncodable,\n        count: Optional[int] = None,\n    ) -&gt; TXInfoStreamFullResponse:\n        \"\"\"\n        Returns verbose information about the stream stored at `key`.\n\n        See https://valkey.io/commands/xinfo-stream for more details.\n\n        Args:\n            key (TEncodable): The key of the stream.\n            count (Optional[int]): The number of stream and PEL entries that are returned. A value of `0` means that all\n                entries will be returned. If not provided, defaults to `10`.\n\n        Returns:\n            TXInfoStreamFullResponse: A mapping of detailed stream information for the given `key`. See the example for\n                a sample response.\n\n        Examples:\n            &gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n                {\n                    b\"length\": 4,\n                    b\"radix-tree-keys\": 1L,\n                    b\"radix-tree-nodes\": 2L,\n                    b\"last-generated-id\": b\"1719877599564-0\",\n                    b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                    b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                    b\"entries\": [\n                        [\n                            b\"1719710679916-0\",\n                            [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                        ],\n                        [\n                            b\"1719877599564-0\":\n                            [b\"field1\", b\"value1\"],\n                        ]\n                    ],\n                    b\"groups\": [\n                        {\n                            b\"name\": b\"mygroup\",\n                            b\"last-delivered-id\": b\"1719710688676-0\",\n                            b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                            b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                            b\"pel-count\": 2,\n                            b\"pending\": [\n                                [\n                                    b\"1719710679916-0\",\n                                    b\"Alice\",\n                                    1719710707260,\n                                    1,\n                                ],\n                                [\n                                    b\"1719710688676-0\",\n                                    b\"Alice\",\n                                    1719710718373,\n                                    1,\n                                ],\n                            ],\n                            b\"consumers\": [\n                                {\n                                    b\"name\": b\"Alice\",\n                                    b\"seen-time\": 1719710718373,\n                                    b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                                    b\"pel-count\": 2,\n                                    b\"pending\": [\n                                        [\n                                            b\"1719710679916-0\",\n                                            1719710707260,\n                                            1\n                                        ],\n                                        [\n                                            b\"1719710688676-0\",\n                                            1719710718373,\n                                            1\n                                        ]\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                }\n                # Detailed stream information for \"my_stream\".\n\n        Since: Valkey version 6.0.0.\n        \"\"\"\n        args = [key, \"FULL\"]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            TXInfoStreamFullResponse,\n            await self._execute_command(RequestType.XInfoStream, args),\n        )\n\n    async def geoadd(\n        self,\n        key: TEncodable,\n        members_geospatialdata: Mapping[TEncodable, GeospatialData],\n        existing_options: Optional[ConditionalChange] = None,\n        changed: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Adds geospatial members with their positions to the specified sorted set stored at `key`.\n        If a member is already a part of the sorted set, its position is updated.\n\n        See https://valkey.io/commands/geoadd for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members_geospatialdata (Mapping[TEncodable, GeospatialData]): A mapping of member names to their corresponding positions. See `GeospatialData`.\n            The command will report an error when the user attempts to index coordinates outside the specified ranges.\n            existing_options (Optional[ConditionalChange]): Options for handling existing members.\n                - NX: Only add new elements.\n                - XX: Only update existing elements.\n            changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n        Returns:\n            int: The number of elements added to the sorted set.\n            If `changed` is set, returns the number of elements updated in the sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n                2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n                1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if changed:\n            args.append(\"CH\")\n\n        members_geospatialdata_list = [\n            coord\n            for member, position in members_geospatialdata.items()\n            for coord in [str(position.longitude), str(position.latitude), member]\n        ]\n        args += members_geospatialdata_list\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.GeoAdd, args),\n        )\n\n    async def geodist(\n        self,\n        key: TEncodable,\n        member1: TEncodable,\n        member2: TEncodable,\n        unit: Optional[GeoUnit] = None,\n    ) -&gt; Optional[float]:\n        \"\"\"\n        Returns the distance between two members in the geospatial index stored at `key`.\n\n        See https://valkey.io/commands/geodist for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member1 (TEncodable): The name of the first member.\n            member2 (TEncodable): The name of the second member.\n            unit (Optional[GeoUnit]): The unit of distance measurement. See `GeoUnit`.\n                If not specified, the default unit is `METERS`.\n\n        Returns:\n            Optional[float]: The distance between `member1` and `member2`.\n            If one or both members do not exist, or if the key does not exist, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n                166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n                166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n            &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n                None  # Returns None for non-existing member.\n        \"\"\"\n        args = [key, member1, member2]\n        if unit:\n            args.append(unit.value)\n\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.GeoDist, args),\n        )\n\n    async def geohash(\n        self, key: TEncodable, members: List[TEncodable]\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at\n        `key`.\n\n        See https://valkey.io/commands/geohash for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): The list of members whose GeoHash bytes strings are to be retrieved.\n\n        Returns:\n            List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at `key`.\n            If a member does not exist in the sorted set, a None value is returned for that member.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n                [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n        \"\"\"\n        return cast(\n            List[Optional[bytes]],\n            await self._execute_command(RequestType.GeoHash, [key] + members),\n        )\n\n    async def geopos(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; List[Optional[List[float]]]:\n        \"\"\"\n        Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at\n        `key`.\n\n        See https://valkey.io/commands/geopos for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): The members for which to get the positions.\n\n        Returns:\n            List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.\n            If a member does not exist, its position will be None.\n\n        Example:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])\n                [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]\n        \"\"\"\n        return cast(\n            List[Optional[List[float]]],\n            await self._execute_command(RequestType.GeoPos, [key] + members),\n        )\n\n    async def geosearch(\n        self,\n        key: TEncodable,\n        search_from: Union[str, bytes, GeospatialData],\n        search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n        order_by: Optional[OrderBy] = None,\n        count: Optional[GeoSearchCount] = None,\n        with_coord: bool = False,\n        with_dist: bool = False,\n        with_hash: bool = False,\n    ) -&gt; List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]:\n        \"\"\"\n        Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area.\n\n        See https://valkey.io/commands/geosearch/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set representing geospatial data.\n            search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                from the sorted set or as a geospatial data (see `GeospatialData`).\n            search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                For circular area search, see `GeoSearchByRadius`.\n                For rectangular area search, see `GeoSearchByBox`.\n            order_by (Optional[OrderBy]): Specifies the order in which the results should be returned.\n                    - `ASC`: Sorts items from the nearest to the farthest, relative to the center point.\n                    - `DESC`: Sorts items from the farthest to the nearest, relative to the center point.\n                If not specified, the results would be unsorted.\n            count (Optional[GeoSearchCount]): Specifies the maximum number of results to return. See `GeoSearchCount`.\n                If not specified, return all results.\n            with_coord (bool): Whether to include coordinates of the returned items. Defaults to False.\n            with_dist (bool): Whether to include distance from the center in the returned items.\n                The distance is returned in the same unit as specified for the `search_by` arguments. Defaults to False.\n            with_hash (bool): Whether to include geohash of the returned items. Defaults to False.\n\n        Returns:\n            List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.\n            If any of `with_coord`, `with_dist` or `with_hash` are True, returns an array of arrays, we're each sub array represents a single item in the following order:\n                (bytes): The member (location) name.\n                (float): The distance from the center as a floating point number, in the same unit specified in the radius, if `with_dist` is set to True.\n                (int): The Geohash integer, if `with_hash` is set to True.\n                List[float]: The coordinates as a two item [longitude,latitude] array, if `with_coord` is set to True.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n                ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n            &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n                [\n                    [\n                        b\"Catania\",\n                        [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n                    ],\n                    [\n                        b\"Palermo\",\n                        [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n                    ],\n                    [\n                        b\"edge2\",\n                        [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n                    ],\n                    [\n                        b\"edge1\",\n                        [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n                    ],\n                ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = _create_geosearch_args(\n            [key],\n            search_from,\n            search_by,\n            order_by,\n            count,\n            with_coord,\n            with_dist,\n            with_hash,\n        )\n\n        return cast(\n            List[Union[bytes, List[Union[bytes, float, int, List[float]]]]],\n            await self._execute_command(RequestType.GeoSearch, args),\n        )\n\n    async def geosearchstore(\n        self,\n        destination: TEncodable,\n        source: TEncodable,\n        search_from: Union[str, bytes, GeospatialData],\n        search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n        count: Optional[GeoSearchCount] = None,\n        store_dist: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n\n        To get the result directly, see `geosearch`.\n\n        Note:\n            When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n            Args:\n                destination (TEncodable): The key to store the search results.\n                source (TEncodable): The key of the sorted set representing geospatial data to search from.\n                search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                    from the sorted set or as a geospatial data (see `GeospatialData`).\n                search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                    For circular area search, see `GeoSearchByRadius`.\n                    For rectangular area search, see `GeoSearchByBox`.\n                count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See `GeoSearchCount`.\n                    If not specified, stores all results.\n                store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.\n                    - If set to False, the geohash of the location will be stored as the sorted set score.\n                    - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.\n                        The distance is represented as a floating-point number in the same unit specified for that shape.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n                2 # Number of elements stored in \"my_dest_sorted_set\".\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n                {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n            &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n                2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n                {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = _create_geosearch_args(\n            [destination, source],\n            search_from,\n            search_by,\n            None,\n            count,\n            False,\n            False,\n            False,\n            store_dist,\n        )\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.GeoSearchStore, args),\n        )\n\n    async def zadd(\n        self,\n        key: TEncodable,\n        members_scores: Mapping[TEncodable, float],\n        existing_options: Optional[ConditionalChange] = None,\n        update_condition: Optional[UpdateOptions] = None,\n        changed: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Adds members with their scores to the sorted set stored at `key`.\n        If a member is already a part of the sorted set, its score is updated.\n\n        See https://valkey.io/commands/zadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members_scores (Mapping[TEncodable, float]): A mapping of members to their corresponding scores.\n            existing_options (Optional[ConditionalChange]): Options for handling existing members.\n                - NX: Only add new elements.\n                - XX: Only update existing elements.\n            update_condition (Optional[UpdateOptions]): Options for updating scores.\n                - GT: Only update scores greater than the current values.\n                - LT: Only update scores less than the current values.\n            changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n        Returns:\n            int: The number of elements added to the sorted set.\n            If `changed` is set, returns the number of elements updated in the sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n                2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n            &gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n                2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if update_condition:\n            args.append(update_condition.value)\n\n        if changed:\n            args.append(\"CH\")\n\n        if existing_options and update_condition:\n            if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n                raise ValueError(\n                    \"The GT, LT and NX options are mutually exclusive. \"\n                    f\"Cannot choose both {update_condition.value} and NX.\"\n                )\n\n        members_scores_list = [\n            str(item) for pair in members_scores.items() for item in pair[::-1]\n        ]\n        args += members_scores_list\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZAdd, args),\n        )\n\n    async def zadd_incr(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n        increment: float,\n        existing_options: Optional[ConditionalChange] = None,\n        update_condition: Optional[UpdateOptions] = None,\n    ) -&gt; Optional[float]:\n        \"\"\"\n        Increments the score of member in the sorted set stored at `key` by `increment`.\n        If `member` does not exist in the sorted set, it is added with `increment` as its score (as if its previous score was 0.0).\n        If `key` does not exist, a new sorted set with the specified member as its sole member is created.\n\n        See https://valkey.io/commands/zadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): A member in the sorted set to increment.\n            increment (float): The score to increment the member.\n            existing_options (Optional[ConditionalChange]): Options for handling the member's existence.\n                - NX: Only increment a member that doesn't exist.\n                - XX: Only increment an existing member.\n            update_condition (Optional[UpdateOptions]): Options for updating the score.\n                - GT: Only increment the score of the member if the new score will be greater than the current score.\n                - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.\n\n        Returns:\n            Optional[float]: The score of the member.\n            If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n                5.0\n            &gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n                None\n        \"\"\"\n        args = [key]\n        if existing_options:\n            args.append(existing_options.value)\n\n        if update_condition:\n            args.append(update_condition.value)\n\n        args.append(\"INCR\")\n\n        if existing_options and update_condition:\n            if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n                raise ValueError(\n                    \"The GT, LT and NX options are mutually exclusive. \"\n                    f\"Cannot choose both {update_condition.value} and NX.\"\n                )\n\n        args += [str(increment), member]\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.ZAdd, args),\n        )\n\n    async def zcard(self, key: TEncodable) -&gt; int:\n        \"\"\"\n        Returns the cardinality (number of elements) of the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zcard/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n\n        Returns:\n            int: The number of elements in the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n                3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n                0\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.ZCard, [key]))\n\n    async def zcount(\n        self,\n        key: TEncodable,\n        min_score: Union[InfBound, ScoreBoundary],\n        max_score: Union[InfBound, ScoreBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Returns the number of members in the sorted set stored at `key` with scores between `min_score` and `max_score`.\n\n        See https://valkey.io/commands/zcount/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_score (Union[InfBound, ScoreBoundary]): The minimum score to count from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n            max_score (Union[InfBound, ScoreBoundary]): The maximum score to count up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n\n        Returns:\n            int: The number of members in the specified score range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n            If `max_score` &lt; `min_score`, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n                2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n                1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n        \"\"\"\n        score_min = (\n            min_score.value[\"score_arg\"]\n            if type(min_score) == InfBound\n            else min_score.value\n        )\n        score_max = (\n            max_score.value[\"score_arg\"]\n            if type(max_score) == InfBound\n            else max_score.value\n        )\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZCount, [key, score_min, score_max]\n            ),\n        )\n\n    async def zincrby(\n        self, key: TEncodable, increment: float, member: TEncodable\n    ) -&gt; float:\n        \"\"\"\n        Increments the score of `member` in the sorted set stored at `key` by `increment`.\n        If `member` does not exist in the sorted set, it is added with `increment` as its score.\n        If `key` does not exist, a new sorted set is created with the specified member as its sole member.\n\n        See https://valkey.io/commands/zincrby/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            increment (float): The score increment.\n            member (TEncodable): A member of the sorted set.\n\n        Returns:\n            float: The new score of `member`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n                11.7  # The member existed in the set before score was altered, the new score is 11.7.\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n                10.0 # Negative increment, decrements the score.\n            &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n                5.5  # A new member is added to the sorted set with the score being 5.5.\n        \"\"\"\n        return cast(\n            float,\n            await self._execute_command(\n                RequestType.ZIncrBy, [key, str(increment), member]\n            ),\n        )\n\n    async def zpopmax(\n        self, key: TEncodable, count: Optional[int] = None\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Removes and returns the members with the highest scores from the sorted set stored at `key`.\n        If `count` is provided, up to `count` members with the highest scores are removed and returned.\n        Otherwise, only one member with the highest score is removed and returned.\n\n        See https://valkey.io/commands/zpopmax for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n            If `count` is higher than the sorted set's cardinality, returns all members and their scores, ordered from highest to lowest.\n\n        Returns:\n            Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.\n            If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n                {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n            &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n                {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n        \"\"\"\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(\n                RequestType.ZPopMax, [key, str(count)] if count else [key]\n            ),\n        )\n\n    async def bzpopmax(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[Union[bytes, float]]]:\n        \"\"\"\n        Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in\n        the order that they are given. Blocks the connection when there are no members to remove from any of the given\n        sorted sets.\n\n        When in cluster mode, all keys must map to the same hash slot.\n\n        `BZPOPMAX` is the blocking variant of `ZPOPMAX`.\n\n        `BZPOPMAX` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/bzpopmax for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            timeout (float): The number of seconds to wait for a blocking operation to complete.\n                A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n                and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n                2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n            &gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n                [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n        \"\"\"\n        return cast(\n            Optional[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.BZPopMax, keys + [str(timeout)]),\n        )\n\n    async def zpopmin(\n        self, key: TEncodable, count: Optional[int] = None\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Removes and returns the members with the lowest scores from the sorted set stored at `key`.\n        If `count` is provided, up to `count` members with the lowest scores are removed and returned.\n        Otherwise, only one member with the lowest score is removed and returned.\n\n        See https://valkey.io/commands/zpopmin for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n            If `count` is higher than the sorted set's cardinality, returns all members and their scores.\n\n        Returns:\n            Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.\n            If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n                {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n            &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n                {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count)] if count else [key]\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZPopMin, args),\n        )\n\n    async def bzpopmin(\n        self, keys: List[TEncodable], timeout: float\n    ) -&gt; Optional[List[Union[bytes, float]]]:\n        \"\"\"\n        Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in\n        the order that they are given. Blocks the connection when there are no members to remove from any of the given\n        sorted sets.\n\n        When in cluster mode, all keys must map to the same hash slot.\n\n        `BZPOPMIN` is the blocking variant of `ZPOPMIN`.\n\n        `BZPOPMIN` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        See https://valkey.io/commands/bzpopmin for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            timeout (float): The number of seconds to wait for a blocking operation to complete.\n                A value of 0 will block indefinitely.\n\n        Returns:\n            Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n                and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n                2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n            &gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n                [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n        \"\"\"\n        args: List[TEncodable] = keys + [str(timeout)]\n        return cast(\n            Optional[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.BZPopMin, args),\n        )\n\n    async def zrange(\n        self,\n        key: TEncodable,\n        range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Returns the specified range of elements in the sorted set stored at `key`.\n\n        ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.\n\n        See https://valkey.io/commands/zrange/ for more details.\n\n        To get the elements with their scores, see zrange_withscores.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by lexicographical order, use RangeByLex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            List[bytes]: A list of elements within the specified range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty array.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n                [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n        \"\"\"\n        args = _create_zrange_args(key, range_query, reverse, with_scores=False)\n\n        return cast(List[bytes], await self._execute_command(RequestType.ZRange, args))\n\n    async def zrange_withscores(\n        self,\n        key: TEncodable,\n        range_query: Union[RangeByIndex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Returns the specified range of elements with their scores in the sorted set stored at `key`.\n        Similar to ZRANGE but with a WITHSCORE flag.\n\n        See https://valkey.io/commands/zrange/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            range_query (Union[RangeByIndex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            Mapping[bytes , float]: A map of elements and their scores within the specified range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty map.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n                {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n           &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.\n        \"\"\"\n        args = _create_zrange_args(key, range_query, reverse, with_scores=True)\n\n        return cast(\n            Mapping[bytes, float], await self._execute_command(RequestType.ZRange, args)\n        )\n\n    async def zrangestore(\n        self,\n        destination: TEncodable,\n        source: TEncodable,\n        range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n        reverse: bool = False,\n    ) -&gt; int:\n        \"\"\"\n        Stores a specified range of elements from the sorted set at `source`, into a new sorted set at `destination`. If\n        `destination` doesn't exist, a new sorted set is created; if it exists, it's overwritten.\n\n        ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical\n        order.\n\n        See https://valkey.io/commands/zrangestore for more details.\n\n        Note:\n            When in Cluster mode, `source` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key for the destination sorted set.\n            source (TEncodable): The key of the source sorted set.\n            range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n                - For range queries by index (rank), use RangeByIndex.\n                - For range queries by lexicographical order, use RangeByLex.\n                - For range queries by score, use RangeByScore.\n            reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n        Returns:\n            int: The number of elements in the resulting sorted set.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n                3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n            &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n                2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n        \"\"\"\n        args = _create_zrange_args(source, range_query, reverse, False, destination)\n\n        return cast(int, await self._execute_command(RequestType.ZRangeStore, args))\n\n    async def zrank(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key`, with scores ordered from low to high.\n\n        See https://valkey.io/commands/zrank for more details.\n\n        To get the rank of `member` with its score, see `zrank_withscore`.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[int]: The rank of `member` in the sorted set.\n            If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n            Examples:\n            &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"member2\")\n                1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"non_existing_member\")\n                None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n        \"\"\"\n        return cast(\n            Optional[int], await self._execute_command(RequestType.ZRank, [key, member])\n        )\n\n    async def zrank_withscore(\n        self,\n        key: TEncodable,\n        member: TEncodable,\n    ) -&gt; Optional[List[Union[int, float]]]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the lowest to highest.\n\n        See https://valkey.io/commands/zrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[List[Union[int, float]]]: A list containing the rank and score of `member` in the sorted set.\n            If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n                [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n                None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n\n        Since: Valkey version 7.2.0.\n        \"\"\"\n        return cast(\n            Optional[List[Union[int, float]]],\n            await self._execute_command(RequestType.ZRank, [key, member, \"WITHSCORE\"]),\n        )\n\n    async def zrevrank(self, key: TEncodable, member: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key`, where scores are ordered from the highest to\n        lowest, starting from `0`.\n\n        To get the rank of `member` with its score, see `zrevrank_withscore`.\n\n        See https://valkey.io/commands/zrevrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[int]: The rank of `member` in the sorted set, where ranks are ordered from high to low based on scores.\n                If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n                2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ZRevRank, [key, member]),\n        )\n\n    async def zrevrank_withscore(\n        self, key: TEncodable, member: TEncodable\n    ) -&gt; Optional[List[Union[int, float]]]:\n        \"\"\"\n        Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the\n        highest to lowest, starting from `0`.\n\n        See https://valkey.io/commands/zrevrank for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose rank is to be retrieved.\n\n        Returns:\n            Optional[List[Union[int, float]]]: A list containing the rank (as `int`) and score (as `float`) of `member`\n                in the sorted set, where ranks are ordered from high to low based on scores.\n                If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n                [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n\n        Since: Valkey version 7.2.0.\n        \"\"\"\n        return cast(\n            Optional[List[Union[int, float]]],\n            await self._execute_command(\n                RequestType.ZRevRank, [key, member, \"WITHSCORE\"]\n            ),\n        )\n\n    async def zrem(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Removes the specified members from the sorted set stored at `key`.\n        Specified members that are not a member of this set are ignored.\n\n        See https://valkey.io/commands/zrem/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): A list of members to remove from the sorted set.\n\n        Returns:\n            int: The number of members that were removed from the sorted set, not including non-existing members.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n                2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n            &gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZRem, [key] + members),\n        )\n\n    async def zremrangebyscore(\n        self,\n        key: TEncodable,\n        min_score: Union[InfBound, ScoreBoundary],\n        max_score: Union[InfBound, ScoreBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with a score between `min_score` and `max_score`.\n\n        See https://valkey.io/commands/zremrangebyscore/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_score (Union[InfBound, ScoreBoundary]): The minimum score to remove from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n            max_score (Union[InfBound, ScoreBoundary]): The maximum score to remove up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or ScoreBoundary representing a specific score and inclusivity.\n        Returns:\n            int: The number of members that were removed from the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n            If `min_score` is greater than `max_score`, 0 is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n                2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        score_min = (\n            min_score.value[\"score_arg\"]\n            if type(min_score) == InfBound\n            else min_score.value\n        )\n        score_max = (\n            max_score.value[\"score_arg\"]\n            if type(max_score) == InfBound\n            else max_score.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByScore, [key, score_min, score_max]\n            ),\n        )\n\n    async def zremrangebylex(\n        self,\n        key: TEncodable,\n        min_lex: Union[InfBound, LexBoundary],\n        max_lex: Union[InfBound, LexBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with a lexicographical order between `min_lex` and\n        `max_lex`.\n\n        See https://valkey.io/commands/zremrangebylex/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_lex (Union[InfBound, LexBoundary]): The minimum bound of the lexicographical range.\n                Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n                representing a specific lex and inclusivity.\n            max_lex (Union[InfBound, LexBoundary]): The maximum bound of the lexicographical range.\n                Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n                representing a specific lex and inclusivity.\n\n        Returns:\n            int: The number of members that were removed from the sorted set.\n                If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n                If `min_lex` is greater than `max_lex`, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n                4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n                0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n        \"\"\"\n        min_lex_arg = (\n            min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n        )\n        max_lex_arg = (\n            max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByLex, [key, min_lex_arg, max_lex_arg]\n            ),\n        )\n\n    async def zremrangebyrank(\n        self,\n        key: TEncodable,\n        start: int,\n        end: int,\n    ) -&gt; int:\n        \"\"\"\n        Removes all elements in the sorted set stored at `key` with rank between `start` and `end`.\n        Both `start` and `end` are zero-based indexes with 0 being the element with the lowest score.\n        These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.\n\n        See https://valkey.io/commands/zremrangebyrank/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            start (int): The starting point of the range.\n            end (int): The end of the range.\n\n        Returns:\n            int: The number of elements that were removed.\n                If `start` exceeds the end of the sorted set, or if `start` is greater than `end`, `0` is returned.\n                If `end` exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set.\n                If `key` does not exist, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n                5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n                0  # Indicates that nothing was removed.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZRemRangeByRank, [key, str(start), str(end)]\n            ),\n        )\n\n    async def zlexcount(\n        self,\n        key: TEncodable,\n        min_lex: Union[InfBound, LexBoundary],\n        max_lex: Union[InfBound, LexBoundary],\n    ) -&gt; int:\n        \"\"\"\n        Returns the number of members in the sorted set stored at `key` with lexicographical values between `min_lex` and `max_lex`.\n\n        See https://valkey.io/commands/zlexcount/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            min_lex (Union[InfBound, LexBoundary]): The minimum lexicographical value to count from.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or LexBoundary representing a specific lexicographical value and inclusivity.\n            max_lex (Union[InfBound, LexBoundary]): The maximum lexicographical to count up to.\n                Can be an instance of InfBound representing positive/negative infinity,\n                or LexBoundary representing a specific lexicographical value and inclusivity.\n\n        Returns:\n            int: The number of members in the specified lexicographical range.\n                If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n                If `max_lex &lt; min_lex`, `0` is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n                2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n                1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n        \"\"\"\n        min_lex_arg = (\n            min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n        )\n        max_lex_arg = (\n            max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n        )\n\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZLexCount, [key, min_lex_arg, max_lex_arg]\n            ),\n        )\n\n    async def zscore(self, key: TEncodable, member: TEncodable) -&gt; Optional[float]:\n        \"\"\"\n        Returns the score of `member` in the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zscore/ for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            member (TEncodable): The member whose score is to be retrieved.\n\n        Returns:\n            Optional[float]: The score of the member.\n            If `member` does not exist in the sorted set, None is returned.\n            If `key` does not exist,  None is returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n                10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n            &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n                None\n        \"\"\"\n        return cast(\n            Optional[float],\n            await self._execute_command(RequestType.ZScore, [key, member]),\n        )\n\n    async def zmscore(\n        self,\n        key: TEncodable,\n        members: List[TEncodable],\n    ) -&gt; List[Optional[float]]:\n        \"\"\"\n        Returns the scores associated with the specified `members` in the sorted set stored at `key`.\n\n        See https://valkey.io/commands/zmscore for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            members (List[TEncodable]): A list of members in the sorted set.\n\n        Returns:\n            List[Optional[float]]: A list of scores corresponding to `members`.\n                If a member does not exist in the sorted set, the corresponding value in the list will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n                [1.0, None, 3.0]\n        \"\"\"\n        return cast(\n            List[Optional[float]],\n            await self._execute_command(RequestType.ZMScore, [key] + members),\n        )\n\n    async def zdiff(self, keys: List[TEncodable]) -&gt; List[bytes]:\n        \"\"\"\n        Returns the difference between the first sorted set and all the successive sorted sets.\n        To get the elements with their scores, see `zdiff_withscores`.\n\n        When in Cluster mode, all keys must map to the same hash slot.\n\n        See https://valkey.io/commands/zdiff for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: A list of elements representing the difference between the sorted sets.\n                If the first key does not exist, it is treated as an empty sorted set, and the command returns an\n                empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n            &gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n                [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZDiff, args),\n        )\n\n    async def zdiff_withscores(self, keys: List[TEncodable]) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores.\n        When in Cluster mode, all keys must map to the same hash slot.\n\n        See https://valkey.io/commands/zdiff for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted\n                sets.\n                If the first `key` does not exist, it is treated as an empty sorted set, and the command returns an\n                empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n            &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n            &gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n                {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n        \"\"\"\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(\n                RequestType.ZDiff, [str(len(keys))] + keys + [\"WITHSCORES\"]\n            ),\n        )\n\n    async def zdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Calculates the difference between the first sorted set and all the successive sorted sets at `keys` and stores\n        the difference as a sorted set to `destination`, overwriting it if it already exists. Non-existent keys are\n        treated as empty sets.\n        See https://valkey.io/commands/zdiffstore for more details.\n\n        Note:\n            When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key for the resulting sorted set.\n            keys (List[TEncodable]): The keys of the sorted sets to compare.\n\n        Returns:\n            int: The number of members in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n                2  # Indicates that two elements have been added to the sorted set at \"key1\".\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n                1  # Indicates that one element has been added to the sorted set at \"key2\".\n            &gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n                ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.ZDiffStore, [destination, str(len(keys))] + keys\n            ),\n        )\n\n    async def zinter(\n        self,\n        keys: List[TEncodable],\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and returns a list of intersecting elements.\n        To get the scores as well, see `zinter_withscores`.\n        To store the result in a key as a sorted set, see `zinterstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinter/ for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: The resulting array of intersecting elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n                [b'member1']\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZInter, args),\n        )\n\n    async def zinter_withscores(\n        self,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and returns a sorted set of intersecting elements with scores.\n        To get the elements only, see `zinter`.\n        To store the result in a key as a sorted set, see `zinterstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinter/ for more details.\n\n        Args:\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            Mapping[bytes, float]: The resulting sorted set with scores.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n                {b'member1': 20}  # \"member1\" with score of 20 is the result\n            &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n                {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n        args.append(\"WITHSCORES\")\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZInter, args),\n        )\n\n    async def zinterstore(\n        self,\n        destination: TEncodable,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Computes the intersection of sorted sets given by the specified `keys` and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n        To get the result directly, see `zinter_withscores`.\n\n        When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zinterstore/ for more details.\n\n        Args:\n            destination (TEncodable): The key of the destination sorted set.\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n            &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n                1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZInterStore, args),\n        )\n\n    async def zunion(\n        self,\n        keys: List[TEncodable],\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and returns a list of union elements.\n        To get the scores as well, see `zunion_withscores`.\n        To store the result in a key as a sorted set, see `zunionstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunion/ for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n\n        Returns:\n            List[bytes]: The resulting array of union elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n                [b'member1', b'member2']\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))]\n        args.extend(keys)\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZUnion, args),\n        )\n\n    async def zunion_withscores(\n        self,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; Mapping[bytes, float]:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and returns a sorted set of union elements with scores.\n        To get the elements only, see `zunion`.\n        To store the result in a key as a sorted set, see `zunionstore`.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunion/ for more details.\n\n        Args:\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            Mapping[bytes, float]: The resulting sorted set with scores.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n                {b'member1': 20, b'member2': 8.2}\n            &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n                {b'member1': 10.5, b'member2': 8.2}\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n        args.append(\"WITHSCORES\")\n        return cast(\n            Mapping[bytes, float],\n            await self._execute_command(RequestType.ZUnion, args),\n        )\n\n    async def zunionstore(\n        self,\n        destination: TEncodable,\n        keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n        aggregation_type: Optional[AggregationType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Computes the union of sorted sets given by the specified `keys` and stores the result in `destination`.\n        If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n        To get the result directly, see `zunion_withscores`.\n\n        When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n        See https://valkey.io/commands/zunionstore/ for more details.\n\n        Args:\n            destination (TEncodable): The key of the destination sorted set.\n            keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n                List[TEncodable] - for keys only.\n                List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n            aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n                when combining the scores of elements. See `AggregationType`.\n\n        Returns:\n            int: The number of elements in the resulting sorted set stored at `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n            &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n                2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 20, b'member2': 8.2}\n            &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n                2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n            &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n                {b'member1': 10.5, b'member2': 8.2}\n        \"\"\"\n        args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZUnionStore, args),\n        )\n\n    async def zrandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random member from the sorted set stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n\n        Returns:\n            Optional[bytes]: A random member from the sorted set.\n                If the sorted set does not exist or is empty, the response will be None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n                b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n                None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.ZRandMember, [key]),\n        )\n\n    async def zrandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Retrieves up to the absolute value of `count` random members from the sorted set stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[bytes]: A list of members from the sorted set.\n                If the sorted set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n                [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n            &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n                []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count)]\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.ZRandMember, args),\n        )\n\n    async def zrandmember_withscores(\n        self, key: TEncodable, count: int\n    ) -&gt; List[List[Union[bytes, float]]]:\n        \"\"\"\n        Retrieves up to the absolute value of `count` random members along with their scores from the sorted set\n        stored at 'key'.\n\n        See https://valkey.io/commands/zrandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[List[Union[bytes, float]]]: A list of `[member, score]` lists, where `member` is a random member from\n                the sorted set and `score` is the associated score.\n                If the sorted set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n                [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n            &gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n                []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        args: List[TEncodable] = [key, str(count), \"WITHSCORES\"]\n        return cast(\n            List[List[Union[bytes, float]]],\n            await self._execute_command(RequestType.ZRandMember, args),\n        )\n\n    async def zmpop(\n        self,\n        keys: List[TEncodable],\n        filter: ScoreFilter,\n        count: Optional[int] = None,\n    ) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n        \"\"\"\n        Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n        that they are given.\n\n        The optional `count` argument can be used to specify the number of elements to pop, and is\n        set to 1 by default.\n\n        The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n        See https://valkey.io/commands/zmpop for more details.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            filter (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n                members with the lowest/highest scores accordingly.\n            count (Optional[int]): The number of elements to pop.\n\n        Returns:\n            Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n                which elements were popped, and a member-score mapping of the popped elements. If no members could be\n                popped, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n            &gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n                [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [str(len(keys))] + keys + [filter.value]\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        return cast(\n            Optional[List[Union[bytes, Mapping[bytes, float]]]],\n            await self._execute_command(RequestType.ZMPop, args),\n        )\n\n    async def bzmpop(\n        self,\n        keys: List[TEncodable],\n        modifier: ScoreFilter,\n        timeout: float,\n        count: Optional[int] = None,\n    ) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n        \"\"\"\n        Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n        that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.\n\n        The optional `count` argument can be used to specify the number of elements to pop, and is set to 1 by default.\n\n        The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n        `BZMPOP` is the blocking variant of `ZMPOP`.\n\n        See https://valkey.io/commands/bzmpop for more details.\n\n        Notes:\n            1. When in cluster mode, all `keys` must map to the same hash slot.\n            2. `BZMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets.\n            modifier (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n                members with the lowest/highest scores accordingly.\n            timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will\n                block indefinitely.\n            count (Optional[int]): The number of elements to pop.\n\n        Returns:\n            Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n                which elements were popped, and a member-score mapping of the popped elements. If no members could be\n                popped and the timeout expired, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n            &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n            &gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n                [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(timeout), str(len(keys))] + keys + [modifier.value]\n        if count is not None:\n            args = args + [\"COUNT\", str(count)]\n\n        return cast(\n            Optional[List[Union[bytes, Mapping[bytes, float]]]],\n            await self._execute_command(RequestType.BZMPop, args),\n        )\n\n    async def zintercard(\n        self, keys: List[TEncodable], limit: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Returns the cardinality of the intersection of the sorted sets specified by `keys`. When provided with the\n        optional `limit` argument, if the intersection cardinality reaches `limit` partway through the computation, the\n        algorithm will exit early and yield `limit` as the cardinality.\n\n        See https://valkey.io/commands/zintercard for more details.\n\n        Args:\n            keys (List[TEncodable]): The keys of the sorted sets to intersect.\n            limit (Optional[int]): An optional argument that can be used to specify a maximum number for the\n                intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.\n\n        Note:\n            When in cluster mode, all `keys` must map to the same hash slot.\n\n        Returns:\n            int: The cardinality of the intersection of the given sorted sets, or the `limit` if reached.\n\n        Examples:\n            &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n            &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n            &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n                2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n            &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n                1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = [str(len(keys))] + keys\n        if limit is not None:\n            args.extend([\"LIMIT\", str(limit)])\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.ZInterCard, args),\n        )\n\n    async def script_show(self, sha1: TEncodable) -&gt; bytes:\n        \"\"\"\n        Returns the original source code of a script in the script cache.\n\n        See https://valkey.io/commands/script-show for more details.\n\n        Args:\n            sha1 (TEncodable): The SHA1 digest of the script.\n\n        Returns:\n            bytes: The original source code of the script, if present in the cache.\n                If the script is not found in the cache, an error is thrown.\n\n        Example:\n            &gt;&gt;&gt; await client.script_show(script.get_hash())\n                b\"return { KEYS[1], ARGV[1] }\"\n\n        Since: Valkey version 8.0.0.\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.ScriptShow, [sha1]))\n\n    async def pfadd(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Adds all elements to the HyperLogLog data structure stored at the specified `key`.\n        Creates a new structure if the `key` does not exist.\n        When no elements are provided, and `key` exists and is a HyperLogLog, then no operation is performed.\n\n        See https://valkey.io/commands/pfadd/ for more details.\n\n        Args:\n            key (TEncodable): The key of the HyperLogLog data structure to add elements into.\n            elements (List[TEncodable]): A list of members to add to the HyperLogLog stored at `key`.\n\n        Returns:\n            int: If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is\n            altered, then returns 1. Otherwise, returns 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n                1 # A data structure was created or modified\n            &gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n                1 # A new empty data structure was created\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PfAdd, [key] + elements),\n        )\n\n    async def pfcount(self, keys: List[TEncodable]) -&gt; int:\n        \"\"\"\n        Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or\n        calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.\n\n        See https://valkey.io/commands/pfcount for more details.\n\n        Note:\n            When in Cluster mode, all `keys` must map to the same hash slot.\n\n        Args:\n            keys (List[TEncodable]): The keys of the HyperLogLog data structures to be analyzed.\n\n        Returns:\n            int: The approximated cardinality of given HyperLogLog data structures.\n                The cardinality of a key that does not exist is 0.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n                4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.PfCount, keys),\n        )\n\n    async def pfmerge(\n        self, destination: TEncodable, source_keys: List[TEncodable]\n    ) -&gt; TOK:\n        \"\"\"\n        Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one\n        of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.\n\n        See https://valkey.io/commands/pfmerge for more details.\n\n        Note:\n            When in Cluster mode, all keys in `source_keys` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key of the destination HyperLogLog where the merged data sets will be stored.\n            source_keys (List[TEncodable]): The keys of the HyperLogLog structures to be merged.\n\n        Returns:\n            OK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n            &gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n            &gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n                OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n            &gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n                3  # The approximated cardinality of \"new_hll\" is 3.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.PfMerge, [destination] + source_keys\n            ),\n        )\n\n    async def bitcount(\n        self, key: TEncodable, options: Optional[OffsetOptions] = None\n    ) -&gt; int:\n        \"\"\"\n        Counts the number of set bits (population counting) in the string stored at `key`. The `options` argument can\n        optionally be provided to count the number of bits in a specific string interval.\n\n        See https://valkey.io/commands/bitcount for more details.\n\n        Args:\n            key (TEncodable): The key for the string to count the set bits of.\n            options (Optional[OffsetOptions]): The offset options.\n\n        Returns:\n            int: If `options` is provided, returns the number of set bits in the string interval specified by `options`.\n                If `options` is not provided, returns the number of set bits in the string stored at `key`.\n                Otherwise, if `key` is missing, returns `0` as it is treated as an empty string.\n\n        Examples:\n            &gt;&gt;&gt; await client.bitcount(\"my_key1\")\n                2  # The string stored at \"my_key1\" contains 2 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n                8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n                2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n            &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n                1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n            &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n                1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        if options is not None:\n            args.extend(options.to_args())\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitCount, args),\n        )\n\n    async def setbit(self, key: TEncodable, offset: int, value: int) -&gt; int:\n        \"\"\"\n        Sets or clears the bit at `offset` in the string value stored at `key`. The `offset` is a zero-based index,\n        with `0` being the first element of the list, `1` being the next element, and so on. The `offset` must be less\n        than `2^32` and greater than or equal to `0`. If a key is non-existent then the bit at `offset` is set to\n        `value` and the preceding bits are set to `0`.\n\n        See https://valkey.io/commands/setbit for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            offset (int): The index of the bit to be set.\n            value (int): The bit value to set at `offset`. The value must be `0` or `1`.\n\n        Returns:\n            int: The bit value that was previously stored at `offset`.\n\n        Examples:\n            &gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n                0  # The second bit value was 0 before setting to 1.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.SetBit, [key, str(offset), str(value)]\n            ),\n        )\n\n    async def getbit(self, key: TEncodable, offset: int) -&gt; int:\n        \"\"\"\n        Returns the bit value at `offset` in the string value stored at `key`.\n        `offset` should be greater than or equal to zero.\n\n        See https://valkey.io/commands/getbit for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            offset (int): The index of the bit to return.\n\n        Returns:\n            int: The bit at the given `offset` of the string. Returns `0` if the key is empty or if the `offset` exceeds\n                the length of the string.\n\n        Examples:\n            &gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n                1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.GetBit, [key, str(offset)]),\n        )\n\n    async def bitpos(\n        self, key: TEncodable, bit: int, start: Optional[int] = None\n    ) -&gt; int:\n        \"\"\"\n        Returns the position of the first bit matching the given `bit` value. The optional starting offset\n        `start` is a zero-based index, with `0` being the first byte of the list, `1` being the next byte and so on.\n        The offset can also be a negative number indicating an offset starting at the end of the list, with `-1` being\n        the last byte of the list, `-2` being the penultimate, and so on.\n\n        See https://valkey.io/commands/bitpos for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            bit (int): The bit value to match. Must be `0` or `1`.\n            start (Optional[int]): The starting offset.\n\n        Returns:\n            int: The position of the first occurrence of `bit` in the binary value of the string held at `key`.\n                If `start` was provided, the search begins at the offset indicated by `start`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n            &gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n                1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n            &gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n                10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n        \"\"\"\n        args = [key, str(bit)] if start is None else [key, str(bit), str(start)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitPos, args),\n        )\n\n    async def bitpos_interval(\n        self,\n        key: TEncodable,\n        bit: int,\n        start: int,\n        end: int,\n        index_type: Optional[BitmapIndexType] = None,\n    ) -&gt; int:\n        \"\"\"\n        Returns the position of the first bit matching the given `bit` value. The offsets are zero-based indexes, with\n        `0` being the first element of the list, `1` being the next, and so on. These offsets can also be negative\n        numbers indicating offsets starting at the end of the list, with `-1` being the last element of the list, `-2`\n        being the penultimate, and so on.\n\n        If you are using Valkey 7.0.0 or above, the optional `index_type` can also be provided to specify whether the\n        `start` and `end` offsets specify BIT or BYTE offsets. If `index_type` is not provided, BYTE offsets\n        are assumed. If BIT is specified, `start=0` and `end=2` means to look at the first three bits. If BYTE is\n        specified, `start=0` and `end=2` means to look at the first three bytes.\n\n        See https://valkey.io/commands/bitpos for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            bit (int): The bit value to match. Must be `0` or `1`.\n            start (int): The starting offset.\n            end (int): The ending offset.\n            index_type (Optional[BitmapIndexType]): The index offset type. This option can only be specified if you are\n                using Valkey version 7.0.0 or above. Could be either `BitmapIndexType.BYTE` or `BitmapIndexType.BIT`.\n                If no index type is provided, the indexes will be assumed to be byte indexes.\n\n        Returns:\n            int: The position of the first occurrence from the `start` to the `end` offsets of the `bit` in the binary\n                value of the string held at `key`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n            &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n                10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n            &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n                7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n        \"\"\"\n        if index_type is not None:\n            args = [key, str(bit), str(start), str(end), index_type.value]\n        else:\n            args = [key, str(bit), str(start), str(end)]\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.BitPos, args),\n        )\n\n    async def bitop(\n        self,\n        operation: BitwiseOperation,\n        destination: TEncodable,\n        keys: List[TEncodable],\n    ) -&gt; int:\n        \"\"\"\n        Perform a bitwise operation between multiple keys (containing string values) and store the result in the\n        `destination`.\n\n        See https://valkey.io/commands/bitop for more details.\n\n        Note:\n            When in cluster mode, `destination` and all `keys` must map to the same hash slot.\n\n        Args:\n            operation (BitwiseOperation): The bitwise operation to perform.\n            destination (TEncodable): The key that will store the resulting string.\n            keys (List[TEncodable]): The list of keys to perform the bitwise operation on.\n\n        Returns:\n            int: The size of the string stored in `destination`.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n            &gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n                1  # The size of the resulting string stored in \"destination\" is 1\n            &gt;&gt;&gt; await client.get(\"destination\")\n                \"@\"  # \"@\" has binary value 01000000\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(\n                RequestType.BitOp, [operation.value, destination] + keys\n            ),\n        )\n\n    async def bitfield(\n        self, key: TEncodable, subcommands: List[BitFieldSubCommands]\n    ) -&gt; List[Optional[int]]:\n        \"\"\"\n        Reads or modifies the array of bits representing the string that is held at `key` based on the specified\n        `subcommands`.\n\n        See https://valkey.io/commands/bitfield for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            subcommands (List[BitFieldSubCommands]): The subcommands to be performed on the binary value of the string\n                at `key`, which could be any of the following:\n                    - `BitFieldGet`\n                    - `BitFieldSet`\n                    - `BitFieldIncrBy`\n                    - `BitFieldOverflow`\n\n        Returns:\n            List[Optional[int]]: An array of results from the executed subcommands:\n                - `BitFieldGet` returns the value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldSet` returns the old value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldIncrBy` returns the new value in `BitOffset` or `BitOffsetMultiplier`.\n                - `BitFieldOverflow` determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or\n                  underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list\n                  response.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n                [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n        \"\"\"\n        args = [key] + _create_bitfield_args(subcommands)\n        return cast(\n            List[Optional[int]],\n            await self._execute_command(RequestType.BitField, args),\n        )\n\n    async def bitfield_read_only(\n        self, key: TEncodable, subcommands: List[BitFieldGet]\n    ) -&gt; List[int]:\n        \"\"\"\n        Reads the array of bits representing the string that is held at `key` based on the specified `subcommands`.\n\n        See https://valkey.io/commands/bitfield_ro for more details.\n\n        Args:\n            key (TEncodable): The key of the string.\n            subcommands (List[BitFieldGet]): The \"GET\" subcommands to be performed.\n\n        Returns:\n            List[int]: An array of results from the \"GET\" subcommands.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n            &gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n                [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n\n        Since: Valkey version 6.0.0.\n        \"\"\"\n        args = [key] + _create_bitfield_read_only_args(subcommands)\n        return cast(\n            List[int],\n            await self._execute_command(RequestType.BitFieldReadOnly, args),\n        )\n\n    async def object_encoding(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns the internal encoding for the Valkey object stored at `key`.\n\n        See https://valkey.io/commands/object-encoding for more details.\n\n        Args:\n            key (TEncodable): The `key` of the object to get the internal encoding of.\n\n        Returns:\n            Optional[bytes]: If `key` exists, returns the internal encoding of the object stored at\n                `key` as a bytes string. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n                b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.ObjectEncoding, [key]),\n        )\n\n    async def object_freq(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the logarithmic access frequency counter of a Valkey object stored at `key`.\n\n        See https://valkey.io/commands/object-freq for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the logarithmic access frequency counter of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the logarithmic access frequency counter of the object stored at `key` as an\n                integer. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_freq(\"my_hash\")\n                2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectFreq, [key]),\n        )\n\n    async def object_idletime(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the time in seconds since the last access to the value stored at `key`.\n\n        See https://valkey.io/commands/object-idletime for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the idle time of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the idle time in seconds. Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n                13  # \"my_hash\" was last accessed 13 seconds ago.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectIdleTime, [key]),\n        )\n\n    async def object_refcount(self, key: TEncodable) -&gt; Optional[int]:\n        \"\"\"\n        Returns the reference count of the object stored at `key`.\n\n        See https://valkey.io/commands/object-refcount for more details.\n\n        Args:\n            key (TEncodable): The key of the object to get the reference count of.\n\n        Returns:\n            Optional[int]: If `key` exists, returns the reference count of the object stored at `key` as an integer.\n                Otherwise, returns None.\n\n        Examples:\n            &gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n                2  # \"my_hash\" has a reference count of 2.\n        \"\"\"\n        return cast(\n            Optional[int],\n            await self._execute_command(RequestType.ObjectRefCount, [key]),\n        )\n\n    async def srandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random element from the set value stored at 'key'.\n\n        See https://valkey.io/commands/srandmember for more details.\n\n        Args:\n            key (TEncodable): The key from which to retrieve the set member.\n\n        Returns:\n            Optional[bytes]: A random element from the set, or None if 'key' does not exist.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.srandmember(b\"my_set\")\n                b\"member1\"  # \"member1\" is a random member of \"my_set\".\n            &gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n                None  # \"non_existing_set\" is not an existing key, so None was returned.\n        \"\"\"\n        args: List[TEncodable] = [key]\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.SRandMember, args),\n        )\n\n    async def srandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n        \"\"\"\n        Returns one or more random elements from the set value stored at 'key'.\n\n        See https://valkey.io/commands/srandmember for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            count (int): The number of members to return.\n                If `count` is positive, returns unique members.\n                If `count` is negative, allows for duplicates members.\n\n        Returns:\n            List[bytes]: A list of members from the set.\n                If the set does not exist or is empty, the response will be an empty list.\n\n        Examples:\n            &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n            &gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n                [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n            &gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n                []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.SRandMember, [key, str(count)]),\n        )\n\n    async def getex(\n        self,\n        key: TEncodable,\n        expiry: Optional[ExpiryGetEx] = None,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Get the value of `key` and optionally set its expiration. `GETEX` is similar to `GET`.\n        See https://valkey.io/commands/getex for more details.\n\n        Args:\n            key (TEncodable): The key to get.\n            expiry (Optional[ExpiryGetEx], optional): set expiriation to the given key.\n                Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `PERSIST`] in the Valkey API.\n\n        Returns:\n            Optional[bytes]:\n                If `key` exists, return the value stored at `key`\n                If `key` does not exist, return `None`\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\")\n                'OK'\n            &gt;&gt;&gt; await client.getex(\"key\")\n                b'value'\n            &gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n                b'value'\n            &gt;&gt;&gt; time.sleep(1)\n            &gt;&gt;&gt; await client.getex(b\"key\")\n                None\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args = [key]\n        if expiry is not None:\n            args.extend(expiry.get_cmd_args())\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.GetEx, args),\n        )\n\n    async def dump(\n        self,\n        key: TEncodable,\n    ) -&gt; Optional[bytes]:\n        \"\"\"\n        Serialize the value stored at `key` in a Valkey-specific format and return it to the user.\n\n        See https://valkey.io/commands/dump for more details.\n\n        Args:\n            key (TEncodable): The `key` to serialize.\n\n        Returns:\n            Optional[bytes]: The serialized value of the data stored at `key`.\n                If `key` does not exist, `None` will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.dump(\"key\")\n                b\"value\" # The serialized value stored at `key`.\n            &gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n                None # Non-existing key will return `None`.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.Dump, [key]),\n        )\n\n    async def restore(\n        self,\n        key: TEncodable,\n        ttl: int,\n        value: TEncodable,\n        replace: bool = False,\n        absttl: bool = False,\n        idletime: Optional[int] = None,\n        frequency: Optional[int] = None,\n    ) -&gt; TOK:\n        \"\"\"\n        Create a `key` associated with a `value` that is obtained by deserializing the provided\n        serialized `value` obtained via `dump`.\n\n        See https://valkey.io/commands/restore for more details.\n\n        Note: `IDLETIME` and `FREQ` modifiers cannot be set at the same time.\n\n        Args:\n            key (TEncodable): The `key` to create.\n            ttl (int): The expiry time (in milliseconds). If `0`, the `key` will persist.\n            value (TEncodable) The serialized value to deserialize and assign to `key`.\n            replace (bool): Set to `True` to replace the key if it exists.\n            absttl (bool): Set to `True` to specify that `ttl` represents an absolute Unix\n                timestamp (in milliseconds).\n            idletime (Optional[int]): Set the `IDLETIME` option with object idletime to the given key.\n            frequency (Optional[int]): Set the `FREQ` option with object frequency to the given key.\n\n        Returns:\n            OK: If the `key` was successfully restored with a `value`.\n\n        Examples:\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n                OK # Indicates restore `newKey` without any ttl expiry nor any option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n                OK # Indicates restore `newKey` with `REPLACE` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n                OK # Indicates restore `newKey` with `ABSTTL` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n                OK # Indicates restore `newKey` with `IDLETIME` option\n            &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n                OK # Indicates restore `newKey` with `FREQ` option\n        \"\"\"\n        args = [key, str(ttl), value]\n        if replace is True:\n            args.append(\"REPLACE\")\n        if absttl is True:\n            args.append(\"ABSTTL\")\n        if idletime is not None:\n            args.extend([\"IDLETIME\", str(idletime)])\n        if frequency is not None:\n            args.extend([\"FREQ\", str(frequency)])\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.Restore, args),\n        )\n\n    async def sscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a set.\n\n        See https://valkey.io/commands/sscan for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a\n                subset of the set then there could be a case where the result is empty although there are items that\n                match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n                only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the set.\n                `COUNT` could be ignored until the set is large enough for the `SCAN` commands to represent the results\n                as compact single-allocation packed encoding.\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the set held by `key`.\n                The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n                returned on the last iteration of the set. The second element is always an `Array` of the subset of the\n                set held in `key`.\n\n        Examples:\n            # Assume \"key\" contains a set with 130 members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor:  48\n            Members: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\n            Cursor: 24\n            Members: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\n            Cursor: 0\n            Members: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.SScan, args),\n        )\n\n    async def zscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        no_scores: bool = False,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a sorted set.\n\n        See https://valkey.io/commands/zscan for more details.\n\n        Args:\n            key (TEncodable): The key of the sorted set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return\n                only a subset of the sorted set then there could be a case where the result is empty although there are\n                items that match the pattern specified. This is due to the default `COUNT` being `10` which indicates\n                that it will only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the\n                sorted set. `COUNT` could be ignored until the sorted set is large enough for the `SCAN` commands to\n                represent the results as compact single-allocation packed encoding.\n            no_scores (bool): If `True`, the command will not return scores associated with the members. Since Valkey \"8.0.0\".\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the sorted set held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the sorted set. The second element is always an `Array` of the subset\n            of the sorted set held in `key`. The `Array` in the second element is a flattened series of\n            `String` pairs, where the value is at even indices and the score is at odd indices.\n            If `no_scores` is set to`True`, the second element will only contain the members without scores.\n\n        Examples:\n            # Assume \"key\" contains a sorted set with multiple members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 123\n            Members: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\n            Cursor: 47\n            Members: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\n            Cursor: 0\n            Members: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n\n            # Using no-score\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n            ...     new_cursor = str(result[0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 123\n            Members: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\n            Cursor: 47\n            Members: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\n            Cursor: 0\n            Members: [b'value 55', b'value 24', b'value 90', b'value 113']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n        if no_scores:\n            args.append(\"NOSCORES\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.ZScan, args),\n        )\n\n    async def hscan(\n        self,\n        key: TEncodable,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        no_values: bool = False,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Iterates incrementally over a hash.\n\n        See https://valkey.io/commands/hscan for more details.\n\n        Args:\n            key (TEncodable): The key of the set.\n            cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n                the search.\n            match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n                strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a\n                subset of the hash then there could be a case where the result is empty although there are items that\n                match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n                only fetch and match `10` items from the list.\n            count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the hash.\n                `COUNT` could be ignored until the hash is large enough for the `SCAN` commands to represent the results\n                as compact single-allocation packed encoding.\n            no_values (bool): If `True`, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the hash held by `key`.\n                The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n                returned on the last iteration of the hash. The second element is always an `Array` of the subset of the\n                hash held in `key`. The `Array` in the second element is a flattened series of `String` pairs,\n                where the value is at even indices and the score is at odd indices.\n                If `no_values` is set to `True`, the second element will only contain the fields without the values.\n\n        Examples:\n            # Assume \"key\" contains a hash with multiple members\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 1\n            Members: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\n            Cursor: 39\n            Members: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\n            Cursor: 0\n            Members: [b'field 420', b'value 420', b'field 221', b'value 221']\n\n            # Use no-values\n            &gt;&gt;&gt; result_cursor = \"0\"\n            &gt;&gt;&gt; while True:\n            ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n            ...     new_cursor = str(result [0])\n            ...     print(\"Cursor: \", new_cursor)\n            ...     print(\"Members: \", result[1])\n            ...     if new_cursor == \"0\":\n            ...         break\n            ...     result_cursor = new_cursor\n            Cursor: 1\n            Members: [b'field 79',b'field 20', b'field 115']\n            Cursor: 39\n            Members: [b'field 63', b'field 293', b'field 162']\n            Cursor: 0\n            Members: [b'field 420', b'field 221']\n        \"\"\"\n        args: List[TEncodable] = [key, cursor]\n        if match is not None:\n            args += [\"MATCH\", match]\n        if count is not None:\n            args += [\"COUNT\", str(count)]\n        if no_values:\n            args.append(\"NOVALUES\")\n\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.HScan, args),\n        )\n\n    async def fcall(\n        self,\n        function: TEncodable,\n        keys: Optional[List[TEncodable]] = None,\n        arguments: Optional[List[TEncodable]] = None,\n    ) -&gt; TResult:\n        \"\"\"\n        Invokes a previously loaded function.\n        See https://valkey.io/commands/fcall/ for more details.\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n        Args:\n            function (TEncodable): The function name.\n            keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct\n                execution of functions, both in standalone and clustered deployments, all names of keys\n                that a function accesses must be explicitly provided as `keys`.\n            arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n                should not represent names of keys.\n        Returns:\n            TResult:\n                The invoked function's return value.\n        Example:\n            &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")\n                b'new_value' # Returns the function's return value.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = []\n        if keys is not None:\n            args.extend([function, str(len(keys))] + keys)\n        else:\n            args.extend([function, str(0)])\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TResult,\n            await self._execute_command(RequestType.FCall, args),\n        )\n\n    async def fcall_ro(\n        self,\n        function: TEncodable,\n        keys: Optional[List[TEncodable]] = None,\n        arguments: Optional[List[TEncodable]] = None,\n    ) -&gt; TResult:\n        \"\"\"\n        Invokes a previously loaded read-only function.\n\n        See https://valkey.io/commands/fcall_ro for more details.\n\n        When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n        Args:\n            function (TEncodable): The function name.\n            keys (List[TEncodable]): An `array` of keys accessed by the function. To ensure the correct\n                execution of functions, all names of keys that a function accesses must be\n                explicitly provided as `keys`.\n            arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n                represent names of keys.\n\n        Returns:\n            TResult: The return value depends on the function that was executed.\n\n        Examples:\n            &gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n                    \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n                42 # The return value on the function that was executed\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = []\n        if keys is not None:\n            args.extend([function, str(len(keys))] + keys)\n        else:\n            args.extend([function, str(0)])\n        if arguments is not None:\n            args.extend(arguments)\n        return cast(\n            TResult,\n            await self._execute_command(RequestType.FCallReadOnly, args),\n        )\n\n    async def watch(self, keys: List[TEncodable]) -&gt; TOK:\n        \"\"\"\n        Marks the given keys to be watched for conditional execution of a transaction. Transactions\n        will only execute commands if the watched keys are not modified before execution of the\n        transaction.\n\n        See https://valkey.io/commands/watch for more details.\n\n        Note:\n            When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n        Args:\n            keys (List[TEncodable]): The keys to watch.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.watch(\"sampleKey\")\n                'OK'\n            &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n            &gt;&gt;&gt; await client.exec(transaction)\n                'OK' # Executes successfully and keys are unwatched.\n\n            &gt;&gt;&gt; await client.watch(\"sampleKey\")\n                'OK'\n            &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n            &gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n                'OK'\n            &gt;&gt;&gt; await client.exec(transaction)\n                None  # None is returned when the watched key is modified before transaction execution.\n        \"\"\"\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.Watch, keys),\n        )\n\n    @dataclass\n    class PubSubMsg:\n        \"\"\"\n        Describes the incoming pubsub message\n\n        Attributes:\n            message (TEncodable): Incoming message.\n            channel (TEncodable): Name of an channel that triggered the message.\n            pattern (Optional[TEncodable]): Pattern that triggered the message.\n        \"\"\"\n\n        message: TEncodable\n        channel: TEncodable\n        pattern: Optional[TEncodable]\n\n    async def get_pubsub_message(self) -&gt; PubSubMsg:\n        \"\"\"\n        Returns the next pubsub message.\n        Throws WrongConfiguration in cases:\n        1. No pubsub subscriptions are configured for the client\n        2. Callback is configured with the pubsub subsciptions\n\n        See https://valkey.io/docs/topics/pubsub/ for more details.\n\n        Returns:\n            PubSubMsg: The next pubsub message\n\n        Examples:\n            &gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n        \"\"\"\n        ...\n\n    def try_get_pubsub_message(self) -&gt; Optional[PubSubMsg]:\n        \"\"\"\n        Tries to return the next pubsub message.\n        Throws WrongConfiguration in cases:\n        1. No pubsub subscriptions are configured for the client\n        2. Callback is configured with the pubsub subsciptions\n\n        See https://valkey.io/docs/topics/pubsub/ for more details.\n\n        Returns:\n            Optional[PubSubMsg]: The next pubsub message or None\n\n        Examples:\n            &gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n        \"\"\"\n        ...\n\n    async def lcs(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n    ) -&gt; bytes:\n        \"\"\"\n        Returns the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string.\n            key2 (TEncodable): The key that stores the second string.\n\n        Returns:\n            A Bytes String containing the longest common subsequence between the 2 strings.\n            An empty String is returned if the keys do not exist or have no common subsequences.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n                b'OK'\n            &gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n                b'acd'\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2]\n\n        return cast(\n            bytes,\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lcs_len(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n    ) -&gt; int:\n        \"\"\"\n        Returns the length of the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string value.\n            key2 (TEncodable): The key that stores the second string value.\n\n        Returns:\n            The length of the longest common subsequence between the 2 strings.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n                'OK'\n            &gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n                3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2, \"LEN\"]\n\n        return cast(\n            int,\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lcs_idx(\n        self,\n        key1: TEncodable,\n        key2: TEncodable,\n        min_match_len: Optional[int] = None,\n        with_match_len: Optional[bool] = False,\n    ) -&gt; Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]:\n        \"\"\"\n        Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.\n\n        Note that this is different than the longest common string algorithm, since\n        matching characters in the two strings do not need to be contiguous.\n\n        For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n        from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n        See https://valkey.io/commands/lcs for more details.\n\n        Args:\n            key1 (TEncodable): The key that stores the first string value.\n            key2 (TEncodable): The key that stores the second string value.\n            min_match_len (Optional[int]): The minimum length of matches to include in the result.\n            with_match_len (Optional[bool]): If True, include the length of the substring matched for each substring.\n\n        Returns:\n            A Mapping containing the indices of the longest common subsequence between the\n            2 strings and the length of the longest common subsequence. The resulting map contains two\n            keys, \"matches\" and \"len\":\n                - \"len\" is mapped to the length of the longest common subsequence between the 2 strings.\n                - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that\n                  represent the location of the common subsequences in the strings held by key1 and key2,\n                  with the length of the match after each matches, if with_match_len is enabled.\n\n        Examples:\n            &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n                'OK'\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n                {\n                    b'matches': [\n                        [\n                            [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                            [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n                        ],\n                        [\n                            [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                            [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n                        ],\n                    ],\n                    b'len': 7  # length of the entire longest common subsequence\n                }\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n                {\n                    b'matches': [\n                        [\n                            [4, 7],\n                            [5, 8],\n                        ],\n                        # the other match with a length of 3 is excluded\n                    ],\n                    b'len': 7\n                }\n            &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n                {\n                    b'matches': [\n                        [\n                            [4, 7],\n                            [5, 8],\n                            4,  # length of this match (b\"1234\")\n                        ],\n                        [\n                            [1, 3],\n                            [0, 2],\n                            3,  # length of this match (b\"bcd\")\n                        ],\n                    ],\n                    b'len': 7\n                }\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [key1, key2, \"IDX\"]\n\n        if min_match_len is not None:\n            args.extend([\"MINMATCHLEN\", str(min_match_len)])\n\n        if with_match_len:\n            args.append(\"WITHMATCHLEN\")\n\n        return cast(\n            Mapping[bytes, Union[List[List[Union[List[int], int]]], int]],\n            await self._execute_command(RequestType.LCS, args),\n        )\n\n    async def lpos(\n        self,\n        key: TEncodable,\n        element: TEncodable,\n        rank: Optional[int] = None,\n        count: Optional[int] = None,\n        max_len: Optional[int] = None,\n    ) -&gt; Union[int, List[int], None]:\n        \"\"\"\n        Returns the index or indexes of element(s) matching `element` in the `key` list. If no match is found,\n        None is returned.\n\n        See https://valkey.io/commands/lpos for more details.\n\n        Args:\n            key (TEncodable): The name of the list.\n            element (TEncodable): The value to search for within the list.\n            rank (Optional[int]): The rank of the match to return.\n            count (Optional[int]): The number of matches wanted. A `count` of 0 returns all the matches.\n            max_len (Optional[int]): The maximum number of comparisons to make between the element and the items\n                                     in the list. A `max_len` of 0 means unlimited amount of comparisons.\n\n        Returns:\n            Union[int, List[int], None]: The index of the first occurrence of `element`,\n            or None if `element` is not in the list.\n            With the `count` option, a list of indices of matching elements will be returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n            &gt;&gt;&gt; await client.lpos(key, 'c')\n                2\n            &gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n                6\n            &gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n                7\n            &gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n                [2, 6]\n            &gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n                [2, 6, 7]\n\n        Since: Valkey version 6.0.6.\n        \"\"\"\n        args: List[TEncodable] = [key, element]\n\n        if rank is not None:\n            args.extend([\"RANK\", str(rank)])\n\n        if count is not None:\n            args.extend([\"COUNT\", str(count)])\n\n        if max_len is not None:\n            args.extend([\"MAXLEN\", str(max_len)])\n\n        return cast(\n            Union[int, List[int], None],\n            await self._execute_command(RequestType.LPos, args),\n        )\n\n    async def pubsub_channels(\n        self, pattern: Optional[TEncodable] = None\n    ) -&gt; List[bytes]:\n        \"\"\"\n        Lists the currently active channels.\n        The command is routed to all nodes, and aggregates the response to a single array.\n\n        See https://valkey.io/commands/pubsub-channels for more details.\n\n        Args:\n            pattern (Optional[TEncodable]): A glob-style pattern to match active channels.\n                                If not provided, all active channels are returned.\n\n        Returns:\n            List[bytes]: A list of currently active channels matching the given pattern.\n                    If no pattern is specified, all active channels are returned.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_channels()\n                [b\"channel1\", b\"channel2\"]\n\n            &gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n                [b\"news.sports\", \"news.weather\"]\n        \"\"\"\n\n        return cast(\n            List[bytes],\n            await self._execute_command(\n                RequestType.PubSubChannels, [pattern] if pattern else []\n            ),\n        )\n\n    async def pubsub_numpat(self) -&gt; int:\n        \"\"\"\n        Returns the number of unique patterns that are subscribed to by clients.\n\n        Note: This is the total number of unique patterns all the clients are subscribed to,\n        not the count of clients subscribed to patterns.\n        The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.\n\n        See https://valkey.io/commands/pubsub-numpat for more details.\n\n        Returns:\n            int: The number of unique patterns.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_numpat()\n                3\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.PubSubNumPat, []))\n\n    async def pubsub_numsub(\n        self, channels: Optional[List[TEncodable]] = None\n    ) -&gt; Mapping[bytes, int]:\n        \"\"\"\n        Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.\n\n        Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n        The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n        See https://valkey.io/commands/pubsub-numsub for more details.\n\n        Args:\n            channels (Optional[List[TEncodable]]): The list of channels to query for the number of subscribers.\n                                            If not provided, returns an empty map.\n\n        Returns:\n            Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.\n\n        Examples:\n            &gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n                {b'channel1': 3, b'channel2': 5}\n\n            &gt;&gt;&gt; await client.pubsub_numsub()\n                {}\n        \"\"\"\n        return cast(\n            Mapping[bytes, int],\n            await self._execute_command(\n                RequestType.PubSubNumSub, channels if channels else []\n            ),\n        )\n\n    async def sort(\n        self,\n        key: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n        The `sort` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n        This command is routed to primary nodes only.\n        To store the result into a new key, see `sort_store`.\n\n        Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            List[Optional[bytes]]: Returns a list of sorted elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n            &gt;&gt;&gt; await client.sort(\"mylist\")\n                [b'1', b'2', b'3']\n            &gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n                [b'3', b'2', b'1']\n            &gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n            &gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n                [b'2', b'2', b'3']\n            &gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n            &gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n            &gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n            &gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n                [b'Bob', b'Alice']\n        \"\"\"\n        args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n        result = await self._execute_command(RequestType.Sort, args)\n        return cast(List[Optional[bytes]], result)\n\n    async def sort_ro(\n        self,\n        key: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; List[Optional[bytes]]:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n        The `sort_ro` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n        This command is routed depending on the client's `ReadFrom` strategy.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_pattern (Optional[TEncodable]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            List[Optional[bytes]]: Returns a list of sorted elements.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n            &gt;&gt;&gt; await client.sort_ro(\"mylist\")\n                [b'1', b'2', b'3']\n            &gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n                [b'3', b'2', b'1']\n            &gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n            &gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n                [b'2', b'2', b'3']\n            &gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n            &gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n            &gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n            &gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n                [b'Bob', b'Alice']\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n        result = await self._execute_command(RequestType.SortReadOnly, args)\n        return cast(List[Optional[bytes]], result)\n\n    async def sort_store(\n        self,\n        key: TEncodable,\n        destination: TEncodable,\n        by_pattern: Optional[TEncodable] = None,\n        limit: Optional[Limit] = None,\n        get_patterns: Optional[List[TEncodable]] = None,\n        order: Optional[OrderBy] = None,\n        alpha: Optional[bool] = None,\n    ) -&gt; int:\n        \"\"\"\n        Sorts the elements in the list, set, or sorted set at `key` and stores the result in `store`.\n        The `sort` command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key.\n        To get the sort result without storing it into a key, see `sort`.\n\n        See https://valkey.io/commands/sort for more details.\n\n        Note: When in cluster mode, `key`, `destination`, and any patterns specified in `by_pattern` or `get_patterns`\n            must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n            only since Valkey version 8.0.\n\n        Args:\n            key (TEncodable): The key of the list, set, or sorted set to be sorted.\n            destination (TEncodable): The key where the sorted result will be stored.\n            by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n                `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n                timestamps.\n                E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n                keys `weight_&lt;element&gt;`.\n                If not provided, elements are sorted by their value.\n                Supported in cluster mode since Valkey version 8.0.\n            limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n            get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n                The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n                from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n                transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n                can be used to retrieve specific attributes of these users, such as their names or email addresses.\n                E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n                for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n                The special value `#` can be used to include the actual element from `key` being sorted.\n                If not provided, only the sorted elements themselves are returned.\n                Supported in cluster mode since Valkey version 8.0.\n            order (Optional[OrderBy]): Specifies the order to sort the elements.\n                Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n            alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n                Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n        Returns:\n            int: The number of elements in the sorted key stored at `store`.\n\n        Examples:\n            &gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n            &gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n                3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n            &gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n                [b'1', b'2', b'3']\n        \"\"\"\n        args = _build_sort_args(\n            key, by_pattern, limit, get_patterns, order, alpha, store=destination\n        )\n        result = await self._execute_command(RequestType.Sort, args)\n        return cast(int, result)\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.PubSubMsg","title":"<code>PubSubMsg</code>  <code>dataclass</code>","text":"<p>Describes the incoming pubsub message</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>TEncodable</code> <p>Incoming message.</p> <code>channel</code> <code>TEncodable</code> <p>Name of an channel that triggered the message.</p> <code>pattern</code> <code>Optional[TEncodable]</code> <p>Pattern that triggered the message.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>@dataclass\nclass PubSubMsg:\n    \"\"\"\n    Describes the incoming pubsub message\n\n    Attributes:\n        message (TEncodable): Incoming message.\n        channel (TEncodable): Name of an channel that triggered the message.\n        pattern (Optional[TEncodable]): Pattern that triggered the message.\n    \"\"\"\n\n    message: TEncodable\n    channel: TEncodable\n    pattern: Optional[TEncodable]\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.append","title":"<code>append(key, value)</code>  <code>async</code>","text":"<p>Appends a value to a key. If <code>key</code> does not exist it is created and set as an empty string, so <code>APPEND</code> will be similar to <code>SET</code> in this special case.</p> <p>See https://valkey.io/commands/append for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to which the value will be appended.</p> required <code>value</code> <code>TEncodable</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the stored value after appending <code>value</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n    5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n&gt;&gt;&gt; await client.append(\"key\", \" world\")\n    11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n&gt;&gt;&gt; await client.get(\"key\")\n    b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def append(self, key: TEncodable, value: TEncodable) -&gt; int:\n    \"\"\"\n    Appends a value to a key.\n    If `key` does not exist it is created and set as an empty string, so `APPEND` will be similar to `SET` in this special case.\n\n    See https://valkey.io/commands/append for more details.\n\n    Args:\n        key (TEncodable): The key to which the value will be appended.\n        value (TEncodable): The value to append.\n\n    Returns:\n        int: The length of the stored value after appending `value`.\n\n    Examples:\n        &gt;&gt;&gt; await client.append(\"key\", \"Hello\")\n            5  # Indicates that \"Hello\" has been appended to the value of \"key\", which was initially empty, resulting in a new value of \"Hello\" with a length of 5 - similar to the set operation.\n        &gt;&gt;&gt; await client.append(\"key\", \" world\")\n            11  # Indicates that \" world\" has been appended to the value of \"key\", resulting in a new value of \"Hello world\" with a length of 11.\n        &gt;&gt;&gt; await client.get(\"key\")\n            b\"Hello world\"  # Returns the value stored in \"key\", which is now \"Hello world\".\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Append, [key, value]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitcount","title":"<code>bitcount(key, options=None)</code>  <code>async</code>","text":"<p>Counts the number of set bits (population counting) in the string stored at <code>key</code>. The <code>options</code> argument can optionally be provided to count the number of bits in a specific string interval.</p> <p>See https://valkey.io/commands/bitcount for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key for the string to count the set bits of.</p> required <code>options</code> <code>Optional[OffsetOptions]</code> <p>The offset options.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>If <code>options</code> is provided, returns the number of set bits in the string interval specified by <code>options</code>. If <code>options</code> is not provided, returns the number of set bits in the string stored at <code>key</code>. Otherwise, if <code>key</code> is missing, returns <code>0</code> as it is treated as an empty string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.bitcount(\"my_key1\")\n    2  # The string stored at \"my_key1\" contains 2 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n    8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n    2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n&gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n    1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n&gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n    1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitcount(\n    self, key: TEncodable, options: Optional[OffsetOptions] = None\n) -&gt; int:\n    \"\"\"\n    Counts the number of set bits (population counting) in the string stored at `key`. The `options` argument can\n    optionally be provided to count the number of bits in a specific string interval.\n\n    See https://valkey.io/commands/bitcount for more details.\n\n    Args:\n        key (TEncodable): The key for the string to count the set bits of.\n        options (Optional[OffsetOptions]): The offset options.\n\n    Returns:\n        int: If `options` is provided, returns the number of set bits in the string interval specified by `options`.\n            If `options` is not provided, returns the number of set bits in the string stored at `key`.\n            Otherwise, if `key` is missing, returns `0` as it is treated as an empty string.\n\n    Examples:\n        &gt;&gt;&gt; await client.bitcount(\"my_key1\")\n            2  # The string stored at \"my_key1\" contains 2 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1))\n            8  # From the second to last bytes of the string stored at \"my_key2\" there are 8 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key2\", OffsetOptions(1, 3))\n            2  # The second to fourth bytes of the string stored at \"my_key2\" contain 2 set bits.\n        &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(1, 1, BitmapIndexType.BIT))\n            1  # Indicates that the second bit of the string stored at \"my_key3\" is set.\n        &gt;&gt;&gt; await client.bitcount(\"my_key3\", OffsetOptions(-1, -1, BitmapIndexType.BIT))\n            1  # Indicates that the last bit of the string stored at \"my_key3\" is set.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    if options is not None:\n        args.extend(options.to_args())\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitCount, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitfield","title":"<code>bitfield(key, subcommands)</code>  <code>async</code>","text":"<p>Reads or modifies the array of bits representing the string that is held at <code>key</code> based on the specified <code>subcommands</code>.</p> <p>See https://valkey.io/commands/bitfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>subcommands</code> <code>List[BitFieldSubCommands]</code> <p>The subcommands to be performed on the binary value of the string at <code>key</code>, which could be any of the following:     - <code>BitFieldGet</code>     - <code>BitFieldSet</code>     - <code>BitFieldIncrBy</code>     - <code>BitFieldOverflow</code></p> required <p>Returns:</p> Type Description <code>List[Optional[int]]</code> <p>List[Optional[int]]: An array of results from the executed subcommands: - <code>BitFieldGet</code> returns the value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldSet</code> returns the old value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldIncrBy</code> returns the new value in <code>BitOffset</code> or <code>BitOffsetMultiplier</code>. - <code>BitFieldOverflow</code> determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or   underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list   response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n    [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitfield(\n    self, key: TEncodable, subcommands: List[BitFieldSubCommands]\n) -&gt; List[Optional[int]]:\n    \"\"\"\n    Reads or modifies the array of bits representing the string that is held at `key` based on the specified\n    `subcommands`.\n\n    See https://valkey.io/commands/bitfield for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        subcommands (List[BitFieldSubCommands]): The subcommands to be performed on the binary value of the string\n            at `key`, which could be any of the following:\n                - `BitFieldGet`\n                - `BitFieldSet`\n                - `BitFieldIncrBy`\n                - `BitFieldOverflow`\n\n    Returns:\n        List[Optional[int]]: An array of results from the executed subcommands:\n            - `BitFieldGet` returns the value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldSet` returns the old value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldIncrBy` returns the new value in `BitOffset` or `BitOffsetMultiplier`.\n            - `BitFieldOverflow` determines the behavior of the \"SET\" and \"INCRBY\" subcommands when an overflow or\n              underflow occurs. \"OVERFLOW\" does not return a value and does not contribute a value to the list\n              response.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.bitfield(\"my_key\", [BitFieldSet(UnsignedEncoding(2), BitOffset(1), 3), BitFieldGet(UnsignedEncoding(2), BitOffset(1))])\n            [2, 3]  # The old value at offset 1 with an unsigned encoding of 2 was 2. The new value at offset 1 with an unsigned encoding of 2 is 3.\n    \"\"\"\n    args = [key] + _create_bitfield_args(subcommands)\n    return cast(\n        List[Optional[int]],\n        await self._execute_command(RequestType.BitField, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitfield_read_only","title":"<code>bitfield_read_only(key, subcommands)</code>  <code>async</code>","text":"<p>Reads the array of bits representing the string that is held at <code>key</code> based on the specified <code>subcommands</code>.</p> <p>See https://valkey.io/commands/bitfield_ro for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>subcommands</code> <code>List[BitFieldGet]</code> <p>The \"GET\" subcommands to be performed.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: An array of results from the \"GET\" subcommands.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n    [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n</code></pre> <p>Since: Valkey version 6.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitfield_read_only(\n    self, key: TEncodable, subcommands: List[BitFieldGet]\n) -&gt; List[int]:\n    \"\"\"\n    Reads the array of bits representing the string that is held at `key` based on the specified `subcommands`.\n\n    See https://valkey.io/commands/bitfield_ro for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        subcommands (List[BitFieldGet]): The \"GET\" subcommands to be performed.\n\n    Returns:\n        List[int]: An array of results from the \"GET\" subcommands.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"my_key\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.bitfield_read_only(\"my_key\", [BitFieldGet(UnsignedEncoding(2), Offset(1))])\n            [2]  # The value at offset 1 with an unsigned encoding of 2 is 2.\n\n    Since: Valkey version 6.0.0.\n    \"\"\"\n    args = [key] + _create_bitfield_read_only_args(subcommands)\n    return cast(\n        List[int],\n        await self._execute_command(RequestType.BitFieldReadOnly, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitop","title":"<code>bitop(operation, destination, keys)</code>  <code>async</code>","text":"<p>Perform a bitwise operation between multiple keys (containing string values) and store the result in the <code>destination</code>.</p> <p>See https://valkey.io/commands/bitop for more details.</p> Note <p>When in cluster mode, <code>destination</code> and all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>BitwiseOperation</code> <p>The bitwise operation to perform.</p> required <code>destination</code> <code>TEncodable</code> <p>The key that will store the resulting string.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to perform the bitwise operation on.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The size of the string stored in <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n&gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n&gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n    1  # The size of the resulting string stored in \"destination\" is 1\n&gt;&gt;&gt; await client.get(\"destination\")\n    \"@\"  # \"@\" has binary value 01000000\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitop(\n    self,\n    operation: BitwiseOperation,\n    destination: TEncodable,\n    keys: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Perform a bitwise operation between multiple keys (containing string values) and store the result in the\n    `destination`.\n\n    See https://valkey.io/commands/bitop for more details.\n\n    Note:\n        When in cluster mode, `destination` and all `keys` must map to the same hash slot.\n\n    Args:\n        operation (BitwiseOperation): The bitwise operation to perform.\n        destination (TEncodable): The key that will store the resulting string.\n        keys (List[TEncodable]): The list of keys to perform the bitwise operation on.\n\n    Returns:\n        int: The size of the string stored in `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A\")  # \"A\" has binary value 01000001\n        &gt;&gt;&gt; await client.set(\"key1\", \"B\")  # \"B\" has binary value 01000010\n        &gt;&gt;&gt; await client.bitop(BitwiseOperation.AND, \"destination\", [\"key1\", \"key2\"])\n            1  # The size of the resulting string stored in \"destination\" is 1\n        &gt;&gt;&gt; await client.get(\"destination\")\n            \"@\"  # \"@\" has binary value 01000000\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.BitOp, [operation.value, destination] + keys\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitpos","title":"<code>bitpos(key, bit, start=None)</code>  <code>async</code>","text":"<p>Returns the position of the first bit matching the given <code>bit</code> value. The optional starting offset <code>start</code> is a zero-based index, with <code>0</code> being the first byte of the list, <code>1</code> being the next byte and so on. The offset can also be a negative number indicating an offset starting at the end of the list, with <code>-1</code> being the last byte of the list, <code>-2</code> being the penultimate, and so on.</p> <p>See https://valkey.io/commands/bitpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>bit</code> <code>int</code> <p>The bit value to match. Must be <code>0</code> or <code>1</code>.</p> required <code>start</code> <code>Optional[int]</code> <p>The starting offset.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The position of the first occurrence of <code>bit</code> in the binary value of the string held at <code>key</code>. If <code>start</code> was provided, the search begins at the offset indicated by <code>start</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n&gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n    1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n&gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n    10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitpos(\n    self, key: TEncodable, bit: int, start: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Returns the position of the first bit matching the given `bit` value. The optional starting offset\n    `start` is a zero-based index, with `0` being the first byte of the list, `1` being the next byte and so on.\n    The offset can also be a negative number indicating an offset starting at the end of the list, with `-1` being\n    the last byte of the list, `-2` being the penultimate, and so on.\n\n    See https://valkey.io/commands/bitpos for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        bit (int): The bit value to match. Must be `0` or `1`.\n        start (Optional[int]): The starting offset.\n\n    Returns:\n        int: The position of the first occurrence of `bit` in the binary value of the string held at `key`.\n            If `start` was provided, the search begins at the offset indicated by `start`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A1\")  # \"A1\" has binary value 01000001 00110001\n        &gt;&gt;&gt; await client.bitpos(\"key1\", 1)\n            1  # The first occurrence of bit value 1 in the string stored at \"key1\" is at the second position.\n        &gt;&gt;&gt; await client.bitpos(\"key1\", 1, -1)\n            10  # The first occurrence of bit value 1, starting at the last byte in the string stored at \"key1\", is at the eleventh position.\n    \"\"\"\n    args = [key, str(bit)] if start is None else [key, str(bit), str(start)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitPos, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bitpos_interval","title":"<code>bitpos_interval(key, bit, start, end, index_type=None)</code>  <code>async</code>","text":"<p>Returns the position of the first bit matching the given <code>bit</code> value. The offsets are zero-based indexes, with <code>0</code> being the first element of the list, <code>1</code> being the next, and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with <code>-1</code> being the last element of the list, <code>-2</code> being the penultimate, and so on.</p> <p>If you are using Valkey 7.0.0 or above, the optional <code>index_type</code> can also be provided to specify whether the <code>start</code> and <code>end</code> offsets specify BIT or BYTE offsets. If <code>index_type</code> is not provided, BYTE offsets are assumed. If BIT is specified, <code>start=0</code> and <code>end=2</code> means to look at the first three bits. If BYTE is specified, <code>start=0</code> and <code>end=2</code> means to look at the first three bytes.</p> <p>See https://valkey.io/commands/bitpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>bit</code> <code>int</code> <p>The bit value to match. Must be <code>0</code> or <code>1</code>.</p> required <code>start</code> <code>int</code> <p>The starting offset.</p> required <code>end</code> <code>int</code> <p>The ending offset.</p> required <code>index_type</code> <code>Optional[BitmapIndexType]</code> <p>The index offset type. This option can only be specified if you are using Valkey version 7.0.0 or above. Could be either <code>BitmapIndexType.BYTE</code> or <code>BitmapIndexType.BIT</code>. If no index type is provided, the indexes will be assumed to be byte indexes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The position of the first occurrence from the <code>start</code> to the <code>end</code> offsets of the <code>bit</code> in the binary value of the string held at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n&gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n    10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n&gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n    7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bitpos_interval(\n    self,\n    key: TEncodable,\n    bit: int,\n    start: int,\n    end: int,\n    index_type: Optional[BitmapIndexType] = None,\n) -&gt; int:\n    \"\"\"\n    Returns the position of the first bit matching the given `bit` value. The offsets are zero-based indexes, with\n    `0` being the first element of the list, `1` being the next, and so on. These offsets can also be negative\n    numbers indicating offsets starting at the end of the list, with `-1` being the last element of the list, `-2`\n    being the penultimate, and so on.\n\n    If you are using Valkey 7.0.0 or above, the optional `index_type` can also be provided to specify whether the\n    `start` and `end` offsets specify BIT or BYTE offsets. If `index_type` is not provided, BYTE offsets\n    are assumed. If BIT is specified, `start=0` and `end=2` means to look at the first three bits. If BYTE is\n    specified, `start=0` and `end=2` means to look at the first three bytes.\n\n    See https://valkey.io/commands/bitpos for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        bit (int): The bit value to match. Must be `0` or `1`.\n        start (int): The starting offset.\n        end (int): The ending offset.\n        index_type (Optional[BitmapIndexType]): The index offset type. This option can only be specified if you are\n            using Valkey version 7.0.0 or above. Could be either `BitmapIndexType.BYTE` or `BitmapIndexType.BIT`.\n            If no index type is provided, the indexes will be assumed to be byte indexes.\n\n    Returns:\n        int: The position of the first occurrence from the `start` to the `end` offsets of the `bit` in the binary\n            value of the string held at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"A12\")  # \"A12\" has binary value 01000001 00110001 00110010\n        &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 1, -1)\n            10  # The first occurrence of bit value 1 in the second byte to the last byte of the string stored at \"key1\" is at the eleventh position.\n        &gt;&gt;&gt; await client.bitpos_interval(\"key1\", 1, 2, 9, BitmapIndexType.BIT)\n            7  # The first occurrence of bit value 1 in the third to tenth bits of the string stored at \"key1\" is at the eighth position.\n    \"\"\"\n    if index_type is not None:\n        args = [key, str(bit), str(start), str(end), index_type.value]\n    else:\n        args = [key, str(bit), str(start), str(end)]\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.BitPos, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.blmove","title":"<code>blmove(source, destination, where_from, where_to, timeout)</code>  <code>async</code>","text":"<p>Blocks the connection until it pops atomically and removes the left/right-most element to the list stored at <code>source</code> depending on <code>where_from</code>, and pushes the element at the first/last element of the list stored at <code>destination</code> depending on <code>where_to</code>. <code>BLMOVE</code> is the blocking variant of <code>LMOVE</code>.</p> Notes <ol> <li>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</li> <li><code>BLMOVE</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>See https://valkey.io/commands/blmove/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source list.</p> required <code>destination</code> <code>TEncodable</code> <p>The key to the destination list.</p> required <code>where_from</code> <code>ListDirection</code> <p>The direction to remove the element from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>where_to</code> <code>ListDirection</code> <p>The direction to add the element to (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of <code>0</code> will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The popped element, or None if <code>source</code> does not exist or if the operation timed-out.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n&gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n&gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n    b\"one\"\n&gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n    [b\"two\"]\n&gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n    [b\"one\", b\"three\", bb\"four\"]\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blmove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    where_from: ListDirection,\n    where_to: ListDirection,\n    timeout: float,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Blocks the connection until it pops atomically and removes the left/right-most element to the\n    list stored at `source` depending on `where_from`, and pushes the element at the first/last element\n    of the list stored at `destination` depending on `where_to`.\n    `BLMOVE` is the blocking variant of `LMOVE`.\n\n    Notes:\n        1. When in cluster mode, both `source` and `destination` must map to the same hash slot.\n        2. `BLMOVE` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/blmove/ for details.\n\n    Args:\n        source (TEncodable): The key to the source list.\n        destination (TEncodable): The key to the destination list.\n        where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n\n    Returns:\n        Optional[bytes]: The popped element, or None if `source` does not exist or if the operation timed-out.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey1\", [\"two\", \"one\"])\n        &gt;&gt;&gt; await client.lpush(\"testKey2\", [\"four\", \"three\"])\n        &gt;&gt;&gt; await client.blmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT, 0.1)\n            b\"one\"\n        &gt;&gt;&gt; await client.lrange(\"testKey1\", 0, -1)\n            [b\"two\"]\n        &gt;&gt;&gt; updated_array2 = await client.lrange(\"testKey2\", 0, -1)\n            [b\"one\", b\"three\", bb\"four\"]\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(\n            RequestType.BLMove,\n            [source, destination, where_from.value, where_to.value, str(timeout)],\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.blmpop","title":"<code>blmpop(keys, direction, timeout, count=None)</code>  <code>async</code>","text":"<p>Blocks the connection until it pops one or more elements from the first non-empty list from the provided <code>keys</code>.</p> <p><code>BLMPOP</code> is the blocking variant of <code>LMPOP</code>.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BLMPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>See https://valkey.io/commands/blmpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>An array of keys of lists.</p> required <code>direction</code> <code>ListDirection</code> <p>The direction based on which elements are popped from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of <code>0</code> will block indefinitely.</p> required <code>count</code> <code>Optional[int]</code> <p>The maximum number of popped elements. If not provided, defaults to popping a single element.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[bytes]]]</code> <p>Optional[Mapping[bytes, List[bytes]]]: A map of <code>key</code> name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n&gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n   {b\"testKey\": [b\"three\", b\"two\"]}\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blmpop(\n    self,\n    keys: List[TEncodable],\n    direction: ListDirection,\n    timeout: float,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n    \"\"\"\n    Blocks the connection until it pops one or more elements from the first non-empty list from the provided `keys`.\n\n    `BLMPOP` is the blocking variant of `LMPOP`.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BLMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/blmpop/ for details.\n\n    Args:\n        keys (List[TEncodable]): An array of keys of lists.\n        direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of `0` will block indefinitely.\n        count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n    Returns:\n        Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped and the timeout expired.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n        &gt;&gt;&gt; await client.blmpop([\"testKey\"], ListDirection.LEFT, 0.1, 2)\n           {b\"testKey\": [b\"three\", b\"two\"]}\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(timeout), str(len(keys)), *keys, direction.value]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[Mapping[bytes, List[bytes]]],\n        await self._execute_command(RequestType.BLMPop, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.blpop","title":"<code>blpop(keys, timeout)</code>  <code>async</code>","text":"<p>Pops an element from the head of the first list that is non-empty, with the given keys being checked in the order that they are given. Blocks the connection when there are no elements to pop from any of the given lists. See https://valkey.io/commands/blpop for details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BLPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the lists to pop from.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the popped element, formatted as <code>[key, value]</code>. If no element could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n    [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def blpop(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Pops an element from the head of the first list that is non-empty, with the given keys being checked in the\n    order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n    See https://valkey.io/commands/blpop for details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BLPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the lists to pop from.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n            popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.blpop([\"list1\", \"list2\"], 0.5)\n            [b\"list1\", b\"element\"]  # \"element\" was popped from the head of the list with key \"list1\"\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.BLPop, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.brpop","title":"<code>brpop(keys, timeout)</code>  <code>async</code>","text":"<p>Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given. Blocks the connection when there are no elements to pop from any of the given lists. See https://valkey.io/commands/brpop for details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BRPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the lists to pop from.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the popped element, formatted as <code>[key, value]</code>. If no element could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n    [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def brpop(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Pops an element from the tail of the first list that is non-empty, with the given keys being checked in the\n    order that they are given. Blocks the connection when there are no elements to pop from any of the given lists.\n    See https://valkey.io/commands/brpop for details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BRPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the lists to pop from.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[bytes]]: A two-element list containing the key from which the element was popped and the value of the\n            popped element, formatted as `[key, value]`. If no element could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.brpop([\"list1\", \"list2\"], 0.5)\n            [b\"list1\", b\"element\"]  # \"element\" was popped from the tail of the list with key \"list1\"\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.BRPop, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bzmpop","title":"<code>bzmpop(keys, modifier, timeout, count=None)</code>  <code>async</code>","text":"<p>Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.</p> <p>The optional <code>count</code> argument can be used to specify the number of elements to pop, and is set to 1 by default.</p> <p>The number of popped elements is the minimum from the sorted set's cardinality and <code>count</code>.</p> <p><code>BZMPOP</code> is the blocking variant of <code>ZMPOP</code>.</p> <p>See https://valkey.io/commands/bzmpop for more details.</p> Notes <ol> <li>When in cluster mode, all <code>keys</code> must map to the same hash slot.</li> <li><code>BZMPOP</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>modifier</code> <code>ScoreFilter</code> <p>The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop members with the lowest/highest scores accordingly.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of elements to pop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, Mapping[bytes, float]]]]</code> <p>Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from which elements were popped, and a member-score mapping of the popped elements. If no members could be popped and the timeout expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n&gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n    [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzmpop(\n    self,\n    keys: List[TEncodable],\n    modifier: ScoreFilter,\n    timeout: float,\n    count: Optional[int] = None,\n) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n    \"\"\"\n    Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n    that they are given. Blocks the connection when there are no members to pop from any of the given sorted sets.\n\n    The optional `count` argument can be used to specify the number of elements to pop, and is set to 1 by default.\n\n    The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n    `BZMPOP` is the blocking variant of `ZMPOP`.\n\n    See https://valkey.io/commands/bzmpop for more details.\n\n    Notes:\n        1. When in cluster mode, all `keys` must map to the same hash slot.\n        2. `BZMPOP` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        modifier (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n            members with the lowest/highest scores accordingly.\n        timeout (float): The number of seconds to wait for a blocking operation to complete. A value of 0 will\n            block indefinitely.\n        count (Optional[int]): The number of elements to pop.\n\n    Returns:\n        Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n            which elements were popped, and a member-score mapping of the popped elements. If no members could be\n            popped and the timeout expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n        &gt;&gt;&gt; await client.bzmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 0.5, 2)\n            [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(timeout), str(len(keys))] + keys + [modifier.value]\n    if count is not None:\n        args = args + [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[List[Union[bytes, Mapping[bytes, float]]]],\n        await self._execute_command(RequestType.BZMPop, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bzpopmax","title":"<code>bzpopmax(keys, timeout)</code>  <code>async</code>","text":"<p>Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to remove from any of the given sorted sets.</p> <p>When in cluster mode, all keys must map to the same hash slot.</p> <p><code>BZPOPMAX</code> is the blocking variant of <code>ZPOPMAX</code>.</p> <p><code>BZPOPMAX</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</p> <p>See https://valkey.io/commands/bzpopmax for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, float]]]</code> <p>Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself, and the member score. If no member could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n    2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n&gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n    [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzpopmax(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[Union[bytes, float]]]:\n    \"\"\"\n    Pops the member with the highest score from the first non-empty sorted set, with the given keys being checked in\n    the order that they are given. Blocks the connection when there are no members to remove from any of the given\n    sorted sets.\n\n    When in cluster mode, all keys must map to the same hash slot.\n\n    `BZPOPMAX` is the blocking variant of `ZPOPMAX`.\n\n    `BZPOPMAX` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/bzpopmax for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        timeout (float): The number of seconds to wait for a blocking operation to complete.\n            A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n            and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n            2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n        &gt;&gt;&gt; await client.bzpopmax([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n            [b'my_sorted_set1', b'member1', 10.0]  # \"member1\" with a score of 10.0 has been removed from \"my_sorted_set1\".\n    \"\"\"\n    return cast(\n        Optional[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.BZPopMax, keys + [str(timeout)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.bzpopmin","title":"<code>bzpopmin(keys, timeout)</code>  <code>async</code>","text":"<p>Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in the order that they are given. Blocks the connection when there are no members to remove from any of the given sorted sets.</p> <p>When in cluster mode, all keys must map to the same hash slot.</p> <p><code>BZPOPMIN</code> is the blocking variant of <code>ZPOPMIN</code>.</p> <p><code>BZPOPMIN</code> is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.</p> <p>See https://valkey.io/commands/bzpopmin for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait for a blocking operation to complete. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, float]]]</code> <p>Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself, and the member score. If no member could be popped and the <code>timeout</code> expired, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n    2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n&gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n    [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def bzpopmin(\n    self, keys: List[TEncodable], timeout: float\n) -&gt; Optional[List[Union[bytes, float]]]:\n    \"\"\"\n    Pops the member with the lowest score from the first non-empty sorted set, with the given keys being checked in\n    the order that they are given. Blocks the connection when there are no members to remove from any of the given\n    sorted sets.\n\n    When in cluster mode, all keys must map to the same hash slot.\n\n    `BZPOPMIN` is the blocking variant of `ZPOPMIN`.\n\n    `BZPOPMIN` is a client blocking command, see https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#blocking-commands for more details and best practices.\n\n    See https://valkey.io/commands/bzpopmin for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        timeout (float): The number of seconds to wait for a blocking operation to complete.\n            A value of 0 will block indefinitely.\n\n    Returns:\n        Optional[List[Union[bytes, float]]]: An array containing the key where the member was popped out, the member itself,\n            and the member score. If no member could be popped and the `timeout` expired, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set1\", {\"member1\": 10.0, \"member2\": 5.0})\n            2  # Two elements have been added to the sorted set at \"my_sorted_set1\".\n        &gt;&gt;&gt; await client.bzpopmin([\"my_sorted_set1\", \"my_sorted_set2\"], 0.5)\n            [b'my_sorted_set1', b'member2', 5.0]  # \"member2\" with a score of 5.0 has been removed from \"my_sorted_set1\".\n    \"\"\"\n    args: List[TEncodable] = keys + [str(timeout)]\n    return cast(\n        Optional[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.BZPopMin, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.decr","title":"<code>decr(key)</code>  <code>async</code>","text":"<p>Decrement the number stored at <code>key</code> by one. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/decr/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the decrement.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.decr(\"key\")\n    9\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def decr(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Decrement the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n    operation.\n    See https://valkey.io/commands/decr/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n\n    Returns:\n        int: The value of key after the decrement.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.decr(\"key\")\n            9\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Decr, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.decrby","title":"<code>decrby(key, amount)</code>  <code>async</code>","text":"<p>Decrements the number stored at <code>key</code> by <code>amount</code>. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/decrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to decrement its value.</p> required <code>amount</code> <code>int) </code> <p>The amount to decrement.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the decrement.</p> Example <p>await client.set(\"key\", \"10\") await client.decrby(\"key\" , 5)     5</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def decrby(self, key: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Decrements the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n    the operation.\n    See https://valkey.io/commands/decrby/ for more details.\n\n    Args:\n      key (TEncodable): The key to decrement its value.\n      amount (int) : The amount to decrement.\n\n    Returns:\n        int: The value of key after the decrement.\n\n    Example:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.decrby(\"key\" , 5)\n            5\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.DecrBy, [key, str(amount)])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.delete","title":"<code>delete(keys)</code>  <code>async</code>","text":"<p>Delete one or more keys from the database. A key is ignored if it does not exist. See https://valkey.io/commands/del/ for details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys to be deleted from the database.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.delete([\"key\"])\n    1 # Indicates that the key was successfully deleted.\n&gt;&gt;&gt; await client.delete([\"key\"])\n    0 # No keys we're deleted since \"key\" doesn't exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def delete(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Delete one or more keys from the database. A key is ignored if it does not exist.\n    See https://valkey.io/commands/del/ for details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): A list of keys to be deleted from the database.\n\n    Returns:\n        int: The number of keys that were deleted.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.delete([\"key\"])\n            1 # Indicates that the key was successfully deleted.\n        &gt;&gt;&gt; await client.delete([\"key\"])\n            0 # No keys we're deleted since \"key\" doesn't exist.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Del, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.dump","title":"<code>dump(key)</code>  <code>async</code>","text":"<p>Serialize the value stored at <code>key</code> in a Valkey-specific format and return it to the user.</p> <p>See https://valkey.io/commands/dump for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to serialize.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The serialized value of the data stored at <code>key</code>. If <code>key</code> does not exist, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.dump(\"key\")\n    b\"value\" # The serialized value stored at `key`.\n&gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n    None # Non-existing key will return `None`.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def dump(\n    self,\n    key: TEncodable,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Serialize the value stored at `key` in a Valkey-specific format and return it to the user.\n\n    See https://valkey.io/commands/dump for more details.\n\n    Args:\n        key (TEncodable): The `key` to serialize.\n\n    Returns:\n        Optional[bytes]: The serialized value of the data stored at `key`.\n            If `key` does not exist, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.dump(\"key\")\n            b\"value\" # The serialized value stored at `key`.\n        &gt;&gt;&gt; await client.dump(\"nonExistingKey\")\n            None # Non-existing key will return `None`.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.Dump, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.exists","title":"<code>exists(keys)</code>  <code>async</code>","text":"<p>Returns the number of keys in <code>keys</code> that exist in the database. See https://valkey.io/commands/exists/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to check.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that exist. If the same existing key is mentioned in <code>keys</code> multiple times, it will be counted multiple times.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n    3  # Indicates that all three keys exist in the database.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def exists(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Returns the number of keys in `keys` that exist in the database.\n    See https://valkey.io/commands/exists/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The list of keys to check.\n\n    Returns:\n        int: The number of keys that exist. If the same existing key is mentioned in `keys` multiple times,\n            it will be counted multiple times.\n\n    Examples:\n        &gt;&gt;&gt; await client.exists([\"key1\", \"key2\", \"key3\"])\n            3  # Indicates that all three keys exist in the database.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Exists, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.expire","title":"<code>expire(key, seconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> in seconds. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. If <code>seconds</code> is a non-positive number, the key will be deleted rather than expired. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/expire/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>seconds</code> <code>int</code> <p>The timeout in seconds.</p> required <code>option</code> <code>ExpireOptions</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n    True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expire(\n    self,\n    key: TEncodable,\n    seconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` in seconds. After the timeout has expired, the key will automatically be deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    If `seconds` is a non-positive number, the key will be deleted rather than expired.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/expire/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        seconds (int): The timeout in seconds.\n        option (ExpireOptions, optional): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n            True  # Indicates that a timeout of 60 seconds has been set for \"my_key.\"\n    \"\"\"\n    args: List[TEncodable] = (\n        [key, str(seconds)] if option is None else [key, str(seconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.Expire, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.expireat","title":"<code>expireat(key, unix_seconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the number of seconds. A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/expireat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>unix_seconds</code> <code>int</code> <p>The timeout in an absolute Unix timestamp.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n    True\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expireat(\n    self,\n    key: TEncodable,\n    unix_seconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` using an absolute Unix timestamp (seconds since January 1, 1970) instead of specifying the\n    number of seconds.\n    A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n    deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/expireat/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        unix_seconds (int): The timeout in an absolute Unix timestamp.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.expireAt(\"my_key\", 1672531200, ExpireOptions.HasNoExpiry)\n            True\n    \"\"\"\n    args = (\n        [key, str(unix_seconds)]\n        if option is None\n        else [key, str(unix_seconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.ExpireAt, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.expiretime","title":"<code>expiretime(key)</code>  <code>async</code>","text":"<p>Returns the absolute Unix timestamp (since January 1, 1970) at which the given <code>key</code> will expire, in seconds. To get the expiration with millisecond precision, use <code>pexpiretime</code>.</p> <p>See https://valkey.io/commands/expiretime/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to determine the expiration value of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expiration Unix timestamp in seconds, -2 if <code>key</code> does not exist or -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    -2 # 'my_key' doesn't exist.\n&gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    -1 # 'my_key' has no associate expiration.\n&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n&gt;&gt;&gt; await client.expiretime(\"my_key\")\n    1718614954\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def expiretime(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the absolute Unix timestamp (since January 1, 1970) at which\n    the given `key` will expire, in seconds.\n    To get the expiration with millisecond precision, use `pexpiretime`.\n\n    See https://valkey.io/commands/expiretime/ for details.\n\n    Args:\n        key (TEncodable): The `key` to determine the expiration value of.\n\n    Returns:\n        int: The expiration Unix timestamp in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            -2 # 'my_key' doesn't exist.\n        &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            -1 # 'my_key' has no associate expiration.\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n        &gt;&gt;&gt; await client.expiretime(\"my_key\")\n            1718614954\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.ExpireTime, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.fcall","title":"<code>fcall(function, keys=None, arguments=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded function. See https://valkey.io/commands/fcall/ for more details. When in cluster mode, all keys in <code>keys</code> must map to the same hash slot. Args:     function (TEncodable): The function name.     keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct         execution of functions, both in standalone and clustered deployments, all names of keys         that a function accesses must be explicitly provided as <code>keys</code>.     arguments (Optional[List[TEncodable]]): A list of <code>function</code> arguments. <code>Arguments</code>         should not represent names of keys. Returns:     TResult:         The invoked function's return value. Example:     &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")         b'new_value' # Returns the function's return value.</p> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def fcall(\n    self,\n    function: TEncodable,\n    keys: Optional[List[TEncodable]] = None,\n    arguments: Optional[List[TEncodable]] = None,\n) -&gt; TResult:\n    \"\"\"\n    Invokes a previously loaded function.\n    See https://valkey.io/commands/fcall/ for more details.\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n    Args:\n        function (TEncodable): The function name.\n        keys (Optional[List[TEncodable]]): A list of keys accessed by the function. To ensure the correct\n            execution of functions, both in standalone and clustered deployments, all names of keys\n            that a function accesses must be explicitly provided as `keys`.\n        arguments (Optional[List[TEncodable]]): A list of `function` arguments. `Arguments`\n            should not represent names of keys.\n    Returns:\n        TResult:\n            The invoked function's return value.\n    Example:\n        &gt;&gt;&gt; await client.fcall(\"Deep_Thought\")\n            b'new_value' # Returns the function's return value.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = []\n    if keys is not None:\n        args.extend([function, str(len(keys))] + keys)\n    else:\n        args.extend([function, str(0)])\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TResult,\n        await self._execute_command(RequestType.FCall, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.fcall_ro","title":"<code>fcall_ro(function, keys=None, arguments=None)</code>  <code>async</code>","text":"<p>Invokes a previously loaded read-only function.</p> <p>See https://valkey.io/commands/fcall_ro for more details.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>TEncodable</code> <p>The function name.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>An <code>array</code> of keys accessed by the function. To ensure the correct execution of functions, all names of keys that a function accesses must be explicitly provided as <code>keys</code>.</p> <code>None</code> <code>arguments</code> <code>List[TEncodable]</code> <p>An <code>array</code> of <code>function</code> arguments. <code>arguments</code> should not represent names of keys.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TResult</code> <p>The return value depends on the function that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n        \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n    42 # The return value on the function that was executed\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def fcall_ro(\n    self,\n    function: TEncodable,\n    keys: Optional[List[TEncodable]] = None,\n    arguments: Optional[List[TEncodable]] = None,\n) -&gt; TResult:\n    \"\"\"\n    Invokes a previously loaded read-only function.\n\n    See https://valkey.io/commands/fcall_ro for more details.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    Args:\n        function (TEncodable): The function name.\n        keys (List[TEncodable]): An `array` of keys accessed by the function. To ensure the correct\n            execution of functions, all names of keys that a function accesses must be\n            explicitly provided as `keys`.\n        arguments (List[TEncodable]): An `array` of `function` arguments. `arguments` should not\n            represent names of keys.\n\n    Returns:\n        TResult: The return value depends on the function that was executed.\n\n    Examples:\n        &gt;&gt;&gt; await client.fcall_ro(\"Deep_Thought\", [\"key1\"], [\"Answer\", \"to\", \"the\",\n                \"Ultimate\", \"Question\", \"of\", \"Life,\", \"the\", \"Universe,\", \"and\", \"Everything\"])\n            42 # The return value on the function that was executed\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = []\n    if keys is not None:\n        args.extend([function, str(len(keys))] + keys)\n    else:\n        args.extend([function, str(0)])\n    if arguments is not None:\n        args.extend(arguments)\n    return cast(\n        TResult,\n        await self._execute_command(RequestType.FCallReadOnly, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geoadd","title":"<code>geoadd(key, members_geospatialdata, existing_options=None, changed=False)</code>  <code>async</code>","text":"<p>Adds geospatial members with their positions to the specified sorted set stored at <code>key</code>. If a member is already a part of the sorted set, its position is updated.</p> <p>See https://valkey.io/commands/geoadd for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members_geospatialdata</code> <code>Mapping[TEncodable, GeospatialData]</code> <p>A mapping of member names to their corresponding positions. See <code>GeospatialData</code>.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling existing members. - NX: Only add new elements. - XX: Only update existing elements.</p> <code>None</code> <code>changed</code> <code>bool</code> <p>Modify the return value to return the number of changed elements, instead of the number of new elements added.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements added to the sorted set.</p> <code>int</code> <p>If <code>changed</code> is set, returns the number of elements updated in the sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n    2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n    1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geoadd(\n    self,\n    key: TEncodable,\n    members_geospatialdata: Mapping[TEncodable, GeospatialData],\n    existing_options: Optional[ConditionalChange] = None,\n    changed: bool = False,\n) -&gt; int:\n    \"\"\"\n    Adds geospatial members with their positions to the specified sorted set stored at `key`.\n    If a member is already a part of the sorted set, its position is updated.\n\n    See https://valkey.io/commands/geoadd for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members_geospatialdata (Mapping[TEncodable, GeospatialData]): A mapping of member names to their corresponding positions. See `GeospatialData`.\n        The command will report an error when the user attempts to index coordinates outside the specified ranges.\n        existing_options (Optional[ConditionalChange]): Options for handling existing members.\n            - NX: Only add new elements.\n            - XX: Only update existing elements.\n        changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n    Returns:\n        int: The number of elements added to the sorted set.\n        If `changed` is set, returns the number of elements updated in the sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n            2  # Indicates that two elements have been added to the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.geoadd(\"my_sorted_set\", {\"Palermo\": GeospatialData(14.361389, 38.115556)}, existing_options=ConditionalChange.XX, changed=True)\n            1  # Updates the position of an existing member in the sorted set \"my_sorted_set\".\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if changed:\n        args.append(\"CH\")\n\n    members_geospatialdata_list = [\n        coord\n        for member, position in members_geospatialdata.items()\n        for coord in [str(position.longitude), str(position.latitude), member]\n    ]\n    args += members_geospatialdata_list\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.GeoAdd, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geodist","title":"<code>geodist(key, member1, member2, unit=None)</code>  <code>async</code>","text":"<p>Returns the distance between two members in the geospatial index stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geodist for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member1</code> <code>TEncodable</code> <p>The name of the first member.</p> required <code>member2</code> <code>TEncodable</code> <p>The name of the second member.</p> required <code>unit</code> <code>Optional[GeoUnit]</code> <p>The unit of distance measurement. See <code>GeoUnit</code>. If not specified, the default unit is <code>METERS</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The distance between <code>member1</code> and <code>member2</code>.</p> <code>Optional[float]</code> <p>If one or both members do not exist, or if the key does not exist, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n    166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n    166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n&gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n    None  # Returns None for non-existing member.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geodist(\n    self,\n    key: TEncodable,\n    member1: TEncodable,\n    member2: TEncodable,\n    unit: Optional[GeoUnit] = None,\n) -&gt; Optional[float]:\n    \"\"\"\n    Returns the distance between two members in the geospatial index stored at `key`.\n\n    See https://valkey.io/commands/geodist for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member1 (TEncodable): The name of the first member.\n        member2 (TEncodable): The name of the second member.\n        unit (Optional[GeoUnit]): The unit of distance measurement. See `GeoUnit`.\n            If not specified, the default unit is `METERS`.\n\n    Returns:\n        Optional[float]: The distance between `member1` and `member2`.\n        If one or both members do not exist, or if the key does not exist, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Catania\")\n            166274.1516  # Indicates the distance between \"Palermo\" and \"Catania\" in meters.\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"Palermo\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n            166.2742  # Indicates the distance between \"Palermo\" and \"Palermo\" in kilometers.\n        &gt;&gt;&gt; await client.geodist(\"my_geo_set\", \"non-existing\", \"Palermo\", unit=GeoUnit.KILOMETERS)\n            None  # Returns None for non-existing member.\n    \"\"\"\n    args = [key, member1, member2]\n    if unit:\n        args.append(unit.value)\n\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.GeoDist, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geohash","title":"<code>geohash(key, members)</code>  <code>async</code>","text":"<p>Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geohash for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>The list of members whose GeoHash bytes strings are to be retrieved.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at <code>key</code>.</p> <code>List[Optional[bytes]]</code> <p>If a member does not exist in the sorted set, a None value is returned for that member.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n    [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geohash(\n    self, key: TEncodable, members: List[TEncodable]\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Returns the GeoHash bytes strings representing the positions of all the specified members in the sorted set stored at\n    `key`.\n\n    See https://valkey.io/commands/geohash for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): The list of members whose GeoHash bytes strings are to be retrieved.\n\n    Returns:\n        List[Optional[bytes]]: A list of GeoHash bytes strings representing the positions of the specified members stored at `key`.\n        If a member does not exist in the sorted set, a None value is returned for that member.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geohash(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"some city])\n            [\"sqc8b49rny0\", \"sqdtr74hyu0\", None]  # Indicates the GeoHash bytes strings for the specified members.\n    \"\"\"\n    return cast(\n        List[Optional[bytes]],\n        await self._execute_command(RequestType.GeoHash, [key] + members),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geopos","title":"<code>geopos(key, members)</code>  <code>async</code>","text":"<p>Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/geopos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>The members for which to get the positions.</p> required <p>Returns:</p> Type Description <code>List[Optional[List[float]]]</code> <p>List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.</p> <code>List[Optional[List[float]]]</code> <p>If a member does not exist, its position will be None.</p> Example <p>await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)}) await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])     [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geopos(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; List[Optional[List[float]]]:\n    \"\"\"\n    Returns the positions (longitude and latitude) of all the given members of a geospatial index in the sorted set stored at\n    `key`.\n\n    See https://valkey.io/commands/geopos for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): The members for which to get the positions.\n\n    Returns:\n        List[Optional[List[float]]]: A list of positions (longitude and latitude) corresponding to the given members.\n        If a member does not exist, its position will be None.\n\n    Example:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geopos(\"my_geo_sorted_set\", [\"Palermo\", \"Catania\", \"NonExisting\"])\n            [[13.36138933897018433, 38.11555639549629859], [15.08726745843887329, 37.50266842333162032], None]\n    \"\"\"\n    return cast(\n        List[Optional[List[float]]],\n        await self._execute_command(RequestType.GeoPos, [key] + members),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geosearch","title":"<code>geosearch(key, search_from, search_by, order_by=None, count=None, with_coord=False, with_dist=False, with_hash=False)</code>  <code>async</code>","text":"<p>Searches for members in a sorted set stored at <code>key</code> representing geospatial data within a circular or rectangular area.</p> <p>See https://valkey.io/commands/geosearch/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set representing geospatial data.</p> required <code>search_from</code> <code>Union[str, bytes, GeospatialData]</code> <p>The location to search from. Can be specified either as a member from the sorted set or as a geospatial data (see <code>GeospatialData</code>).</p> required <code>search_by</code> <code>Union[GeoSearchByRadius, GeoSearchByBox]</code> <p>The search criteria. For circular area search, see <code>GeoSearchByRadius</code>. For rectangular area search, see <code>GeoSearchByBox</code>.</p> required <code>order_by</code> <code>Optional[OrderBy]</code> <p>Specifies the order in which the results should be returned.     - <code>ASC</code>: Sorts items from the nearest to the farthest, relative to the center point.     - <code>DESC</code>: Sorts items from the farthest to the nearest, relative to the center point. If not specified, the results would be unsorted.</p> <code>None</code> <code>count</code> <code>Optional[GeoSearchCount]</code> <p>Specifies the maximum number of results to return. See <code>GeoSearchCount</code>. If not specified, return all results.</p> <code>None</code> <code>with_coord</code> <code>bool</code> <p>Whether to include coordinates of the returned items. Defaults to False.</p> <code>False</code> <code>with_dist</code> <code>bool</code> <p>Whether to include distance from the center in the returned items. The distance is returned in the same unit as specified for the <code>search_by</code> arguments. Defaults to False.</p> <code>False</code> <code>with_hash</code> <code>bool</code> <p>Whether to include geohash of the returned items. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]</code> <p>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.</p> <code>List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]</code> <p>If any of <code>with_coord</code>, <code>with_dist</code> or <code>with_hash</code> are True, returns an array of arrays, we're each sub array represents a single item in the following order: (bytes): The member (location) name. (float): The distance from the center as a floating point number, in the same unit specified in the radius, if <code>with_dist</code> is set to True. (int): The Geohash integer, if <code>with_hash</code> is set to True. List[float]: The coordinates as a two item [longitude,latitude] array, if <code>with_coord</code> is set to True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n    ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n&gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n    [\n        [\n            b\"Catania\",\n            [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n        ],\n        [\n            b\"Palermo\",\n            [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n        ],\n        [\n            b\"edge2\",\n            [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n        ],\n        [\n            b\"edge1\",\n            [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n        ],\n    ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geosearch(\n    self,\n    key: TEncodable,\n    search_from: Union[str, bytes, GeospatialData],\n    search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n    order_by: Optional[OrderBy] = None,\n    count: Optional[GeoSearchCount] = None,\n    with_coord: bool = False,\n    with_dist: bool = False,\n    with_hash: bool = False,\n) -&gt; List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]:\n    \"\"\"\n    Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area.\n\n    See https://valkey.io/commands/geosearch/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set representing geospatial data.\n        search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n            from the sorted set or as a geospatial data (see `GeospatialData`).\n        search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n            For circular area search, see `GeoSearchByRadius`.\n            For rectangular area search, see `GeoSearchByBox`.\n        order_by (Optional[OrderBy]): Specifies the order in which the results should be returned.\n                - `ASC`: Sorts items from the nearest to the farthest, relative to the center point.\n                - `DESC`: Sorts items from the farthest to the nearest, relative to the center point.\n            If not specified, the results would be unsorted.\n        count (Optional[GeoSearchCount]): Specifies the maximum number of results to return. See `GeoSearchCount`.\n            If not specified, return all results.\n        with_coord (bool): Whether to include coordinates of the returned items. Defaults to False.\n        with_dist (bool): Whether to include distance from the center in the returned items.\n            The distance is returned in the same unit as specified for the `search_by` arguments. Defaults to False.\n        with_hash (bool): Whether to include geohash of the returned items. Defaults to False.\n\n    Returns:\n        List[Union[bytes, List[Union[bytes, float, int, List[float]]]]]: By default, returns a list of members (locations) names.\n        If any of `with_coord`, `with_dist` or `with_hash` are True, returns an array of arrays, we're each sub array represents a single item in the following order:\n            (bytes): The member (location) name.\n            (float): The distance from the center as a floating point number, in the same unit specified in the radius, if `with_dist` is set to True.\n            (int): The Geohash integer, if `with_hash` is set to True.\n            List[float]: The coordinates as a two item [longitude,latitude] array, if `with_coord` is set to True.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"edge1\": GeospatialData(12.758489, 38.788135), \"edge2\": GeospatialData(17.241510, 38.788135)}})\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES), OrderBy.DESC)\n            ['Palermo', 'Catania'] # Returned the locations names within the radius of 175 miles, with the center being 'Catania' from farthest to nearest.\n        &gt;&gt;&gt; await client.geosearch(\"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), OrderBy.DESC, with_coord=true, with_dist=true, with_hash=true)\n            [\n                [\n                    b\"Catania\",\n                    [56.4413, 3479447370796909, [15.087267458438873, 37.50266842333162]],\n                ],\n                [\n                    b\"Palermo\",\n                    [190.4424, 3479099956230698, [13.361389338970184, 38.1155563954963]],\n                ],\n                [\n                    b\"edge2\",\n                    [279.7403, 3481342659049484, [17.241510450839996, 38.78813451624225]],\n                ],\n                [\n                    b\"edge1\",\n                    [279.7405, 3479273021651468, [12.75848776102066, 38.78813451624225]],\n                ],\n            ]  # Returns locations within the square box of 400 km, with the center being a specific point, from nearest to farthest with the dist, hash and coords.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = _create_geosearch_args(\n        [key],\n        search_from,\n        search_by,\n        order_by,\n        count,\n        with_coord,\n        with_dist,\n        with_hash,\n    )\n\n    return cast(\n        List[Union[bytes, List[Union[bytes, float, int, List[float]]]]],\n        await self._execute_command(RequestType.GeoSearch, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.geosearchstore","title":"<code>geosearchstore(destination, source, search_from, search_by, count=None, store_dist=False)</code>  <code>async</code>","text":"<p>Searches for members in a sorted set stored at <code>key</code> representing geospatial data within a circular or rectangular area and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created.</p> <p>To get the result directly, see <code>geosearch</code>.</p> Note <p>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Args:     destination (TEncodable): The key to store the search results.     source (TEncodable): The key of the sorted set representing geospatial data to search from.     search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member         from the sorted set or as a geospatial data (see <code>GeospatialData</code>).     search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.         For circular area search, see <code>GeoSearchByRadius</code>.         For rectangular area search, see <code>GeoSearchByBox</code>.     count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See <code>GeoSearchCount</code>.         If not specified, stores all results.     store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.         - If set to False, the geohash of the location will be stored as the sorted set score.         - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.             The distance is represented as a floating-point number in the same unit specified for that shape.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n&gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n    2 # Number of elements stored in \"my_dest_sorted_set\".\n&gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n    {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n&gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n    2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n    {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def geosearchstore(\n    self,\n    destination: TEncodable,\n    source: TEncodable,\n    search_from: Union[str, bytes, GeospatialData],\n    search_by: Union[GeoSearchByRadius, GeoSearchByBox],\n    count: Optional[GeoSearchCount] = None,\n    store_dist: bool = False,\n) -&gt; int:\n    \"\"\"\n    Searches for members in a sorted set stored at `key` representing geospatial data within a circular or rectangular area and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n\n    To get the result directly, see `geosearch`.\n\n    Note:\n        When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n        Args:\n            destination (TEncodable): The key to store the search results.\n            source (TEncodable): The key of the sorted set representing geospatial data to search from.\n            search_from (Union[str, bytes, GeospatialData]): The location to search from. Can be specified either as a member\n                from the sorted set or as a geospatial data (see `GeospatialData`).\n            search_by (Union[GeoSearchByRadius, GeoSearchByBox]): The search criteria.\n                For circular area search, see `GeoSearchByRadius`.\n                For rectangular area search, see `GeoSearchByBox`.\n            count (Optional[GeoSearchCount]): Specifies the maximum number of results to store. See `GeoSearchCount`.\n                If not specified, stores all results.\n            store_dist (bool): Determines what is stored as the sorted set score. Defaults to False.\n                - If set to False, the geohash of the location will be stored as the sorted set score.\n                - If set to True, the distance from the center of the shape (circle or box) will be stored as the sorted set score.\n                    The distance is represented as a floating-point number in the same unit specified for that shape.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.geoadd(\"my_geo_sorted_set\", {\"Palermo\": GeospatialData(13.361389, 38.115556), \"Catania\": GeospatialData(15.087269, 37.502669)})\n        &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", \"Catania\", GeoSearchByRadius(175, GeoUnit.MILES))\n            2 # Number of elements stored in \"my_dest_sorted_set\".\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n            {b\"Palermo\": 3479099956230698.0, b\"Catania\": 3479447370796909.0} # The elements within te search area, with their geohash as score.\n        &gt;&gt;&gt; await client.geosearchstore(\"my_dest_sorted_set\", \"my_geo_sorted_set\", GeospatialData(15, 37), GeoSearchByBox(400, 400, GeoUnit.KILOMETERS), store_dist=True)\n            2 # Number of elements stored in \"my_dest_sorted_set\", with distance as score.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_dest_sorted_set\", RangeByIndex(0, -1))\n            {b\"Catania\": 56.4412578701582, b\"Palermo\": 190.44242984775784} # The elements within te search area, with the distance as score.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = _create_geosearch_args(\n        [destination, source],\n        search_from,\n        search_by,\n        None,\n        count,\n        False,\n        False,\n        False,\n        store_dist,\n    )\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.GeoSearchStore, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.get","title":"<code>get(key)</code>  <code>async</code>","text":"<p>Get the value associated with the given key, or null if no such value exists. See https://valkey.io/commands/get/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.</p> Example <p>await client.get(\"key\")     b'value'</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def get(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Get the value associated with the given key, or null if no such value exists.\n    See https://valkey.io/commands/get/ for details.\n\n    Args:\n        key (TEncodable): The key to retrieve from the database.\n\n    Returns:\n        Optional[bytes]: If the key exists, returns the value of the key as a byte string. Otherwise, return None.\n\n    Example:\n        &gt;&gt;&gt; await client.get(\"key\")\n            b'value'\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(Optional[bytes], await self._execute_command(RequestType.Get, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.get_pubsub_message","title":"<code>get_pubsub_message()</code>  <code>async</code>","text":"<p>Returns the next pubsub message. Throws WrongConfiguration in cases: 1. No pubsub subscriptions are configured for the client 2. Callback is configured with the pubsub subsciptions</p> <p>See https://valkey.io/docs/topics/pubsub/ for more details.</p> <p>Returns:</p> Name Type Description <code>PubSubMsg</code> <code>PubSubMsg</code> <p>The next pubsub message</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def get_pubsub_message(self) -&gt; PubSubMsg:\n    \"\"\"\n    Returns the next pubsub message.\n    Throws WrongConfiguration in cases:\n    1. No pubsub subscriptions are configured for the client\n    2. Callback is configured with the pubsub subsciptions\n\n    See https://valkey.io/docs/topics/pubsub/ for more details.\n\n    Returns:\n        PubSubMsg: The next pubsub message\n\n    Examples:\n        &gt;&gt;&gt; pubsub_msg = await listening_client.get_pubsub_message()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.getbit","title":"<code>getbit(key, offset)</code>  <code>async</code>","text":"<p>Returns the bit value at <code>offset</code> in the string value stored at <code>key</code>. <code>offset</code> should be greater than or equal to zero.</p> <p>See https://valkey.io/commands/getbit for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>offset</code> <code>int</code> <p>The index of the bit to return.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The bit at the given <code>offset</code> of the string. Returns <code>0</code> if the key is empty or if the <code>offset</code> exceeds the length of the string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n    1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getbit(self, key: TEncodable, offset: int) -&gt; int:\n    \"\"\"\n    Returns the bit value at `offset` in the string value stored at `key`.\n    `offset` should be greater than or equal to zero.\n\n    See https://valkey.io/commands/getbit for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        offset (int): The index of the bit to return.\n\n    Returns:\n        int: The bit at the given `offset` of the string. Returns `0` if the key is empty or if the `offset` exceeds\n            the length of the string.\n\n    Examples:\n        &gt;&gt;&gt; await client.getbit(\"my_key\", 1)\n            1  # Indicates that the second bit of the string stored at \"my_key\" is set to 1.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.GetBit, [key, str(offset)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.getdel","title":"<code>getdel(key)</code>  <code>async</code>","text":"<p>Gets a value associated with the given string <code>key</code> and deletes the key.</p> <p>See https://valkey.io/commands/getdel for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, returns the <code>value</code> of <code>key</code>. Otherwise, returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.getdel(\"key\")\n    b'value'\n&gt;&gt;&gt; await client.getdel(\"key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getdel(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Gets a value associated with the given string `key` and deletes the key.\n\n    See https://valkey.io/commands/getdel for more details.\n\n    Args:\n        key (TEncodable): The `key` to retrieve from the database.\n\n    Returns:\n        Optional[bytes]: If `key` exists, returns the `value` of `key`. Otherwise, returns `None`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.getdel(\"key\")\n            b'value'\n        &gt;&gt;&gt; await client.getdel(\"key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.GetDel, [key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.getex","title":"<code>getex(key, expiry=None)</code>  <code>async</code>","text":"<p>Get the value of <code>key</code> and optionally set its expiration. <code>GETEX</code> is similar to <code>GET</code>. See https://valkey.io/commands/getex for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to get.</p> required <code>expiry</code> <code>Optional[ExpiryGetEx]</code> <p>set expiriation to the given key. Equivalent to [<code>EX</code> | <code>PX</code> | <code>EXAT</code> | <code>PXAT</code> | <code>PERSIST</code>] in the Valkey API.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, return the value stored at <code>key</code> If <code>key</code> does not exist, return <code>None</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n    'OK'\n&gt;&gt;&gt; await client.getex(\"key\")\n    b'value'\n&gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n    b'value'\n&gt;&gt;&gt; time.sleep(1)\n&gt;&gt;&gt; await client.getex(b\"key\")\n    None\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getex(\n    self,\n    key: TEncodable,\n    expiry: Optional[ExpiryGetEx] = None,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Get the value of `key` and optionally set its expiration. `GETEX` is similar to `GET`.\n    See https://valkey.io/commands/getex for more details.\n\n    Args:\n        key (TEncodable): The key to get.\n        expiry (Optional[ExpiryGetEx], optional): set expiriation to the given key.\n            Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `PERSIST`] in the Valkey API.\n\n    Returns:\n        Optional[bytes]:\n            If `key` exists, return the value stored at `key`\n            If `key` does not exist, return `None`\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n            'OK'\n        &gt;&gt;&gt; await client.getex(\"key\")\n            b'value'\n        &gt;&gt;&gt; await client.getex(\"key\", ExpiryGetEx(ExpiryTypeGetEx.SEC, 1))\n            b'value'\n        &gt;&gt;&gt; time.sleep(1)\n        &gt;&gt;&gt; await client.getex(b\"key\")\n            None\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args = [key]\n    if expiry is not None:\n        args.extend(expiry.get_cmd_args())\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.GetEx, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.getrange","title":"<code>getrange(key, start, end)</code>  <code>async</code>","text":"<p>Returns the substring of the value stored at <code>key</code>, determined by the offsets <code>start</code> and <code>end</code> (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the value. So <code>-1</code> means the last character, <code>-2</code> the penultimate and so forth.</p> <p>If <code>key</code> does not exist, an empty byte string is returned. If <code>start</code> or <code>end</code> are out of range, returns the substring within the valid range of the value.</p> <p>See https://valkey.io/commands/getrange/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>start</code> <code>int</code> <p>The starting offset.</p> required <code>end</code> <code>int</code> <p>The ending offset.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>A substring extracted from the value stored at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n&gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n    b\"This\"\n&gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n    b\"ing\"  # extracted last 3 characters of a string\n&gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n    b\"This is a string\"\n&gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n    b\"\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def getrange(self, key: TEncodable, start: int, end: int) -&gt; bytes:\n    \"\"\"\n    Returns the substring of the value stored at `key`, determined by the offsets `start` and `end` (both are inclusive).\n    Negative offsets can be used in order to provide an offset starting from the end of the value.\n    So `-1` means the last character, `-2` the penultimate and so forth.\n\n    If `key` does not exist, an empty byte string is returned. If `start` or `end`\n    are out of range, returns the substring within the valid range of the value.\n\n    See https://valkey.io/commands/getrange/ for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        start (int): The starting offset.\n        end (int): The ending offset.\n\n    Returns:\n        bytes: A substring extracted from the value stored at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"mykey\", \"This is a string\")\n        &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 3)\n            b\"This\"\n        &gt;&gt;&gt; await client.getrange(\"mykey\", -3, -1)\n            b\"ing\"  # extracted last 3 characters of a string\n        &gt;&gt;&gt; await client.getrange(\"mykey\", 0, 100)\n            b\"This is a string\"\n        &gt;&gt;&gt; await client.getrange(\"non_existing\", 5, 6)\n            b\"\"\n    \"\"\"\n    return cast(\n        bytes,\n        await self._execute_command(\n            RequestType.GetRange, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hdel","title":"<code>hdel(key, fields)</code>  <code>async</code>","text":"<p>Remove specified fields from the hash stored at <code>key</code>. See https://valkey.io/commands/hdel/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>fields</code> <code>List[TEncodable]</code> <p>The list of fields to remove from the hash stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields that were removed from the hash, excluding specified but non-existing fields.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty hash, and the function returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n    2  # Indicates that two fields were successfully removed from the hash.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hdel(self, key: TEncodable, fields: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Remove specified fields from the hash stored at `key`.\n    See https://valkey.io/commands/hdel/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        fields (List[TEncodable]): The list of fields to remove from the hash stored at `key`.\n\n    Returns:\n        int: The number of fields that were removed from the hash, excluding specified but non-existing fields.\n        If `key` does not exist, it is treated as an empty hash, and the function returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.hdel(\"my_hash\", [\"field1\", \"field2\"])\n            2  # Indicates that two fields were successfully removed from the hash.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.HDel, [key] + fields))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hexists","title":"<code>hexists(key, field)</code>  <code>async</code>","text":"<p>Check if a field exists in the hash stored at <code>key</code>. See https://valkey.io/commands/hexists/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field to check in the hash stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns 'True' if the hash contains the specified field. If the hash does not contain the field, or if the key does not exist, it returns 'False'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n    True\n&gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n    False\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hexists(self, key: TEncodable, field: TEncodable) -&gt; bool:\n    \"\"\"\n    Check if a field exists in the hash stored at `key`.\n    See https://valkey.io/commands/hexists/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field to check in the hash stored at `key`.\n\n    Returns:\n        bool: Returns 'True' if the hash contains the specified field. If the hash does not contain the field,\n            or if the key does not exist, it returns 'False'.\n\n    Examples:\n        &gt;&gt;&gt; await client.hexists(\"my_hash\", \"field1\")\n            True\n        &gt;&gt;&gt; await client.hexists(\"my_hash\", \"nonexistent_field\")\n            False\n    \"\"\"\n    return cast(\n        bool, await self._execute_command(RequestType.HExists, [key, field])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hget","title":"<code>hget(key, field)</code>  <code>async</code>","text":"<p>Retrieves the value associated with <code>field</code> in the hash stored at <code>key</code>. See https://valkey.io/commands/hget/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field whose value should be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value associated <code>field</code> in the hash.</p> <code>Optional[bytes]</code> <p>Returns None if <code>field</code> is not presented in the hash or <code>key</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n&gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n    b\"value\"\n&gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hget(self, key: TEncodable, field: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Retrieves the value associated with `field` in the hash stored at `key`.\n    See https://valkey.io/commands/hget/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field whose value should be retrieved.\n\n    Returns:\n        Optional[bytes]: The value associated `field` in the hash.\n        Returns None if `field` is not presented in the hash or `key` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n        &gt;&gt;&gt; await client.hget(\"my_hash\", \"field\")\n            b\"value\"\n        &gt;&gt;&gt; await client.hget(\"my_hash\", \"nonexistent_field\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.HGet, [key, field]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hgetall","title":"<code>hgetall(key)</code>  <code>async</code>","text":"<p>Returns all fields and values of the hash stored at <code>key</code>. See https://valkey.io/commands/hgetall/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Dict[bytes, bytes]</code> <p>Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by</p> <code>Dict[bytes, bytes]</code> <p>its value.</p> <code>Dict[bytes, bytes]</code> <p>If <code>key</code> does not exist, it returns an empty dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hgetall(\"my_hash\")\n    {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hgetall(self, key: TEncodable) -&gt; Dict[bytes, bytes]:\n    \"\"\"\n    Returns all fields and values of the hash stored at `key`.\n    See https://valkey.io/commands/hgetall/ for details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        Dict[bytes, bytes]: A dictionary of fields and their values stored in the hash. Every field name in the list is followed by\n        its value.\n        If `key` does not exist, it returns an empty dictionary.\n\n    Examples:\n        &gt;&gt;&gt; await client.hgetall(\"my_hash\")\n            {b\"field1\": b\"value1\", b\"field2\": b\"value2\"}\n    \"\"\"\n    return cast(\n        Dict[bytes, bytes], await self._execute_command(RequestType.HGetAll, [key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hincrby","title":"<code>hincrby(key, field, amount)</code>  <code>async</code>","text":"<p>Increment or decrement the value of a <code>field</code> in the hash stored at <code>key</code> by the specified amount. By using a negative increment value, the value stored at <code>field</code> in the hash stored at <code>key</code> is decremented. If <code>field</code> or <code>key</code> does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/hincrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash stored at <code>key</code> to increment or decrement its value.</p> required <code>amount</code> <code>int</code> <p>The amount by which to increment or decrement the field's value. Use a negative value to decrement.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of the specified field in the hash stored at <code>key</code> after the increment or decrement.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n    5\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hincrby(self, key: TEncodable, field: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Increment or decrement the value of a `field` in the hash stored at `key` by the specified amount.\n    By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n    If `field` or `key` does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/hincrby/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n        amount (int): The amount by which to increment or decrement the field's value.\n            Use a negative value to decrement.\n\n    Returns:\n        int: The value of the specified field in the hash stored at `key` after the increment or decrement.\n\n    Examples:\n        &gt;&gt;&gt; await client.hincrby(\"my_hash\", \"field1\", 5)\n            5\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.HIncrBy, [key, field, str(amount)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hincrbyfloat","title":"<code>hincrbyfloat(key, field, amount)</code>  <code>async</code>","text":"<p>Increment or decrement the floating-point value stored at <code>field</code> in the hash stored at <code>key</code> by the specified amount. By using a negative increment value, the value stored at <code>field</code> in the hash stored at <code>key</code> is decremented. If <code>field</code> or <code>key</code> does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/hincrbyfloat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash stored at <code>key</code> to increment or decrement its value.</p> required <code>amount</code> <code>float</code> <p>The amount by which to increment or decrement the field's value. Use a negative value to decrement.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the specified field in the hash stored at <code>key</code> after the increment as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n    \"2.5\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hincrbyfloat(\n    self, key: TEncodable, field: TEncodable, amount: float\n) -&gt; float:\n    \"\"\"\n    Increment or decrement the floating-point value stored at `field` in the hash stored at `key` by the specified\n    amount.\n    By using a negative increment value, the value stored at `field` in the hash stored at `key` is decremented.\n    If `field` or `key` does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/hincrbyfloat/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash stored at `key` to increment or decrement its value.\n        amount (float): The amount by which to increment or decrement the field's value.\n            Use a negative value to decrement.\n\n    Returns:\n        float: The value of the specified field in the hash stored at `key` after the increment as a string.\n\n    Examples:\n        &gt;&gt;&gt; await client.hincrbyfloat(\"my_hash\", \"field1\", 2.5)\n            \"2.5\"\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(\n            RequestType.HIncrByFloat, [key, field, str(amount)]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hkeys","title":"<code>hkeys(key)</code>  <code>async</code>","text":"<p>Returns all field names in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hkeys/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hkeys(\"my_hash\")\n    [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hkeys(self, key: TEncodable) -&gt; List[bytes]:\n    \"\"\"\n    Returns all field names in the hash stored at `key`.\n\n    See https://valkey.io/commands/hkeys/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        List[bytes]: A list of field names for the hash, or an empty list when the key does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hkeys(\"my_hash\")\n            [b\"field1\", b\"field2\", b\"field3\"]  # Returns all the field names stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(List[bytes], await self._execute_command(RequestType.HKeys, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hlen","title":"<code>hlen(key)</code>  <code>async</code>","text":"<p>Returns the number of fields contained in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields in the hash, or 0 when the key does not exist.</p> <code>int</code> <p>If <code>key</code> holds a value that is not a hash, an error is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hlen(\"my_hash\")\n    3\n&gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n    0\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the number of fields contained in the hash stored at `key`.\n\n    See https://valkey.io/commands/hlen/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        int: The number of fields in the hash, or 0 when the key does not exist.\n        If `key` holds a value that is not a hash, an error is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.hlen(\"my_hash\")\n            3\n        &gt;&gt;&gt; await client.hlen(\"non_existing_key\")\n            0\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.HLen, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hmget","title":"<code>hmget(key, fields)</code>  <code>async</code>","text":"<p>Retrieve the values associated with specified fields in the hash stored at <code>key</code>. See https://valkey.io/commands/hmget/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>fields</code> <code>List[TEncodable]</code> <p>The list of fields in the hash stored at <code>key</code> to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.</p> <code>List[Optional[bytes]]</code> <p>For every field that does not exist in the hash, a null value is returned.</p> <code>List[Optional[bytes]]</code> <p>If <code>key</code> does not exist, it is treated as an empty hash, and the function returns a list of null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n    [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hmget(\n    self, key: TEncodable, fields: List[TEncodable]\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Retrieve the values associated with specified fields in the hash stored at `key`.\n    See https://valkey.io/commands/hmget/ for details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        fields (List[TEncodable]): The list of fields in the hash stored at `key` to retrieve from the database.\n\n    Returns:\n        List[Optional[bytes]]: A list of values associated with the given fields, in the same order as they are requested.\n        For every field that does not exist in the hash, a null value is returned.\n        If `key` does not exist, it is treated as an empty hash, and the function returns a list of null values.\n\n    Examples:\n        &gt;&gt;&gt; await client.hmget(\"my_hash\", [\"field1\", \"field2\"])\n            [b\"value1\", b\"value2\"]  # A list of values associated with the specified fields.\n    \"\"\"\n    return cast(\n        List[Optional[bytes]],\n        await self._execute_command(RequestType.HMGet, [key] + fields),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hrandfield","title":"<code>hrandfield(key)</code>  <code>async</code>","text":"<p>Returns a random field name from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random field name from the hash stored at <code>key</code>.</p> <code>Optional[bytes]</code> <p>If the hash does not exist or is empty, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n    b\"field1\"  # A random field name stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random field name from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        Optional[bytes]: A random field name from the hash stored at `key`.\n        If the hash does not exist or is empty, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield(\"my_hash\")\n            b\"field1\"  # A random field name stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.HRandField, [key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hrandfield_count","title":"<code>hrandfield_count(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to <code>count</code> random field names from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>count</code> <code>int</code> <p>The number of field names to return. If <code>count</code> is positive, returns unique elements. If <code>count</code> is negative, allows for duplicates elements.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of random field names from the hash.</p> <code>List[bytes]</code> <p>If the hash does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n    [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n&gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n    []  # Empty list\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieves up to `count` random field names from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        count (int): The number of field names to return.\n            If `count` is positive, returns unique elements.\n            If `count` is negative, allows for duplicates elements.\n\n    Returns:\n        List[bytes]: A list of random field names from the hash.\n        If the hash does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield_count(\"my_hash\", -3)\n            [b\"field1\", b\"field1\", b\"field2\"]  # Non-distinct, random field names stored in the hash \"my_hash\".\n        &gt;&gt;&gt; await client.hrandfield_count(\"non_existing_hash\", 3)\n            []  # Empty list\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.HRandField, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hrandfield_withvalues","title":"<code>hrandfield_withvalues(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to <code>count</code> random field names along with their values from the hash value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hrandfield for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>count</code> <code>int</code> <p>The number of field names to return. If <code>count</code> is positive, returns unique elements. If <code>count</code> is negative, allows for duplicates elements.</p> required <p>Returns:</p> Type Description <code>List[List[bytes]]</code> <p>List[List[bytes]]: A list of <code>[field_name, value]</code> lists, where <code>field_name</code> is a random field name from the</p> <code>List[List[bytes]]</code> <p>hash and <code>value</code> is the associated value of the field name.</p> <code>List[List[bytes]]</code> <p>If the hash does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n    [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hrandfield_withvalues(\n    self, key: TEncodable, count: int\n) -&gt; List[List[bytes]]:\n    \"\"\"\n    Retrieves up to `count` random field names along with their values from the hash value stored at `key`.\n\n    See https://valkey.io/commands/hrandfield for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        count (int): The number of field names to return.\n            If `count` is positive, returns unique elements.\n            If `count` is negative, allows for duplicates elements.\n\n    Returns:\n        List[List[bytes]]: A list of `[field_name, value]` lists, where `field_name` is a random field name from the\n        hash and `value` is the associated value of the field name.\n        If the hash does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.hrandfield_withvalues(\"my_hash\", -3)\n            [[b\"field1\", b\"value1\"], [b\"field1\", b\"value1\"], [b\"field2\", b\"value2\"]]\n    \"\"\"\n    return cast(\n        List[List[bytes]],\n        await self._execute_command(\n            RequestType.HRandField, [key, str(count), \"WITHVALUES\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hscan","title":"<code>hscan(key, cursor, match=None, count=None, no_values=False)</code>  <code>async</code>","text":"<p>Iterates incrementally over a hash.</p> <p>See https://valkey.io/commands/hscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a subset of the hash then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the hash. <code>COUNT</code> could be ignored until the hash is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <code>no_values</code> <code>bool</code> <p>If <code>True</code>, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the hash held by <code>key</code>. The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code> returned on the last iteration of the hash. The second element is always an <code>Array</code> of the subset of the hash held in <code>key</code>. The <code>Array</code> in the second element is a flattened series of <code>String</code> pairs, where the value is at even indices and the score is at odd indices. If <code>no_values</code> is set to <code>True</code>, the second element will only contain the fields without the values.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hscan--assume-key-contains-a-hash-with-multiple-members","title":"Assume \"key\" contains a hash with multiple members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 1\nMembers: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\nCursor: 39\nMembers: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\nCursor: 0\nMembers: [b'field 420', b'value 420', b'field 221', b'value 221']\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hscan--use-no-values","title":"Use no-values","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 1\nMembers: [b'field 79',b'field 20', b'field 115']\nCursor: 39\nMembers: [b'field 63', b'field 293', b'field 162']\nCursor: 0\nMembers: [b'field 420', b'field 221']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    no_values: bool = False,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a hash.\n\n    See https://valkey.io/commands/hscan for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the hash is large enough for scan commands to return only a\n            subset of the hash then there could be a case where the result is empty although there are items that\n            match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n            only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the hash.\n            `COUNT` could be ignored until the hash is large enough for the `SCAN` commands to represent the results\n            as compact single-allocation packed encoding.\n        no_values (bool): If `True`, the command will not return values the fields in the hash. Since Valkey \"8.0.0\".\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the hash held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the hash. The second element is always an `Array` of the subset of the\n            hash held in `key`. The `Array` in the second element is a flattened series of `String` pairs,\n            where the value is at even indices and the score is at odd indices.\n            If `no_values` is set to `True`, the second element will only contain the fields without the values.\n\n    Examples:\n        # Assume \"key\" contains a hash with multiple members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 1\n        Members: [b'field 79', b'value 79', b'field 20', b'value 20', b'field 115', b'value 115']\n        Cursor: 39\n        Members: [b'field 63', b'value 63', b'field 293', b'value 293', b'field 162', b'value 162']\n        Cursor: 0\n        Members: [b'field 420', b'value 420', b'field 221', b'value 221']\n\n        # Use no-values\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.hscan(\"key\", \"0\", match=\"*\", count=3, no_values=True)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 1\n        Members: [b'field 79',b'field 20', b'field 115']\n        Cursor: 39\n        Members: [b'field 63', b'field 293', b'field 162']\n        Cursor: 0\n        Members: [b'field 420', b'field 221']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n    if no_values:\n        args.append(\"NOVALUES\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.HScan, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hset","title":"<code>hset(key, field_value_map)</code>  <code>async</code>","text":"<p>Sets the specified fields to their respective values in the hash stored at <code>key</code>. See https://valkey.io/commands/hset/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A field-value map consisting of fields and their corresponding values</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of fields that were added to the hash.</p> Example <p>await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})     2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hset(\n    self,\n    key: TEncodable,\n    field_value_map: Mapping[TEncodable, TEncodable],\n) -&gt; int:\n    \"\"\"\n    Sets the specified fields to their respective values in the hash stored at `key`.\n    See https://valkey.io/commands/hset/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field_value_map (Mapping[TEncodable, TEncodable]): A field-value map consisting of fields and their corresponding values\n        to be set in the hash stored at the specified key.\n\n    Returns:\n        int: The number of fields that were added to the hash.\n\n    Example:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", {\"field\": \"value\", \"field2\": \"value2\"})\n            2 # Indicates that 2 fields were successfully set in the hash \"my_hash\".\n    \"\"\"\n    field_value_list: List[TEncodable] = [key]\n    for pair in field_value_map.items():\n        field_value_list.extend(pair)\n    return cast(\n        int,\n        await self._execute_command(RequestType.HSet, field_value_list),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hsetnx","title":"<code>hsetnx(key, field, value)</code>  <code>async</code>","text":"<p>Sets <code>field</code> in the hash stored at <code>key</code> to <code>value</code>, only if <code>field</code> does not yet exist. If <code>key</code> does not exist, a new key holding a hash is created. If <code>field</code> already exists, this operation has no effect. See https://valkey.io/commands/hsetnx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field to set the value for.</p> required <code>value</code> <code>TEncodable</code> <p>The value to set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the field was set, False if the field already existed and was not set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n    True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n&gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n    False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hsetnx(\n    self,\n    key: TEncodable,\n    field: TEncodable,\n    value: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Sets `field` in the hash stored at `key` to `value`, only if `field` does not yet exist.\n    If `key` does not exist, a new key holding a hash is created.\n    If `field` already exists, this operation has no effect.\n    See https://valkey.io/commands/hsetnx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field to set the value for.\n        value (TEncodable): The value to set.\n\n    Returns:\n        bool: True if the field was set, False if the field already existed and was not set.\n\n    Examples:\n        &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"value\")\n            True  # Indicates that the field \"field\" was set successfully in the hash \"my_hash\".\n        &gt;&gt;&gt; await client.hsetnx(\"my_hash\", \"field\", \"new_value\")\n            False # Indicates that the field \"field\" already existed in the hash \"my_hash\" and was not set again.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.HSetNX, [key, field, value]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hstrlen","title":"<code>hstrlen(key, field)</code>  <code>async</code>","text":"<p>Returns the string length of the value associated with <code>field</code> in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hstrlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <code>field</code> <code>TEncodable</code> <p>The field in the hash.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The string length or 0 if <code>field</code> or <code>key</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n&gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n    5\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hstrlen(self, key: TEncodable, field: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the string length of the value associated with `field` in the hash stored at `key`.\n\n    See https://valkey.io/commands/hstrlen/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n        field (TEncodable): The field in the hash.\n\n    Returns:\n        int: The string length or 0 if `field` or `key` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.hset(\"my_hash\", \"field\", \"value\")\n        &gt;&gt;&gt; await client.hstrlen(\"my_hash\", \"my_field\")\n            5\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.HStrlen, [key, field]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.hvals","title":"<code>hvals(key)</code>  <code>async</code>","text":"<p>Returns all values in the hash stored at <code>key</code>.</p> <p>See https://valkey.io/commands/hvals/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of values in the hash, or an empty list when the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.hvals(\"my_hash\")\n    [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def hvals(self, key: TEncodable) -&gt; List[bytes]:\n    \"\"\"\n    Returns all values in the hash stored at `key`.\n\n    See https://valkey.io/commands/hvals/ for more details.\n\n    Args:\n        key (TEncodable): The key of the hash.\n\n    Returns:\n        List[bytes]: A list of values in the hash, or an empty list when the key does not exist.\n\n    Examples:\n       &gt;&gt;&gt; await client.hvals(\"my_hash\")\n           [b\"value1\", b\"value2\", b\"value3\"]  # Returns all the values stored in the hash \"my_hash\".\n    \"\"\"\n    return cast(List[bytes], await self._execute_command(RequestType.HVals, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.incr","title":"<code>incr(key)</code>  <code>async</code>","text":"<p>Increments the number stored at <code>key</code> by one. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incr/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of <code>key</code> after the increment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.incr(\"key\")\n    11\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incr(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Increments the number stored at `key` by one. If the key does not exist, it is set to 0 before performing the\n    operation.\n    See https://valkey.io/commands/incr/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n\n    Returns:\n        int: The value of `key` after the increment.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incr(\"key\")\n            11\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Incr, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.incrby","title":"<code>incrby(key, amount)</code>  <code>async</code>","text":"<p>Increments the number stored at <code>key</code> by <code>amount</code>. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <code>amount</code> <code>int) </code> <p>The amount to increment.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of key after the increment.</p> Example <p>await client.set(\"key\", \"10\") await client.incrby(\"key\" , 5)     15</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incrby(self, key: TEncodable, amount: int) -&gt; int:\n    \"\"\"\n    Increments the number stored at `key` by `amount`. If the key does not exist, it is set to 0 before performing\n    the operation. See https://valkey.io/commands/incrby/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n      amount (int) : The amount to increment.\n\n    Returns:\n        int: The value of key after the increment.\n\n    Example:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incrby(\"key\" , 5)\n            15\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.IncrBy, [key, str(amount)])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.incrbyfloat","title":"<code>incrbyfloat(key, amount)</code>  <code>async</code>","text":"<p>Increment the string representing a floating point number stored at <code>key</code> by <code>amount</code>. By using a negative increment value, the value stored at the <code>key</code> is decremented. If the key does not exist, it is set to 0 before performing the operation. See https://valkey.io/commands/incrbyfloat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to increment its value.</p> required <code>amount</code> <code>float) </code> <p>The amount to increment.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of key after the increment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"10\")\n&gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n    15.55\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def incrbyfloat(self, key: TEncodable, amount: float) -&gt; float:\n    \"\"\"\n    Increment the string representing a floating point number stored at `key` by `amount`.\n    By using a negative increment value, the value stored at the `key` is decremented.\n    If the key does not exist, it is set to 0 before performing the operation.\n    See https://valkey.io/commands/incrbyfloat/ for more details.\n\n    Args:\n      key (TEncodable): The key to increment its value.\n      amount (float) : The amount to increment.\n\n    Returns:\n        float: The value of key after the increment.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"10\")\n        &gt;&gt;&gt; await client.incrbyfloat(\"key\" , 5.5)\n            15.55\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(RequestType.IncrByFloat, [key, str(amount)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lcs","title":"<code>lcs(key1, key2)</code>  <code>async</code>","text":"<p>Returns the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A Bytes String containing the longest common subsequence between the 2 strings.</p> <code>bytes</code> <p>An empty String is returned if the keys do not exist or have no common subsequences.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n    b'OK'\n&gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n    b'acd'\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n) -&gt; bytes:\n    \"\"\"\n    Returns the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string.\n        key2 (TEncodable): The key that stores the second string.\n\n    Returns:\n        A Bytes String containing the longest common subsequence between the 2 strings.\n        An empty String is returned if the keys do not exist or have no common subsequences.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n            b'OK'\n        &gt;&gt;&gt; await client.lcs(\"testKey1\", \"testKey2\")\n            b'acd'\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2]\n\n    return cast(\n        bytes,\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lcs_idx","title":"<code>lcs_idx(key1, key2, min_match_len=None, with_match_len=False)</code>  <code>async</code>","text":"<p>Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string value.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string value.</p> required <code>min_match_len</code> <code>Optional[int]</code> <p>The minimum length of matches to include in the result.</p> <code>None</code> <code>with_match_len</code> <code>Optional[bool]</code> <p>If True, include the length of the substring matched for each substring.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>A Mapping containing the indices of the longest common subsequence between the</p> <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>2 strings and the length of the longest common subsequence. The resulting map contains two</p> <code>Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]</code> <p>keys, \"matches\" and \"len\": - \"len\" is mapped to the length of the longest common subsequence between the 2 strings. - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that   represent the location of the common subsequences in the strings held by key1 and key2,   with the length of the match after each matches, if with_match_len is enabled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n    'OK'\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n    {\n        b'matches': [\n            [\n                [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n            ],\n            [\n                [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n            ],\n        ],\n        b'len': 7  # length of the entire longest common subsequence\n    }\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n    {\n        b'matches': [\n            [\n                [4, 7],\n                [5, 8],\n            ],\n            # the other match with a length of 3 is excluded\n        ],\n        b'len': 7\n    }\n&gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n    {\n        b'matches': [\n            [\n                [4, 7],\n                [5, 8],\n                4,  # length of this match (b\"1234\")\n            ],\n            [\n                [1, 3],\n                [0, 2],\n                3,  # length of this match (b\"bcd\")\n            ],\n        ],\n        b'len': 7\n    }\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs_idx(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n    min_match_len: Optional[int] = None,\n    with_match_len: Optional[bool] = False,\n) -&gt; Mapping[bytes, Union[List[List[Union[List[int], int]]], int]]:\n    \"\"\"\n    Returns the indices and length of the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string value.\n        key2 (TEncodable): The key that stores the second string value.\n        min_match_len (Optional[int]): The minimum length of matches to include in the result.\n        with_match_len (Optional[bool]): If True, include the length of the substring matched for each substring.\n\n    Returns:\n        A Mapping containing the indices of the longest common subsequence between the\n        2 strings and the length of the longest common subsequence. The resulting map contains two\n        keys, \"matches\" and \"len\":\n            - \"len\" is mapped to the length of the longest common subsequence between the 2 strings.\n            - \"matches\" is mapped to a three dimensional int array that stores pairs of indices that\n              represent the location of the common subsequences in the strings held by key1 and key2,\n              with the length of the match after each matches, if with_match_len is enabled.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd1234\", \"testKey2\": \"bcdef1234\"})\n            'OK'\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\")\n            {\n                b'matches': [\n                    [\n                        [4, 7],  # starting and ending indices of the subsequence b\"1234\" in b\"abcd1234\" (testKey1)\n                        [5, 8],  # starting and ending indices of the subsequence b\"1234\" in b\"bcdef1234\" (testKey2)\n                    ],\n                    [\n                        [1, 3],  # starting and ending indices of the subsequence b\"bcd\" in b\"abcd1234\" (testKey1)\n                        [0, 2],  # starting and ending indices of the subsequence b\"bcd\" in b\"bcdef1234\" (testKey2)\n                    ],\n                ],\n                b'len': 7  # length of the entire longest common subsequence\n            }\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", min_match_len=4)\n            {\n                b'matches': [\n                    [\n                        [4, 7],\n                        [5, 8],\n                    ],\n                    # the other match with a length of 3 is excluded\n                ],\n                b'len': 7\n            }\n        &gt;&gt;&gt; await client.lcs_idx(\"testKey1\", \"testKey2\", with_match_len=True)\n            {\n                b'matches': [\n                    [\n                        [4, 7],\n                        [5, 8],\n                        4,  # length of this match (b\"1234\")\n                    ],\n                    [\n                        [1, 3],\n                        [0, 2],\n                        3,  # length of this match (b\"bcd\")\n                    ],\n                ],\n                b'len': 7\n            }\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2, \"IDX\"]\n\n    if min_match_len is not None:\n        args.extend([\"MINMATCHLEN\", str(min_match_len)])\n\n    if with_match_len:\n        args.append(\"WITHMATCHLEN\")\n\n    return cast(\n        Mapping[bytes, Union[List[List[Union[List[int], int]]], int]],\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lcs_len","title":"<code>lcs_len(key1, key2)</code>  <code>async</code>","text":"<p>Returns the length of the longest common subsequence between strings stored at key1 and key2.</p> <p>Note that this is different than the longest common string algorithm, since matching characters in the two strings do not need to be contiguous.</p> <p>For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".</p> <p>See https://valkey.io/commands/lcs for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>TEncodable</code> <p>The key that stores the first string value.</p> required <code>key2</code> <code>TEncodable</code> <p>The key that stores the second string value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The length of the longest common subsequence between the 2 strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n    'OK'\n&gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n    3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lcs_len(\n    self,\n    key1: TEncodable,\n    key2: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Returns the length of the longest common subsequence between strings stored at key1 and key2.\n\n    Note that this is different than the longest common string algorithm, since\n    matching characters in the two strings do not need to be contiguous.\n\n    For instance the LCS between \"foo\" and \"fao\" is \"fo\", since scanning the two strings\n    from left to right, the longest common set of characters is composed of the first \"f\" and then the \"o\".\n\n    See https://valkey.io/commands/lcs for more details.\n\n    Args:\n        key1 (TEncodable): The key that stores the first string value.\n        key2 (TEncodable): The key that stores the second string value.\n\n    Returns:\n        The length of the longest common subsequence between the 2 strings.\n\n    Examples:\n        &gt;&gt;&gt; await client.mset({\"testKey1\" : \"abcd\", \"testKey2\": \"axcd\"})\n            'OK'\n        &gt;&gt;&gt; await client.lcs_len(\"testKey1\", \"testKey2\")\n            3  # the length of the longest common subsequence between these 2 strings (b\"acd\") is 3.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [key1, key2, \"LEN\"]\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.LCS, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lindex","title":"<code>lindex(key, index)</code>  <code>async</code>","text":"<p>Returns the element at <code>index</code> in the list stored at <code>key</code>.</p> <p>The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.</p> <p>See https://valkey.io/commands/lindex/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index of the element in the list to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The element at <code>index</code> in the list stored at <code>key</code>. If <code>index</code> is out of range or if <code>key</code> does not exist, None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n    b'value1'  # Returns the first element in the list stored at 'my_list'.\n&gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n    b'value3'  # Returns the last element in the list stored at 'my_list'.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lindex(\n    self,\n    key: TEncodable,\n    index: int,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns the element at `index` in the list stored at `key`.\n\n    The index is zero-based, so 0 means the first element, 1 the second element and so on.\n    Negative indices can be used to designate elements starting at the tail of the list.\n    Here, -1 means the last element, -2 means the penultimate and so forth.\n\n    See https://valkey.io/commands/lindex/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        index (int): The index of the element in the list to retrieve.\n\n    Returns:\n        Optional[bytes]: The element at `index` in the list stored at `key`.\n            If `index` is out of range or if `key` does not exist, None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lindex(\"my_list\", 0)\n            b'value1'  # Returns the first element in the list stored at 'my_list'.\n        &gt;&gt;&gt; await client.lindex(\"my_list\", -1)\n            b'value3'  # Returns the last element in the list stored at 'my_list'.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.LIndex, [key, str(index)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.linsert","title":"<code>linsert(key, position, pivot, element)</code>  <code>async</code>","text":"<p>Inserts <code>element</code> in the list at <code>key</code> either before or after the <code>pivot</code>.</p> <p>See https://valkey.io/commands/linsert/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>position</code> <code>InsertPosition</code> <p>The relative position to insert into - either <code>InsertPosition.BEFORE</code> or <code>InsertPosition.AFTER</code> the <code>pivot</code>.</p> required <code>pivot</code> <code>TEncodable</code> <p>An element of the list.</p> required <code>element</code> <code>TEncodable</code> <p>The new element to insert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The list length after a successful insert operation. If the <code>key</code> doesn't exist returns <code>-1</code>. If the <code>pivot</code> wasn't found, returns <code>0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n    3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def linsert(\n    self,\n    key: TEncodable,\n    position: InsertPosition,\n    pivot: TEncodable,\n    element: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Inserts `element` in the list at `key` either before or after the `pivot`.\n\n    See https://valkey.io/commands/linsert/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        position (InsertPosition): The relative position to insert into - either `InsertPosition.BEFORE` or\n            `InsertPosition.AFTER` the `pivot`.\n        pivot (TEncodable): An element of the list.\n        element (TEncodable): The new element to insert.\n\n    Returns:\n        int: The list length after a successful insert operation.\n            If the `key` doesn't exist returns `-1`.\n            If the `pivot` wasn't found, returns `0`.\n\n    Examples:\n        &gt;&gt;&gt; await client.linsert(\"my_list\", InsertPosition.BEFORE, \"World\", \"There\")\n            3 # \"There\" was inserted before \"World\", and the new length of the list is 3.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.LInsert, [key, position.value, pivot, element]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.llen","title":"<code>llen(key)</code>  <code>async</code>","text":"<p>Get the length of the list stored at <code>key</code>. See https://valkey.io/commands/llen/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list at the specified key. If <code>key</code> does not exist, it is interpreted as an empty list and 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.llen(\"my_list\")\n    3  # Indicates that there are 3 elements in the list.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def llen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Get the length of the list stored at `key`.\n    See https://valkey.io/commands/llen/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        int: The length of the list at the specified key.\n            If `key` does not exist, it is interpreted as an empty list and 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.llen(\"my_list\")\n            3  # Indicates that there are 3 elements in the list.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.LLen, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lmove","title":"<code>lmove(source, destination, where_from, where_to)</code>  <code>async</code>","text":"<p>Atomically pops and removes the left/right-most element to the list stored at <code>source</code> depending on <code>where_from</code>, and pushes the element at the first/last element of the list stored at <code>destination</code> depending on <code>where_to</code>.</p> <p>When in cluster mode, both <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/lmove/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source list.</p> required <code>destination</code> <code>TEncodable</code> <p>The key to the destination list.</p> required <code>where_from</code> <code>ListDirection</code> <p>The direction to remove the element from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>where_to</code> <code>ListDirection</code> <p>The direction to add the element to (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The popped element, or None if <code>source</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n&gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n&gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n    b\"one\"\n&gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n    [b\"two\"]\n&gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n    [b\"one\", b\"three\", b\"four\"]\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lmove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    where_from: ListDirection,\n    where_to: ListDirection,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Atomically pops and removes the left/right-most element to the list stored at `source`\n    depending on `where_from`, and pushes the element at the first/last element of the list\n    stored at `destination` depending on `where_to`.\n\n    When in cluster mode, both `source` and `destination` must map to the same hash slot.\n\n    See https://valkey.io/commands/lmove/ for details.\n\n    Args:\n        source (TEncodable): The key to the source list.\n        destination (TEncodable): The key to the destination list.\n        where_from (ListDirection): The direction to remove the element from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        where_to (ListDirection): The direction to add the element to (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n\n    Returns:\n        Optional[bytes]: The popped element, or None if `source` does not exist.\n\n    Examples:\n        &gt;&gt;&gt; client.lpush(\"testKey1\", [\"two\", \"one\"])\n        &gt;&gt;&gt; client.lpush(\"testKey2\", [\"four\", \"three\"])\n        &gt;&gt;&gt; await client.lmove(\"testKey1\", \"testKey2\", ListDirection.LEFT, ListDirection.LEFT)\n            b\"one\"\n        &gt;&gt;&gt; updated_array1 = await client.lrange(\"testKey1\", 0, -1)\n            [b\"two\"]\n        &gt;&gt;&gt; await client.lrange(\"testKey2\", 0, -1)\n            [b\"one\", b\"three\", b\"four\"]\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(\n            RequestType.LMove,\n            [source, destination, where_from.value, where_to.value],\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lmpop","title":"<code>lmpop(keys, direction, count=None)</code>  <code>async</code>","text":"<p>Pops one or more elements from the first non-empty list from the provided <code>keys</code>.</p> <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/lmpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>An array of keys of lists.</p> required <code>direction</code> <code>ListDirection</code> <p>The direction based on which elements are popped from (<code>ListDirection.LEFT</code> or <code>ListDirection.RIGHT</code>).</p> required <code>count</code> <code>Optional[int]</code> <p>The maximum number of popped elements. If not provided, defaults to popping a single element.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[bytes]]]</code> <p>Optional[Mapping[bytes, List[bytes]]]: A map of <code>key</code> name mapped to an array of popped elements, or None if no elements could be popped.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n&gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n   {b\"testKey\": [b\"three\", b\"two\"]}\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lmpop(\n    self,\n    keys: List[TEncodable],\n    direction: ListDirection,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[bytes]]]:\n    \"\"\"\n    Pops one or more elements from the first non-empty list from the provided `keys`.\n\n    When in cluster mode, all `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/lmpop/ for details.\n\n    Args:\n        keys (List[TEncodable]): An array of keys of lists.\n        direction (ListDirection): The direction based on which elements are popped from (`ListDirection.LEFT` or `ListDirection.RIGHT`).\n        count (Optional[int]): The maximum number of popped elements. If not provided, defaults to popping a single element.\n\n    Returns:\n        Optional[Mapping[bytes, List[bytes]]]: A map of `key` name mapped to an array of popped elements, or None if no elements could be popped.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"testKey\", [\"one\", \"two\", \"three\"])\n        &gt;&gt;&gt; await client.lmpop([\"testKey\"], ListDirection.LEFT, 2)\n           {b\"testKey\": [b\"three\", b\"two\"]}\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(len(keys)), *keys, direction.value]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        Optional[Mapping[bytes, List[bytes]]],\n        await self._execute_command(RequestType.LMPop, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lpop","title":"<code>lpop(key)</code>  <code>async</code>","text":"<p>Remove and return the first elements of the list stored at <code>key</code>. The command pops a single element from the beginning of the list. See https://valkey.io/commands/lpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the first element.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpop(\"my_list\")\n    b\"value1\"\n&gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Remove and return the first elements of the list stored at `key`.\n    The command pops a single element from the beginning of the list.\n    See https://valkey.io/commands/lpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        Optional[bytes]: The value of the first element.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpop(\"my_list\")\n            b\"value1\"\n        &gt;&gt;&gt; await client.lpop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.LPop, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lpop_count","title":"<code>lpop_count(key, count)</code>  <code>async</code>","text":"<p>Remove and return up to <code>count</code> elements from the list stored at <code>key</code>, depending on the list's length. See https://valkey.io/commands/lpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of elements to pop from the list.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.</p> <code>Optional[List[bytes]]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n    [b\"value1\", b\"value2\"]\n&gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Remove and return up to `count` elements from the list stored at `key`, depending on the list's length.\n    See https://valkey.io/commands/lpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of elements to pop from the list.\n\n    Returns:\n        Optional[List[bytes]]: A a list of popped elements will be returned depending on the list's length.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpop_count(\"my_list\", 2)\n            [b\"value1\", b\"value2\"]\n        &gt;&gt;&gt; await client.lpop_count(\"non_exiting_key\" , 3)\n            None\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.LPop, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lpos","title":"<code>lpos(key, element, rank=None, count=None, max_len=None)</code>  <code>async</code>","text":"<p>Returns the index or indexes of element(s) matching <code>element</code> in the <code>key</code> list. If no match is found, None is returned.</p> <p>See https://valkey.io/commands/lpos for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The name of the list.</p> required <code>element</code> <code>TEncodable</code> <p>The value to search for within the list.</p> required <code>rank</code> <code>Optional[int]</code> <p>The rank of the match to return.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>The number of matches wanted. A <code>count</code> of 0 returns all the matches.</p> <code>None</code> <code>max_len</code> <code>Optional[int]</code> <p>The maximum number of comparisons to make between the element and the items                      in the list. A <code>max_len</code> of 0 means unlimited amount of comparisons.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[int, List[int], None]</code> <p>Union[int, List[int], None]: The index of the first occurrence of <code>element</code>,</p> <code>Union[int, List[int], None]</code> <p>or None if <code>element</code> is not in the list.</p> <code>Union[int, List[int], None]</code> <p>With the <code>count</code> option, a list of indices of matching elements will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n&gt;&gt;&gt; await client.lpos(key, 'c')\n    2\n&gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n    6\n&gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n    7\n&gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n    [2, 6]\n&gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n    [2, 6, 7]\n</code></pre> <p>Since: Valkey version 6.0.6.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpos(\n    self,\n    key: TEncodable,\n    element: TEncodable,\n    rank: Optional[int] = None,\n    count: Optional[int] = None,\n    max_len: Optional[int] = None,\n) -&gt; Union[int, List[int], None]:\n    \"\"\"\n    Returns the index or indexes of element(s) matching `element` in the `key` list. If no match is found,\n    None is returned.\n\n    See https://valkey.io/commands/lpos for more details.\n\n    Args:\n        key (TEncodable): The name of the list.\n        element (TEncodable): The value to search for within the list.\n        rank (Optional[int]): The rank of the match to return.\n        count (Optional[int]): The number of matches wanted. A `count` of 0 returns all the matches.\n        max_len (Optional[int]): The maximum number of comparisons to make between the element and the items\n                                 in the list. A `max_len` of 0 means unlimited amount of comparisons.\n\n    Returns:\n        Union[int, List[int], None]: The index of the first occurrence of `element`,\n        or None if `element` is not in the list.\n        With the `count` option, a list of indices of matching elements will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpush(key, ['a', 'b', 'c', '1', '2', '3', 'c', 'c'])\n        &gt;&gt;&gt; await client.lpos(key, 'c')\n            2\n        &gt;&gt;&gt; await client.lpos(key, 'c', rank = 2)\n            6\n        &gt;&gt;&gt; await client.lpos(key, 'c', rank = -1)\n            7\n        &gt;&gt;&gt; await client.lpos(key, 'c', count = 2)\n            [2, 6]\n        &gt;&gt;&gt; await client.lpos(key, 'c', count = 0)\n            [2, 6, 7]\n\n    Since: Valkey version 6.0.6.\n    \"\"\"\n    args: List[TEncodable] = [key, element]\n\n    if rank is not None:\n        args.extend([\"RANK\", str(rank)])\n\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    if max_len is not None:\n        args.extend([\"MAXLEN\", str(max_len)])\n\n    return cast(\n        Union[int, List[int], None],\n        await self._execute_command(RequestType.LPos, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lpush","title":"<code>lpush(key, elements)</code>  <code>async</code>","text":"<p>Insert all the specified values at the head of the list stored at <code>key</code>. <code>elements</code> are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. If <code>key</code> does not exist, it is created as empty list before performing the push operations. See https://valkey.io/commands/lpush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the head of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n    3 # Indicates that the new length of the list is 3 after the push operation.\n&gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n    1\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Insert all the specified values at the head of the list stored at `key`.\n    `elements` are inserted one after the other to the head of the list, from the leftmost element\n    to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n    See https://valkey.io/commands/lpush/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operations.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"my_list\", [\"value2\", \"value3\"])\n            3 # Indicates that the new length of the list is 3 after the push operation.\n        &gt;&gt;&gt; await client.lpush(\"nonexistent_list\", [\"new_value\"])\n            1\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.LPush, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lpushx","title":"<code>lpushx(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the head of the list stored at <code>key</code>, only if <code>key</code> exists and holds a list. If <code>key</code> is not a list, this performs no operation.</p> <p>See https://valkey.io/commands/lpushx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the head of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n    3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n&gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n    0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the head of the list stored at `key`, only if `key` exists and holds a list.\n    If `key` is not a list, this performs no operation.\n\n    See https://valkey.io/commands/lpushx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the head of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operation.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpushx(\"my_list\", [\"value1\", \"value2\"])\n            3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n        &gt;&gt;&gt; await client.lpushx(\"nonexistent_list\", [\"new_value\"])\n            0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.LPushX, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lrange","title":"<code>lrange(key, start, end)</code>  <code>async</code>","text":"<p>Retrieve the specified elements of the list stored at <code>key</code> within the given range. The offsets <code>start</code> and <code>end</code> are zero-based indexes, with 0 being the first element of the list, 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last element of the list, -2 being the penultimate, and so on. See https://valkey.io/commands/lrange/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements within the specified range.</p> <code>List[bytes]</code> <p>If <code>start</code> exceeds the <code>end</code> of the list, or if <code>start</code> is greater than <code>end</code>, an empty list will be returned.</p> <code>List[bytes]</code> <p>If <code>end</code> exceeds the actual end of the list, the range will stop at the actual end of the list.</p> <code>List[bytes]</code> <p>If <code>key</code> does not exist an empty list will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n    [b\"value1\", b\"value2\", b\"value3\"]\n&gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n    [b\"value2\", b\"value3\"]\n&gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n    []\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lrange(self, key: TEncodable, start: int, end: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieve the specified elements of the list stored at `key` within the given range.\n    The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n    element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list,\n    with -1 being the last element of the list, -2 being the penultimate, and so on.\n    See https://valkey.io/commands/lrange/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        List[bytes]: A list of elements within the specified range.\n        If `start` exceeds the `end` of the list, or if `start` is greater than `end`, an empty list will be returned.\n        If `end` exceeds the actual end of the list, the range will stop at the actual end of the list.\n        If `key` does not exist an empty list will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lrange(\"my_list\", 0, 2)\n            [b\"value1\", b\"value2\", b\"value3\"]\n        &gt;&gt;&gt; await client.lrange(\"my_list\", -2, -1)\n            [b\"value2\", b\"value3\"]\n        &gt;&gt;&gt; await client.lrange(\"non_exiting_key\", 0, 2)\n            []\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(\n            RequestType.LRange, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lrem","title":"<code>lrem(key, count, element)</code>  <code>async</code>","text":"<p>Removes the first <code>count</code> occurrences of elements equal to <code>element</code> from the list stored at <code>key</code>. If <code>count</code> is positive, it removes elements equal to <code>element</code> moving from head to tail. If <code>count</code> is negative, it removes elements equal to <code>element</code> moving from tail to head. If <code>count</code> is 0 or greater than the occurrences of elements equal to <code>element</code>, it removes all elements equal to <code>element</code>. See https://valkey.io/commands/lrem/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of occurrences of elements equal to <code>element</code> to remove.</p> required <code>element</code> <code>TEncodable</code> <p>The element to remove from the list.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of removed elements. If <code>key</code> does not exist, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n    2  # Removes the first 2 occurrences of \"value\" in the list.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lrem(self, key: TEncodable, count: int, element: TEncodable) -&gt; int:\n    \"\"\"\n    Removes the first `count` occurrences of elements equal to `element` from the list stored at `key`.\n    If `count` is positive, it removes elements equal to `element` moving from head to tail.\n    If `count` is negative, it removes elements equal to `element` moving from tail to head.\n    If `count` is 0 or greater than the occurrences of elements equal to `element`, it removes all elements\n    equal to `element`.\n    See https://valkey.io/commands/lrem/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of occurrences of elements equal to `element` to remove.\n        element (TEncodable): The element to remove from the list.\n\n    Returns:\n        int: The number of removed elements.\n            If `key` does not exist, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.lrem(\"my_list\", 2, \"value\")\n            2  # Removes the first 2 occurrences of \"value\" in the list.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.LRem, [key, str(count), element]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.lset","title":"<code>lset(key, index, element)</code>  <code>async</code>","text":"<p>Sets the list element at <code>index</code> to <code>element</code>.</p> <p>The index is zero-based, so <code>0</code> means the first element, <code>1</code> the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, <code>-1</code> means the last element, <code>-2</code> means the penultimate and so forth.</p> <p>See https://valkey.io/commands/lset/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index of the element in the list to be set.</p> required <code>element</code> <code>TEncodable</code> <p>The new element to set at the specified index.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n    OK\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def lset(self, key: TEncodable, index: int, element: TEncodable) -&gt; TOK:\n    \"\"\"\n    Sets the list element at `index` to `element`.\n\n    The index is zero-based, so `0` means the first element, `1` the second element and so on.\n    Negative indices can be used to designate elements starting at the tail of the list.\n    Here, `-1` means the last element, `-2` means the penultimate and so forth.\n\n    See https://valkey.io/commands/lset/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        index (int): The index of the element in the list to be set.\n        element (TEncodable): The new element to set at the specified index.\n\n    Returns:\n        TOK: A simple `OK` response.\n\n    Examples:\n        &gt;&gt;&gt; await client.lset(\"testKey\", 1, \"two\")\n            OK\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.LSet, [key, str(index), element]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.ltrim","title":"<code>ltrim(key, start, end)</code>  <code>async</code>","text":"<p>Trim an existing list so that it will contain only the specified range of elements specified. The offsets <code>start</code> and <code>end</code> are zero-based indexes, with 0 being the first element of the list, 1 being the next element and so on. These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last element of the list, -2 being the penultimate, and so on. See https://valkey.io/commands/ltrim/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response. If <code>start</code> exceeds the end of the list, or if <code>start</code> is greater than <code>end</code>, the result will be an empty list (which causes <code>key</code> to be removed). If <code>end</code> exceeds the actual end of the list, it will be treated like the last element of the list. If <code>key</code> does not exist, \"OK\" will be returned without changes to the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n    \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def ltrim(self, key: TEncodable, start: int, end: int) -&gt; TOK:\n    \"\"\"\n    Trim an existing list so that it will contain only the specified range of elements specified.\n    The offsets `start` and `end` are zero-based indexes, with 0 being the first element of the list, 1 being the next\n    element and so on.\n    These offsets can also be negative numbers indicating offsets starting at the end of the list, with -1 being the last\n    element of the list, -2 being the penultimate, and so on.\n    See https://valkey.io/commands/ltrim/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n            If `start` exceeds the end of the list, or if `start` is greater than `end`, the result will be an empty list\n            (which causes `key` to be removed).\n            If `end` exceeds the actual end of the list, it will be treated like the last element of the list.\n            If `key` does not exist, \"OK\" will be returned without changes to the database.\n\n    Examples:\n        &gt;&gt;&gt; await client.ltrim(\"my_list\", 0, 1)\n            \"OK\"  # Indicates that the list has been trimmed to contain elements from 0 to 1.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.LTrim, [key, str(start), str(end)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.mget","title":"<code>mget(keys)</code>  <code>async</code>","text":"<p>Retrieve the values of multiple keys. See https://valkey.io/commands/mget/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys to retrieve values for.</p> required <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,</p> <code>List[Optional[bytes]]</code> <p>its corresponding value in the list will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n&gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n&gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n    [b'value1' , b'value2']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def mget(self, keys: List[TEncodable]) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Retrieve the values of multiple keys.\n    See https://valkey.io/commands/mget/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): A list of keys to retrieve values for.\n\n    Returns:\n        List[Optional[bytes]]: A list of values corresponding to the provided keys. If a key is not found,\n        its corresponding value in the list will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key1\", \"value1\")\n        &gt;&gt;&gt; await client.set(\"key2\", \"value2\")\n        &gt;&gt;&gt; await client.mget([\"key1\", \"key2\"])\n            [b'value1' , b'value2']\n    \"\"\"\n    return cast(\n        List[Optional[bytes]], await self._execute_command(RequestType.MGet, keys)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.mset","title":"<code>mset(key_value_map)</code>  <code>async</code>","text":"<p>Set multiple keys to multiple values in a single atomic operation. See https://valkey.io/commands/mset/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when keys in <code>key_value_map</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>key_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A map of key value pairs.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>a simple OK response.</p> Example <p>await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})     'OK'</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def mset(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n    \"\"\"\n    Set multiple keys to multiple values in a single atomic operation.\n    See https://valkey.io/commands/mset/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when keys in `key_value_map` map to different hash slots.\n\n    Args:\n        key_value_map (Mapping[TEncodable, TEncodable]): A map of key value pairs.\n\n    Returns:\n        OK: a simple OK response.\n\n    Example:\n        &gt;&gt;&gt; await client.mset({\"key\" : \"value\", \"key2\": \"value2\"})\n            'OK'\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in key_value_map.items():\n        parameters.extend(pair)\n    return cast(TOK, await self._execute_command(RequestType.MSet, parameters))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.msetnx","title":"<code>msetnx(key_value_map)</code>  <code>async</code>","text":"<p>Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or more keys already exist, the entire operation fails.</p> Note <p>When in cluster mode, all keys in <code>key_value_map</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/msetnx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key_value_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A key-value map consisting of keys and their respective values to set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all keys were set. False if no key was set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n    True\n&gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n    False\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def msetnx(self, key_value_map: Mapping[TEncodable, TEncodable]) -&gt; bool:\n    \"\"\"\n    Sets multiple keys to values if the key does not exist. The operation is atomic, and if one or\n    more keys already exist, the entire operation fails.\n\n    Note:\n        When in cluster mode, all keys in `key_value_map` must map to the same hash slot.\n\n    See https://valkey.io/commands/msetnx/ for more details.\n\n    Args:\n        key_value_map (Mapping[TEncodable, TEncodable]): A key-value map consisting of keys and their respective values to set.\n\n    Returns:\n        bool: True if all keys were set. False if no key was set.\n\n    Examples:\n        &gt;&gt;&gt; await client.msetnx({\"key1\": \"value1\", \"key2\": \"value2\"})\n            True\n        &gt;&gt;&gt; await client.msetnx({\"key2\": \"value4\", \"key3\": \"value5\"})\n            False\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in key_value_map.items():\n        parameters.extend(pair)\n    return cast(\n        bool,\n        await self._execute_command(RequestType.MSetNX, parameters),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.object_encoding","title":"<code>object_encoding(key)</code>  <code>async</code>","text":"<p>Returns the internal encoding for the Valkey object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-encoding for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> of the object to get the internal encoding of.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If <code>key</code> exists, returns the internal encoding of the object stored at <code>key</code> as a bytes string. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n    b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_encoding(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns the internal encoding for the Valkey object stored at `key`.\n\n    See https://valkey.io/commands/object-encoding for more details.\n\n    Args:\n        key (TEncodable): The `key` of the object to get the internal encoding of.\n\n    Returns:\n        Optional[bytes]: If `key` exists, returns the internal encoding of the object stored at\n            `key` as a bytes string. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_encoding(\"my_hash\")\n            b\"listpack\"  # The hash stored at \"my_hash\" has an internal encoding of \"listpack\".\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.ObjectEncoding, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.object_freq","title":"<code>object_freq(key)</code>  <code>async</code>","text":"<p>Returns the logarithmic access frequency counter of a Valkey object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-freq for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the logarithmic access frequency counter of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the logarithmic access frequency counter of the object stored at <code>key</code> as an integer. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_freq(\"my_hash\")\n    2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_freq(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the logarithmic access frequency counter of a Valkey object stored at `key`.\n\n    See https://valkey.io/commands/object-freq for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the logarithmic access frequency counter of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the logarithmic access frequency counter of the object stored at `key` as an\n            integer. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_freq(\"my_hash\")\n            2  # The logarithmic access frequency counter of \"my_hash\" has a value of 2.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectFreq, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.object_idletime","title":"<code>object_idletime(key)</code>  <code>async</code>","text":"<p>Returns the time in seconds since the last access to the value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-idletime for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the idle time of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the idle time in seconds. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n    13  # \"my_hash\" was last accessed 13 seconds ago.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_idletime(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the time in seconds since the last access to the value stored at `key`.\n\n    See https://valkey.io/commands/object-idletime for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the idle time of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the idle time in seconds. Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_idletime(\"my_hash\")\n            13  # \"my_hash\" was last accessed 13 seconds ago.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectIdleTime, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.object_refcount","title":"<code>object_refcount(key)</code>  <code>async</code>","text":"<p>Returns the reference count of the object stored at <code>key</code>.</p> <p>See https://valkey.io/commands/object-refcount for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the object to get the reference count of.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: If <code>key</code> exists, returns the reference count of the object stored at <code>key</code> as an integer. Otherwise, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n    2  # \"my_hash\" has a reference count of 2.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def object_refcount(self, key: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the reference count of the object stored at `key`.\n\n    See https://valkey.io/commands/object-refcount for more details.\n\n    Args:\n        key (TEncodable): The key of the object to get the reference count of.\n\n    Returns:\n        Optional[int]: If `key` exists, returns the reference count of the object stored at `key` as an integer.\n            Otherwise, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.object_refcount(\"my_hash\")\n            2  # \"my_hash\" has a reference count of 2.\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ObjectRefCount, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.persist","title":"<code>persist(key)</code>  <code>async</code>","text":"<p>Remove the existing timeout on <code>key</code>, turning the key from volatile (a key with an expire set) to persistent (a key that will never expire as no timeout is associated).</p> <p>See https://valkey.io/commands/persist/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to remove the existing timeout on.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if <code>key</code> does not exist or does not have an associated timeout, True if the timeout has been removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.persist(\"my_key\")\n    True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def persist(\n    self,\n    key: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Remove the existing timeout on `key`, turning the key from volatile (a key with an expire set) to\n    persistent (a key that will never expire as no timeout is associated).\n\n    See https://valkey.io/commands/persist/ for more details.\n\n    Args:\n        key (TEncodable): The key to remove the existing timeout on.\n\n    Returns:\n        bool: False if `key` does not exist or does not have an associated timeout, True if the timeout has been removed.\n\n    Examples:\n        &gt;&gt;&gt; await client.persist(\"my_key\")\n            True  # Indicates that the timeout associated with the key \"my_key\" was successfully removed.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.Persist, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pexpire","title":"<code>pexpire(key, milliseconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> in milliseconds. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. If <code>milliseconds</code> is a non-positive number, the key will be deleted rather than expired. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/pexpire/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>milliseconds</code> <code>int</code> <p>The timeout in milliseconds.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n    True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpire(\n    self,\n    key: TEncodable,\n    milliseconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` in milliseconds. After the timeout has expired, the key will automatically be deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    If `milliseconds` is a non-positive number, the key will be deleted rather than expired.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/pexpire/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        milliseconds (int): The timeout in milliseconds.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpire(\"my_key\", 60000, ExpireOptions.HasNoExpiry)\n            True  # Indicates that a timeout of 60,000 milliseconds has been set for \"my_key.\"\n    \"\"\"\n    args = (\n        [key, str(milliseconds)]\n        if option is None\n        else [key, str(milliseconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.PExpire, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pexpireat","title":"<code>pexpireat(key, unix_milliseconds, option=None)</code>  <code>async</code>","text":"<p>Sets a timeout on <code>key</code> using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead of specifying the number of milliseconds. A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be deleted. If <code>key</code> already has an existing expire set, the time to live is updated to the new value. The timeout will only be cleared by commands that delete or overwrite the contents of <code>key</code>. See https://valkey.io/commands/pexpireat/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to set a timeout on.</p> required <code>unix_milliseconds</code> <code>int</code> <p>The timeout in an absolute Unix timestamp in milliseconds.</p> required <code>option</code> <code>Optional[ExpireOptions]</code> <p>The expire option.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is skipped due to the provided arguments).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n    True\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpireat(\n    self,\n    key: TEncodable,\n    unix_milliseconds: int,\n    option: Optional[ExpireOptions] = None,\n) -&gt; bool:\n    \"\"\"\n    Sets a timeout on `key` using an absolute Unix timestamp in milliseconds (milliseconds since January 1, 1970) instead\n    of specifying the number of milliseconds.\n    A timestamp in the past will delete the key immediately. After the timeout has expired, the key will automatically be\n    deleted.\n    If `key` already has an existing expire set, the time to live is updated to the new value.\n    The timeout will only be cleared by commands that delete or overwrite the contents of `key`.\n    See https://valkey.io/commands/pexpireat/ for more details.\n\n    Args:\n        key (TEncodable): The key to set a timeout on.\n        unix_milliseconds (int): The timeout in an absolute Unix timestamp in milliseconds.\n        option (Optional[ExpireOptions]): The expire option.\n\n    Returns:\n        bool: 'True' if the timeout was set, 'False' if the timeout was not set (e.g., the key doesn't exist or the operation is\n            skipped due to the provided arguments).\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpireAt(\"my_key\", 1672531200000, ExpireOptions.HasNoExpiry)\n            True\n    \"\"\"\n    args = (\n        [key, str(unix_milliseconds)]\n        if option is None\n        else [key, str(unix_milliseconds), option.value]\n    )\n    return cast(bool, await self._execute_command(RequestType.PExpireAt, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pexpiretime","title":"<code>pexpiretime(key)</code>  <code>async</code>","text":"<p>Returns the absolute Unix timestamp (since January 1, 1970) at which the given <code>key</code> will expire, in milliseconds.</p> <p>See https://valkey.io/commands/pexpiretime/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to determine the expiration value of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The expiration Unix timestamp in milliseconds, -2 if <code>key</code> does not exist, or -1 if <code>key</code> exists but has no associated expiration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    -2 # 'my_key' doesn't exist.\n&gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    -1 # 'my_key' has no associate expiration.\n&gt;&gt;&gt; await client.expire(\"my_key\", 60)\n&gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n    1718615446670\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pexpiretime(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the absolute Unix timestamp (since January 1, 1970) at which\n    the given `key` will expire, in milliseconds.\n\n    See https://valkey.io/commands/pexpiretime/ for details.\n\n    Args:\n        key (TEncodable): The `key` to determine the expiration value of.\n\n    Returns:\n        int: The expiration Unix timestamp in milliseconds, -2 if `key` does not exist, or -1 if `key` exists but has no associated expiration.\n\n    Examples:\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            -2 # 'my_key' doesn't exist.\n        &gt;&gt;&gt; await client.set(\"my_key\", \"value\")\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            -1 # 'my_key' has no associate expiration.\n        &gt;&gt;&gt; await client.expire(\"my_key\", 60)\n        &gt;&gt;&gt; await client.pexpiretime(\"my_key\")\n            1718615446670\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.PExpireTime, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pfadd","title":"<code>pfadd(key, elements)</code>  <code>async</code>","text":"<p>Adds all elements to the HyperLogLog data structure stored at the specified <code>key</code>. Creates a new structure if the <code>key</code> does not exist. When no elements are provided, and <code>key</code> exists and is a HyperLogLog, then no operation is performed.</p> <p>See https://valkey.io/commands/pfadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the HyperLogLog data structure to add elements into.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>A list of members to add to the HyperLogLog stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is</p> <code>int</code> <p>altered, then returns 1. Otherwise, returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n    1 # A data structure was created or modified\n&gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n    1 # A new empty data structure was created\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfadd(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Adds all elements to the HyperLogLog data structure stored at the specified `key`.\n    Creates a new structure if the `key` does not exist.\n    When no elements are provided, and `key` exists and is a HyperLogLog, then no operation is performed.\n\n    See https://valkey.io/commands/pfadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the HyperLogLog data structure to add elements into.\n        elements (List[TEncodable]): A list of members to add to the HyperLogLog stored at `key`.\n\n    Returns:\n        int: If the HyperLogLog is newly created, or if the HyperLogLog approximated cardinality is\n        altered, then returns 1. Otherwise, returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfadd(\"hll_1\", [\"a\", \"b\", \"c\" ])\n            1 # A data structure was created or modified\n        &gt;&gt;&gt; await client.pfadd(\"hll_2\", [])\n            1 # A new empty data structure was created\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PfAdd, [key] + elements),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pfcount","title":"<code>pfcount(keys)</code>  <code>async</code>","text":"<p>Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.</p> <p>See https://valkey.io/commands/pfcount for more details.</p> Note <p>When in Cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the HyperLogLog data structures to be analyzed.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The approximated cardinality of given HyperLogLog data structures. The cardinality of a key that does not exist is 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n    4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfcount(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Estimates the cardinality of the data stored in a HyperLogLog structure for a single key or\n    calculates the combined cardinality of multiple keys by merging their HyperLogLogs temporarily.\n\n    See https://valkey.io/commands/pfcount for more details.\n\n    Note:\n        When in Cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the HyperLogLog data structures to be analyzed.\n\n    Returns:\n        int: The approximated cardinality of given HyperLogLog data structures.\n            The cardinality of a key that does not exist is 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfcount([\"hll_1\", \"hll_2\"])\n            4  # The approximated cardinality of the union of \"hll_1\" and \"hll_2\" is 4.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PfCount, keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pfmerge","title":"<code>pfmerge(destination, source_keys)</code>  <code>async</code>","text":"<p>Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.</p> <p>See https://valkey.io/commands/pfmerge for more details.</p> Note <p>When in Cluster mode, all keys in <code>source_keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination HyperLogLog where the merged data sets will be stored.</p> required <code>source_keys</code> <code>List[TEncodable]</code> <p>The keys of the HyperLogLog structures to be merged.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n&gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n&gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n    OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n&gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n    3  # The approximated cardinality of \"new_hll\" is 3.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pfmerge(\n    self, destination: TEncodable, source_keys: List[TEncodable]\n) -&gt; TOK:\n    \"\"\"\n    Merges multiple HyperLogLog values into a unique value. If the destination variable exists, it is treated as one\n    of the source HyperLogLog data sets, otherwise a new HyperLogLog is created.\n\n    See https://valkey.io/commands/pfmerge for more details.\n\n    Note:\n        When in Cluster mode, all keys in `source_keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination HyperLogLog where the merged data sets will be stored.\n        source_keys (List[TEncodable]): The keys of the HyperLogLog structures to be merged.\n\n    Returns:\n        OK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.pfadd(\"hll1\", [\"a\", \"b\"])\n        &gt;&gt;&gt; await client.pfadd(\"hll2\", [\"b\", \"c\"])\n        &gt;&gt;&gt; await client.pfmerge(\"new_hll\", [\"hll1\", \"hll2\"])\n            OK  # The value of \"hll1\" merged with \"hll2\" was stored in \"new_hll\".\n        &gt;&gt;&gt; await client.pfcount([\"new_hll\"])\n            3  # The approximated cardinality of \"new_hll\" is 3.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.PfMerge, [destination] + source_keys\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pttl","title":"<code>pttl(key)</code>  <code>async</code>","text":"<p>Returns the remaining time to live of <code>key</code> that has a timeout, in milliseconds. See https://valkey.io/commands/pttl for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its timeout.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TTL in milliseconds. -2 if <code>key</code> does not exist, -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pttl(\"my_key\")\n    5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n&gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n    -2  # Indicates that the key \"non_existing_key\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pttl(\n    self,\n    key: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Returns the remaining time to live of `key` that has a timeout, in milliseconds.\n    See https://valkey.io/commands/pttl for more details.\n\n    Args:\n        key (TEncodable): The key to return its timeout.\n\n    Returns:\n        int: TTL in milliseconds. -2 if `key` does not exist, -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.pttl(\"my_key\")\n            5000  # Indicates that the key \"my_key\" has a remaining time to live of 5000 milliseconds.\n        &gt;&gt;&gt; await client.pttl(\"non_existing_key\")\n            -2  # Indicates that the key \"non_existing_key\" does not exist.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.PTTL, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pubsub_channels","title":"<code>pubsub_channels(pattern=None)</code>  <code>async</code>","text":"<p>Lists the currently active channels. The command is routed to all nodes, and aggregates the response to a single array.</p> <p>See https://valkey.io/commands/pubsub-channels for more details.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>Optional[TEncodable]</code> <p>A glob-style pattern to match active channels.                 If not provided, all active channels are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of currently active channels matching the given pattern.     If no pattern is specified, all active channels are returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_channels()\n    [b\"channel1\", b\"channel2\"]\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n    [b\"news.sports\", \"news.weather\"]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_channels(\n    self, pattern: Optional[TEncodable] = None\n) -&gt; List[bytes]:\n    \"\"\"\n    Lists the currently active channels.\n    The command is routed to all nodes, and aggregates the response to a single array.\n\n    See https://valkey.io/commands/pubsub-channels for more details.\n\n    Args:\n        pattern (Optional[TEncodable]): A glob-style pattern to match active channels.\n                            If not provided, all active channels are returned.\n\n    Returns:\n        List[bytes]: A list of currently active channels matching the given pattern.\n                If no pattern is specified, all active channels are returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_channels()\n            [b\"channel1\", b\"channel2\"]\n\n        &gt;&gt;&gt; await client.pubsub_channels(\"news.*\")\n            [b\"news.sports\", \"news.weather\"]\n    \"\"\"\n\n    return cast(\n        List[bytes],\n        await self._execute_command(\n            RequestType.PubSubChannels, [pattern] if pattern else []\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pubsub_numpat","title":"<code>pubsub_numpat()</code>  <code>async</code>","text":"<p>Returns the number of unique patterns that are subscribed to by clients.</p> <p>Note: This is the total number of unique patterns all the clients are subscribed to, not the count of clients subscribed to patterns. The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.</p> <p>See https://valkey.io/commands/pubsub-numpat for more details.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of unique patterns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_numpat()\n    3\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_numpat(self) -&gt; int:\n    \"\"\"\n    Returns the number of unique patterns that are subscribed to by clients.\n\n    Note: This is the total number of unique patterns all the clients are subscribed to,\n    not the count of clients subscribed to patterns.\n    The command is routed to all nodes, and aggregates the response the sum of all pattern subscriptions.\n\n    See https://valkey.io/commands/pubsub-numpat for more details.\n\n    Returns:\n        int: The number of unique patterns.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_numpat()\n            3\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.PubSubNumPat, []))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.pubsub_numsub","title":"<code>pubsub_numsub(channels=None)</code>  <code>async</code>","text":"<p>Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.</p> <p>Note that it is valid to call this command without channels. In this case, it will just return an empty map. The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.</p> <p>See https://valkey.io/commands/pubsub-numsub for more details.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Optional[List[TEncodable]]</code> <p>The list of channels to query for the number of subscribers.                             If not provided, returns an empty map.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, int]</code> <p>Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n    {b'channel1': 3, b'channel2': 5}\n</code></pre> <pre><code>&gt;&gt;&gt; await client.pubsub_numsub()\n    {}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def pubsub_numsub(\n    self, channels: Optional[List[TEncodable]] = None\n) -&gt; Mapping[bytes, int]:\n    \"\"\"\n    Returns the number of subscribers (exclusive of clients subscribed to patterns) for the specified channels.\n\n    Note that it is valid to call this command without channels. In this case, it will just return an empty map.\n    The command is routed to all nodes, and aggregates the response to a single map of the channels and their number of subscriptions.\n\n    See https://valkey.io/commands/pubsub-numsub for more details.\n\n    Args:\n        channels (Optional[List[TEncodable]]): The list of channels to query for the number of subscribers.\n                                        If not provided, returns an empty map.\n\n    Returns:\n        Mapping[bytes, int]: A map where keys are the channel names and values are the number of subscribers.\n\n    Examples:\n        &gt;&gt;&gt; await client.pubsub_numsub([\"channel1\", \"channel2\"])\n            {b'channel1': 3, b'channel2': 5}\n\n        &gt;&gt;&gt; await client.pubsub_numsub()\n            {}\n    \"\"\"\n    return cast(\n        Mapping[bytes, int],\n        await self._execute_command(\n            RequestType.PubSubNumSub, channels if channels else []\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.rename","title":"<code>rename(key, new_key)</code>  <code>async</code>","text":"<p>Renames <code>key</code> to <code>new_key</code>. If <code>newkey</code> already exists it is overwritten. See https://valkey.io/commands/rename/ for more details.</p> Note <p>When in cluster mode, both <code>key</code> and <code>newkey</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable) </code> <p>The key to rename.</p> required <code>new_key</code> <code>TEncodable) </code> <p>The new name of the key.</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>If the <code>key</code> was successfully renamed, return \"OK\". If <code>key</code> does not exist, an error is thrown.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rename(self, key: TEncodable, new_key: TEncodable) -&gt; TOK:\n    \"\"\"\n    Renames `key` to `new_key`.\n    If `newkey` already exists it is overwritten.\n    See https://valkey.io/commands/rename/ for more details.\n\n    Note:\n        When in cluster mode, both `key` and `newkey` must map to the same hash slot.\n\n    Args:\n        key (TEncodable) : The key to rename.\n        new_key (TEncodable) : The new name of the key.\n\n    Returns:\n        OK: If the `key` was successfully renamed, return \"OK\". If `key` does not exist, an error is thrown.\n    \"\"\"\n    return cast(\n        TOK, await self._execute_command(RequestType.Rename, [key, new_key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.renamenx","title":"<code>renamenx(key, new_key)</code>  <code>async</code>","text":"<p>Renames <code>key</code> to <code>new_key</code> if <code>new_key</code> does not yet exist.</p> <p>See https://valkey.io/commands/renamenx for more details.</p> Note <p>When in cluster mode, both <code>key</code> and <code>new_key</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to rename.</p> required <code>new_key</code> <code>TEncodable</code> <p>The new key name.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>key</code> was renamed to <code>new_key</code>, or False if <code>new_key</code> already exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n    True  # \"old_key\" was renamed to \"new_key\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def renamenx(self, key: TEncodable, new_key: TEncodable) -&gt; bool:\n    \"\"\"\n    Renames `key` to `new_key` if `new_key` does not yet exist.\n\n    See https://valkey.io/commands/renamenx for more details.\n\n    Note:\n        When in cluster mode, both `key` and `new_key` must map to the same hash slot.\n\n    Args:\n        key (TEncodable): The key to rename.\n        new_key (TEncodable): The new key name.\n\n    Returns:\n        bool: True if `key` was renamed to `new_key`, or False if `new_key` already exists.\n\n    Examples:\n        &gt;&gt;&gt; await client.renamenx(\"old_key\", \"new_key\")\n            True  # \"old_key\" was renamed to \"new_key\"\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.RenameNX, [key, new_key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.restore","title":"<code>restore(key, ttl, value, replace=False, absttl=False, idletime=None, frequency=None)</code>  <code>async</code>","text":"<p>Create a <code>key</code> associated with a <code>value</code> that is obtained by deserializing the provided serialized <code>value</code> obtained via <code>dump</code>.</p> <p>See https://valkey.io/commands/restore for more details.</p> <p>Note: <code>IDLETIME</code> and <code>FREQ</code> modifiers cannot be set at the same time.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The <code>key</code> to create.</p> required <code>ttl</code> <code>int</code> <p>The expiry time (in milliseconds). If <code>0</code>, the <code>key</code> will persist.</p> required <code>replace</code> <code>bool</code> <p>Set to <code>True</code> to replace the key if it exists.</p> <code>False</code> <code>absttl</code> <code>bool</code> <p>Set to <code>True</code> to specify that <code>ttl</code> represents an absolute Unix timestamp (in milliseconds).</p> <code>False</code> <code>idletime</code> <code>Optional[int]</code> <p>Set the <code>IDLETIME</code> option with object idletime to the given key.</p> <code>None</code> <code>frequency</code> <code>Optional[int]</code> <p>Set the <code>FREQ</code> option with object frequency to the given key.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>If the <code>key</code> was successfully restored with a <code>value</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n    OK # Indicates restore `newKey` without any ttl expiry nor any option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n    OK # Indicates restore `newKey` with `REPLACE` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n    OK # Indicates restore `newKey` with `ABSTTL` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n    OK # Indicates restore `newKey` with `IDLETIME` option\n&gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n    OK # Indicates restore `newKey` with `FREQ` option\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def restore(\n    self,\n    key: TEncodable,\n    ttl: int,\n    value: TEncodable,\n    replace: bool = False,\n    absttl: bool = False,\n    idletime: Optional[int] = None,\n    frequency: Optional[int] = None,\n) -&gt; TOK:\n    \"\"\"\n    Create a `key` associated with a `value` that is obtained by deserializing the provided\n    serialized `value` obtained via `dump`.\n\n    See https://valkey.io/commands/restore for more details.\n\n    Note: `IDLETIME` and `FREQ` modifiers cannot be set at the same time.\n\n    Args:\n        key (TEncodable): The `key` to create.\n        ttl (int): The expiry time (in milliseconds). If `0`, the `key` will persist.\n        value (TEncodable) The serialized value to deserialize and assign to `key`.\n        replace (bool): Set to `True` to replace the key if it exists.\n        absttl (bool): Set to `True` to specify that `ttl` represents an absolute Unix\n            timestamp (in milliseconds).\n        idletime (Optional[int]): Set the `IDLETIME` option with object idletime to the given key.\n        frequency (Optional[int]): Set the `FREQ` option with object frequency to the given key.\n\n    Returns:\n        OK: If the `key` was successfully restored with a `value`.\n\n    Examples:\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value)\n            OK # Indicates restore `newKey` without any ttl expiry nor any option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, replace=True)\n            OK # Indicates restore `newKey` with `REPLACE` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, absttl=True)\n            OK # Indicates restore `newKey` with `ABSTTL` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, idletime=10)\n            OK # Indicates restore `newKey` with `IDLETIME` option\n        &gt;&gt;&gt; await client.restore(\"newKey\", 0, value, frequency=5)\n            OK # Indicates restore `newKey` with `FREQ` option\n    \"\"\"\n    args = [key, str(ttl), value]\n    if replace is True:\n        args.append(\"REPLACE\")\n    if absttl is True:\n        args.append(\"ABSTTL\")\n    if idletime is not None:\n        args.extend([\"IDLETIME\", str(idletime)])\n    if frequency is not None:\n        args.extend([\"FREQ\", str(frequency)])\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.Restore, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.rpop","title":"<code>rpop(key)</code>  <code>async</code>","text":"<p>Removes and returns the last elements of the list stored at <code>key</code>. The command pops a single element from the end of the list. See https://valkey.io/commands/rpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the last element.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpop(\"my_list\")\n    b\"value1\"\n&gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Removes and returns the last elements of the list stored at `key`.\n    The command pops a single element from the end of the list.\n    See https://valkey.io/commands/rpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n\n    Returns:\n        Optional[bytes]: The value of the last element.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpop(\"my_list\")\n            b\"value1\"\n        &gt;&gt;&gt; await client.rpop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.RPop, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.rpop_count","title":"<code>rpop_count(key, count)</code>  <code>async</code>","text":"<p>Removes and returns up to <code>count</code> elements from the list stored at <code>key</code>, depending on the list's length. See https://valkey.io/commands/rpop/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>The count of elements to pop from the list.</p> required <p>Returns:</p> Type Description <code>Optional[List[bytes]]</code> <p>Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.</p> <code>Optional[List[bytes]]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n    [b\"value1\", b\"value2\"]\n&gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpop_count(self, key: TEncodable, count: int) -&gt; Optional[List[bytes]]:\n    \"\"\"\n    Removes and returns up to `count` elements from the list stored at `key`, depending on the list's length.\n    See https://valkey.io/commands/rpop/ for details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        count (int): The count of elements to pop from the list.\n\n    Returns:\n        Optional[List[bytes]: A list of popped elements will be returned depending on the list's length.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpop_count(\"my_list\", 2)\n            [b\"value1\", b\"value2\"]\n        &gt;&gt;&gt; await client.rpop_count(\"non_exiting_key\" , 7)\n            None\n    \"\"\"\n    return cast(\n        Optional[List[bytes]],\n        await self._execute_command(RequestType.RPop, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.rpush","title":"<code>rpush(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the tail of the list stored at <code>key</code>. <code>elements</code> are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. If <code>key</code> does not exist, it is created as empty list before performing the push operations. See https://valkey.io/commands/rpush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the tail of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n    3 # Indicates that the new length of the list is 3 after the push operation.\n&gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n    1\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpush(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the tail of the list stored at `key`.\n    `elements` are inserted one after the other to the tail of the list, from the leftmost element\n    to the rightmost element. If `key` does not exist, it is created as empty list before performing the push operations.\n    See https://valkey.io/commands/rpush/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operations.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpush(\"my_list\", [\"value2\", \"value3\"])\n            3 # Indicates that the new length of the list is 3 after the push operation.\n        &gt;&gt;&gt; await client.rpush(\"nonexistent_list\", [\"new_value\"])\n            1\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.RPush, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.rpushx","title":"<code>rpushx(key, elements)</code>  <code>async</code>","text":"<p>Inserts all the specified values at the tail of the list stored at <code>key</code>, only if <code>key</code> exists and holds a list. If <code>key</code> is not a list, this performs no operation.</p> <p>See https://valkey.io/commands/rpushx/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list.</p> required <code>elements</code> <code>List[TEncodable]</code> <p>The elements to insert at the tail of the list stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the list after the push operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n    3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n&gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n    0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def rpushx(self, key: TEncodable, elements: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Inserts all the specified values at the tail of the list stored at `key`, only if `key` exists and holds a list.\n    If `key` is not a list, this performs no operation.\n\n    See https://valkey.io/commands/rpushx/ for more details.\n\n    Args:\n        key (TEncodable): The key of the list.\n        elements (List[TEncodable]): The elements to insert at the tail of the list stored at `key`.\n\n    Returns:\n        int: The length of the list after the push operation.\n\n    Examples:\n        &gt;&gt;&gt; await client.rpushx(\"my_list\", [\"value1\", \"value2\"])\n            3 # Indicates that 2 elements we're added to the list \"my_list\", and the new length of the list is 3.\n        &gt;&gt;&gt; await client.rpushx(\"nonexistent_list\", [\"new_value\"])\n            0 # Indicates that the list \"nonexistent_list\" does not exist, so \"new_value\" could not be pushed.\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.RPushX, [key] + elements)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sadd","title":"<code>sadd(key, members)</code>  <code>async</code>","text":"<p>Add specified members to the set stored at <code>key</code>. Specified members that are already a member of this set are ignored. If <code>key</code> does not exist, a new set is created before adding <code>members</code>. See https://valkey.io/commands/sadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key where members will be added to its set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to add to the set stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were added to the set, excluding members already present.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n    2\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sadd(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Add specified members to the set stored at `key`.\n    Specified members that are already a member of this set are ignored.\n    If `key` does not exist, a new set is created before adding `members`.\n    See https://valkey.io/commands/sadd/ for more details.\n\n    Args:\n        key (TEncodable): The key where members will be added to its set.\n        members (List[TEncodable]): A list of members to add to the set stored at `key`.\n\n    Returns:\n        int: The number of members that were added to the set, excluding members already present.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", [\"member1\", \"member2\"])\n            2\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SAdd, [key] + members))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.scard","title":"<code>scard(key)</code>  <code>async</code>","text":"<p>Retrieve the set cardinality (number of elements) of the set stored at <code>key</code>. See https://valkey.io/commands/scard/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the number of set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The cardinality (number of elements) of the set, or 0 if the key does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.scard(\"my_set\")\n    3\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def scard(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Retrieve the set cardinality (number of elements) of the set stored at `key`.\n    See https://valkey.io/commands/scard/ for details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the number of set members.\n\n    Returns:\n        int: The cardinality (number of elements) of the set, or 0 if the key does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.scard(\"my_set\")\n            3\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SCard, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.script_show","title":"<code>script_show(sha1)</code>  <code>async</code>","text":"<p>Returns the original source code of a script in the script cache.</p> <p>See https://valkey.io/commands/script-show for more details.</p> <p>Parameters:</p> Name Type Description Default <code>sha1</code> <code>TEncodable</code> <p>The SHA1 digest of the script.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The original source code of the script, if present in the cache. If the script is not found in the cache, an error is thrown.</p> Example <p>await client.script_show(script.get_hash())     b\"return { KEYS[1], ARGV[1] }\"</p> <p>Since: Valkey version 8.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def script_show(self, sha1: TEncodable) -&gt; bytes:\n    \"\"\"\n    Returns the original source code of a script in the script cache.\n\n    See https://valkey.io/commands/script-show for more details.\n\n    Args:\n        sha1 (TEncodable): The SHA1 digest of the script.\n\n    Returns:\n        bytes: The original source code of the script, if present in the cache.\n            If the script is not found in the cache, an error is thrown.\n\n    Example:\n        &gt;&gt;&gt; await client.script_show(script.get_hash())\n            b\"return { KEYS[1], ARGV[1] }\"\n\n    Since: Valkey version 8.0.0.\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.ScriptShow, [sha1]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sdiff","title":"<code>sdiff(keys)</code>  <code>async</code>","text":"<p>Computes the difference between the first set and all the successive sets in <code>keys</code>.</p> <p>See https://valkey.io/commands/sdiff for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets to diff</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of elements representing the difference between the sets. If any of the keys in <code>keys</code> do not exist, they are treated as empty sets.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n&gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n    {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sdiff(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Computes the difference between the first set and all the successive sets in `keys`.\n\n    See https://valkey.io/commands/sdiff for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets to diff\n\n    Returns:\n        Set[bytes]: A set of elements representing the difference between the sets.\n            If any of the keys in `keys` do not exist, they are treated as empty sets.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n        &gt;&gt;&gt; await client.sdiff(\"set1\", \"set2\")\n            {b\"member2\"}  # \"member2\" is in \"set1\" but not \"set2\"\n    \"\"\"\n    return cast(\n        Set[bytes],\n        await self._execute_command(RequestType.SDiff, keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sdiffstore","title":"<code>sdiffstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the difference between the first set and all the successive sets in <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sdiffstore for more details.</p> Note <p>When in Cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets to diff.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n&gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n    1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Stores the difference between the first set and all the successive sets in `keys` into a new set at\n    `destination`.\n\n    See https://valkey.io/commands/sdiffstore for more details.\n\n    Note:\n        When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys of the sets to diff.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member1\"])\n        &gt;&gt;&gt; await client.sdiffstore(\"set3\", [\"set1\", \"set2\"])\n            1  # Indicates that one member was stored in \"set3\", and that member is the diff between \"set1\" and \"set2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SDiffStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.set","title":"<code>set(key, value, conditional_set=None, expiry=None, return_old_value=False)</code>  <code>async</code>","text":"<p>Set the given key with the given value. Return value is dependent on the passed options. See https://valkey.io/commands/set/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>the key to store.</p> required <code>value</code> <code>TEncodable</code> <p>the value to store with the given key.</p> required <code>conditional_set</code> <code>Optional[ConditionalChange]</code> <p>set the key only if the given condition is met. Equivalent to [<code>XX</code> | <code>NX</code>] in the Valkey API. Defaults to None.</p> <code>None</code> <code>expiry</code> <code>Optional[ExpirySet]</code> <p>set expiriation to the given key. Equivalent to [<code>EX</code> | <code>PX</code> | <code>EXAT</code> | <code>PXAT</code> | <code>KEEPTTL</code>] in the Valkey API. Defaults to None.</p> <code>None</code> <code>return_old_value</code> <code>bool</code> <p>Return the old value stored at key, or None if key did not exist. An error is returned and SET aborted if the value stored at key is not a string. Equivalent to <code>GET</code> in the Valkey API. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: If the value is successfully set, return OK. If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None. If return_old_value is set, return the old value as a bytes string.</p> Example <p>await client.set(b\"key\", b\"value\")     'OK' await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))     'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds. await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)     b'new_value' # Returns the old value of \"key\". await client.get(\"key\")     b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def set(\n    self,\n    key: TEncodable,\n    value: TEncodable,\n    conditional_set: Optional[ConditionalChange] = None,\n    expiry: Optional[ExpirySet] = None,\n    return_old_value: bool = False,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Set the given key with the given value. Return value is dependent on the passed options.\n    See https://valkey.io/commands/set/ for more details.\n\n    Args:\n        key (TEncodable): the key to store.\n        value (TEncodable): the value to store with the given key.\n        conditional_set (Optional[ConditionalChange], optional): set the key only if the given condition is met.\n            Equivalent to [`XX` | `NX`] in the Valkey API. Defaults to None.\n        expiry (Optional[ExpirySet], optional): set expiriation to the given key.\n            Equivalent to [`EX` | `PX` | `EXAT` | `PXAT` | `KEEPTTL`] in the Valkey API. Defaults to None.\n        return_old_value (bool, optional): Return the old value stored at key, or None if key did not exist.\n            An error is returned and SET aborted if the value stored at key is not a string.\n            Equivalent to `GET` in the Valkey API. Defaults to False.\n\n    Returns:\n        Optional[bytes]:\n            If the value is successfully set, return OK.\n            If value isn't set because of only_if_exists or only_if_does_not_exist conditions, return None.\n            If return_old_value is set, return the old value as a bytes string.\n\n    Example:\n        &gt;&gt;&gt; await client.set(b\"key\", b\"value\")\n            'OK'\n        &gt;&gt;&gt; await client.set(\"key\", \"new_value\",conditional_set=ConditionalChange.ONLY_IF_EXISTS, expiry=Expiry(ExpiryType.SEC, 5))\n            'OK' # Set \"new_value\" to \"key\" only if \"key\" already exists, and set the key expiration to 5 seconds.\n        &gt;&gt;&gt; await client.set(\"key\", \"value\", conditional_set=ConditionalChange.ONLY_IF_DOES_NOT_EXIST,return_old_value=True)\n            b'new_value' # Returns the old value of \"key\".\n        &gt;&gt;&gt; await client.get(\"key\")\n            b'new_value' # Value wasn't modified back to being \"value\" because of \"NX\" flag.\n    \"\"\"\n    args = [key, value]\n    if conditional_set:\n        args.append(conditional_set.value)\n    if return_old_value:\n        args.append(\"GET\")\n    if expiry is not None:\n        args.extend(expiry.get_cmd_args())\n    return cast(Optional[bytes], await self._execute_command(RequestType.Set, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.setbit","title":"<code>setbit(key, offset, value)</code>  <code>async</code>","text":"<p>Sets or clears the bit at <code>offset</code> in the string value stored at <code>key</code>. The <code>offset</code> is a zero-based index, with <code>0</code> being the first element of the list, <code>1</code> being the next element, and so on. The <code>offset</code> must be less than <code>2^32</code> and greater than or equal to <code>0</code>. If a key is non-existent then the bit at <code>offset</code> is set to <code>value</code> and the preceding bits are set to <code>0</code>.</p> <p>See https://valkey.io/commands/setbit for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string.</p> required <code>offset</code> <code>int</code> <p>The index of the bit to be set.</p> required <code>value</code> <code>int</code> <p>The bit value to set at <code>offset</code>. The value must be <code>0</code> or <code>1</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The bit value that was previously stored at <code>offset</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n    0  # The second bit value was 0 before setting to 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def setbit(self, key: TEncodable, offset: int, value: int) -&gt; int:\n    \"\"\"\n    Sets or clears the bit at `offset` in the string value stored at `key`. The `offset` is a zero-based index,\n    with `0` being the first element of the list, `1` being the next element, and so on. The `offset` must be less\n    than `2^32` and greater than or equal to `0`. If a key is non-existent then the bit at `offset` is set to\n    `value` and the preceding bits are set to `0`.\n\n    See https://valkey.io/commands/setbit for more details.\n\n    Args:\n        key (TEncodable): The key of the string.\n        offset (int): The index of the bit to be set.\n        value (int): The bit value to set at `offset`. The value must be `0` or `1`.\n\n    Returns:\n        int: The bit value that was previously stored at `offset`.\n\n    Examples:\n        &gt;&gt;&gt; await client.setbit(\"string_key\", 1, 1)\n            0  # The second bit value was 0 before setting to 1.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.SetBit, [key, str(offset), str(value)]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.setrange","title":"<code>setrange(key, offset, value)</code>  <code>async</code>","text":"<p>Overwrites part of the string stored at <code>key</code>, starting at the specified <code>offset</code>, for the entire length of <code>value</code>. If the <code>offset</code> is larger than the current length of the string at <code>key</code>, the string is padded with zero bytes to make <code>offset</code> fit. Creates the <code>key</code> if it doesn't exist.</p> <p>See https://valkey.io/commands/setrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the string to update.</p> required <code>offset</code> <code>int</code> <p>The position in the string where <code>value</code> should be written.</p> required <code>value</code> <code>TEncodable</code> <p>The value written with <code>offset</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the string stored at <code>key</code> after it was modified.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n&gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n    11  # The length of the string stored at `key` after it was modified.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def setrange(self, key: TEncodable, offset: int, value: TEncodable) -&gt; int:\n    \"\"\"\n    Overwrites part of the string stored at `key`, starting at the specified\n    `offset`, for the entire length of `value`.\n    If the `offset` is larger than the current length of the string at `key`,\n    the string is padded with zero bytes to make `offset` fit. Creates the `key`\n    if it doesn't exist.\n\n    See https://valkey.io/commands/setrange for more details.\n\n    Args:\n        key (TEncodable): The key of the string to update.\n        offset (int): The position in the string where `value` should be written.\n        value (TEncodable): The value written with `offset`.\n\n    Returns:\n        int: The length of the string stored at `key` after it was modified.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"Hello World\")\n        &gt;&gt;&gt; await client.setrange(\"key\", 6, \"Glide\")\n            11  # The length of the string stored at `key` after it was modified.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.SetRange, [key, str(offset), value]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sinter","title":"<code>sinter(keys)</code>  <code>async</code>","text":"<p>Gets the intersection of all the given sets.</p> <p>See https://valkey.io/commands/sinter for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of members which are present in all given sets. If one or more sets do no exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n     {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n&gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sinter(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Gets the intersection of all the given sets.\n\n    See https://valkey.io/commands/sinter for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets.\n\n    Returns:\n        Set[bytes]: A set of members which are present in all given sets.\n            If one or more sets do no exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sinter([\"my_set1\", \"my_set2\"])\n             {b\"member2\"} # sets \"my_set1\" and \"my_set2\" have one commom member\n        &gt;&gt;&gt; await client.sinter([my_set1\", \"non_existing_set\"])\n            None\n    \"\"\"\n    return cast(Set[bytes], await self._execute_command(RequestType.SInter, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sintercard","title":"<code>sintercard(keys, limit=None)</code>  <code>async</code>","text":"<p>Gets the cardinality of the intersection of all the given sets. Optionally, a <code>limit</code> can be specified to stop the computation early if the intersection cardinality reaches the specified limit.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/sintercard for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>A list of keys representing the sets to intersect.</p> required <code>limit</code> <code>Optional[int]</code> <p>An optional limit to the maximum number of intersecting elements to count. If specified, the computation stops as soon as the cardinality reaches this limit.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set of the intersection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n&gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n&gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n</code></pre> <pre><code>&gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sintercard(\n    self, keys: List[TEncodable], limit: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Gets the cardinality of the intersection of all the given sets.\n    Optionally, a `limit` can be specified to stop the computation early if the intersection cardinality reaches the specified limit.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/sintercard for more details.\n\n    Args:\n        keys (List[TEncodable]): A list of keys representing the sets to intersect.\n        limit (Optional[int]): An optional limit to the maximum number of intersecting elements to count.\n            If specified, the computation stops as soon as the cardinality reaches this limit.\n\n    Returns:\n        int: The number of elements in the resulting set of the intersection.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", {\"a\", \"b\", \"c\"})\n        &gt;&gt;&gt; await client.sadd(\"set2\", {\"b\", \"c\", \"d\"})\n        &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"])\n        2  # The intersection of \"set1\" and \"set2\" contains 2 elements: \"b\" and \"c\".\n\n        &gt;&gt;&gt; await client.sintercard([\"set1\", \"set2\"], limit=1)\n        1  # The computation stops early as the intersection cardinality reaches the limit of 1.\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    if limit is not None:\n        args += [\"LIMIT\", str(limit)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.SInterCard, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sinterstore","title":"<code>sinterstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the members of the intersection of all given sets specified by <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sinterstore for more details.</p> Note <p>When in Cluster mode, all <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys from which to retrieve the set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n    1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sinterstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Stores the members of the intersection of all given sets specified by `keys` into a new set at `destination`.\n\n    See https://valkey.io/commands/sinterstore for more details.\n\n    Note:\n        When in Cluster mode, all `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sinterstore(\"my_set3\", [\"my_set1\", \"my_set2\"])\n            1  # One element was stored at \"my_set3\", and that element is the intersection of \"my_set1\" and \"myset2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SInterStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sismember","title":"<code>sismember(key, member)</code>  <code>async</code>","text":"<p>Returns if <code>member</code> is a member of the set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/sismember/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>member</code> <code>TEncodable</code> <p>The member to check for existence in the set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the member exists in the set, False otherwise.</p> <code>bool</code> <p>If <code>key</code> doesn't exist, it is treated as an empty set and the command returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n    True  # Indicates that \"member1\" exists in the set \"my_set\".\n&gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n    False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sismember(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Returns if `member` is a member of the set stored at `key`.\n\n    See https://valkey.io/commands/sismember/ for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        member (TEncodable): The member to check for existence in the set.\n\n    Returns:\n        bool: True if the member exists in the set, False otherwise.\n        If `key` doesn't exist, it is treated as an empty set and the command returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.sismember(\"my_set\", \"member1\")\n            True  # Indicates that \"member1\" exists in the set \"my_set\".\n        &gt;&gt;&gt; await client.sismember(\"my_set\", \"non_existing_member\")\n            False  # Indicates that \"non_existing_member\" does not exist in the set \"my_set\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.SIsMember, [key, member]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.smembers","title":"<code>smembers(key)</code>  <code>async</code>","text":"<p>Retrieve all the members of the set value stored at <code>key</code>. See https://valkey.io/commands/smembers/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the set members.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of all members of the set. If <code>key</code> does not exist an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.smembers(\"my_set\")\n    {b\"member1\", b\"member2\", b\"member3\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smembers(self, key: TEncodable) -&gt; Set[bytes]:\n    \"\"\"\n    Retrieve all the members of the set value stored at `key`.\n    See https://valkey.io/commands/smembers/ for details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the set members.\n\n    Returns:\n        Set[bytes]: A set of all members of the set.\n            If `key` does not exist an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.smembers(\"my_set\")\n            {b\"member1\", b\"member2\", b\"member3\"}\n    \"\"\"\n    return cast(\n        Set[bytes], await self._execute_command(RequestType.SMembers, [key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.smismember","title":"<code>smismember(key, members)</code>  <code>async</code>","text":"<p>Checks whether each member is contained in the members of the set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/smismember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set to check.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to check for existence in the set.</p> required <p>Returns:</p> Type Description <code>List[bool]</code> <p>List[bool]: A list of bool values, each indicating if the respective member exists in the set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n&gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n    [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smismember(\n    self, key: TEncodable, members: List[TEncodable]\n) -&gt; List[bool]:\n    \"\"\"\n    Checks whether each member is contained in the members of the set stored at `key`.\n\n    See https://valkey.io/commands/smismember for more details.\n\n    Args:\n        key (TEncodable): The key of the set to check.\n        members (List[TEncodable]): A list of members to check for existence in the set.\n\n    Returns:\n        List[bool]: A list of bool values, each indicating if the respective member exists in the set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"a\", \"b\", \"c\"])\n        &gt;&gt;&gt; await client.smismember(\"set1\", [\"b\", \"c\", \"d\"])\n            [True, True, False]  # \"b\" and \"c\" are members of \"set1\", but \"d\" is not.\n    \"\"\"\n    return cast(\n        List[bool],\n        await self._execute_command(RequestType.SMIsMember, [key] + members),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.smove","title":"<code>smove(source, destination, member)</code>  <code>async</code>","text":"<p>Moves <code>member</code> from the set at <code>source</code> to the set at <code>destination</code>, removing it from the source set. Creates a new destination set if needed. The operation is atomic.</p> <p>See https://valkey.io/commands/smove for more details.</p> Note <p>When in cluster mode, <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key of the set to remove the element from.</p> required <code>destination</code> <code>TEncodable</code> <p>The key of the set to add the element to.</p> required <code>member</code> <code>TEncodable</code> <p>The set element to move.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True on success, or False if the <code>source</code> set does not exist or the element is not a member of the source set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n    True  # \"member1\" was moved from \"set1\" to \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def smove(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    member: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Moves `member` from the set at `source` to the set at `destination`, removing it from the source set. Creates a\n    new destination set if needed. The operation is atomic.\n\n    See https://valkey.io/commands/smove for more details.\n\n    Note:\n        When in cluster mode, `source` and `destination` must map to the same hash slot.\n\n    Args:\n        source (TEncodable): The key of the set to remove the element from.\n        destination (TEncodable): The key of the set to add the element to.\n        member (TEncodable): The set element to move.\n\n    Returns:\n        bool: True on success, or False if the `source` set does not exist or the element is not a member of the source set.\n\n    Examples:\n        &gt;&gt;&gt; await client.smove(\"set1\", \"set2\", \"member1\")\n            True  # \"member1\" was moved from \"set1\" to \"set2\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(\n            RequestType.SMove, [source, destination, member]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sort","title":"<code>sort(key, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and returns the result. The <code>sort</code> command can be used to sort elements based on different criteria and apply transformations on sorted elements. This command is routed to primary nodes only. To store the result into a new key, see <code>sort_store</code>.</p> When in cluster mode, <code>key</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>See https://valkey.io/commands/sort for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_patterns</code> <code>Optional[List[TEncodable]]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: Returns a list of sorted elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n&gt;&gt;&gt; await client.sort(\"mylist\")\n    [b'1', b'2', b'3']\n&gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n    [b'3', b'2', b'1']\n&gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n&gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n    [b'2', b'2', b'3']\n&gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n&gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n&gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n&gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n    [b'Bob', b'Alice']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort(\n    self,\n    key: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n    The `sort` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n    This command is routed to primary nodes only.\n    To store the result into a new key, see `sort_store`.\n\n    Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        List[Optional[bytes]]: Returns a list of sorted elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", [b\"3\", b\"1\", b\"2\"])\n        &gt;&gt;&gt; await client.sort(\"mylist\")\n            [b'1', b'2', b'3']\n        &gt;&gt;&gt; await client.sort(\"mylist\", order=OrderBy.DESC)\n            [b'3', b'2', b'1']\n        &gt;&gt;&gt; await client.lpush(\"mylist2\", ['2', '1', '2', '3', '3', '1'])\n        &gt;&gt;&gt; await client.sort(\"mylist2\", limit=Limit(2, 3))\n            [b'2', b'2', b'3']\n        &gt;&gt;&gt; await client.hset(\"user:1\": {\"name\": \"Alice\", \"age\": '30'})\n        &gt;&gt;&gt; await client.hset(\"user:2\", {\"name\": \"Bob\", \"age\": '25'})\n        &gt;&gt;&gt; await client.lpush(\"user_ids\", ['2', '1'])\n        &gt;&gt;&gt; await client.sort(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n            [b'Bob', b'Alice']\n    \"\"\"\n    args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n    result = await self._execute_command(RequestType.Sort, args)\n    return cast(List[Optional[bytes]], result)\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sort_ro","title":"<code>sort_ro(key, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and returns the result. The <code>sort_ro</code> command can be used to sort elements based on different criteria and apply transformations on sorted elements. This command is routed depending on the client's <code>ReadFrom</code> strategy.</p> <p>See https://valkey.io/commands/sort for more details.</p> When in cluster mode, <code>key</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> required <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Optional[bytes]]</code> <p>List[Optional[bytes]]: Returns a list of sorted elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n&gt;&gt;&gt; await client.sort_ro(\"mylist\")\n    [b'1', b'2', b'3']\n&gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n    [b'3', b'2', b'1']\n&gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n&gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n    [b'2', b'2', b'3']\n&gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n&gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n&gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n&gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n    [b'Bob', b'Alice']\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort_ro(\n    self,\n    key: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; List[Optional[bytes]]:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and returns the result.\n    The `sort_ro` command can be used to sort elements based on different criteria and apply transformations on sorted elements.\n    This command is routed depending on the client's `ReadFrom` strategy.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Note: When in cluster mode, `key`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_pattern (Optional[TEncodable]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        List[Optional[bytes]]: Returns a list of sorted elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", 3, 1, 2)\n        &gt;&gt;&gt; await client.sort_ro(\"mylist\")\n            [b'1', b'2', b'3']\n        &gt;&gt;&gt; await client.sort_ro(\"mylist\", order=OrderBy.DESC)\n            [b'3', b'2', b'1']\n        &gt;&gt;&gt; await client.lpush(\"mylist2\", 2, 1, 2, 3, 3, 1)\n        &gt;&gt;&gt; await client.sort_ro(\"mylist2\", limit=Limit(2, 3))\n            [b'2', b'2', b'3']\n        &gt;&gt;&gt; await client.hset(\"user:1\", \"name\", \"Alice\", \"age\", 30)\n        &gt;&gt;&gt; await client.hset(\"user:2\", \"name\", \"Bob\", \"age\", 25)\n        &gt;&gt;&gt; await client.lpush(\"user_ids\", 2, 1)\n        &gt;&gt;&gt; await client.sort_ro(\"user_ids\", by_pattern=\"user:*-&gt;age\", get_patterns=[\"user:*-&gt;name\"])\n            [b'Bob', b'Alice']\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = _build_sort_args(key, by_pattern, limit, get_patterns, order, alpha)\n    result = await self._execute_command(RequestType.SortReadOnly, args)\n    return cast(List[Optional[bytes]], result)\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sort_store","title":"<code>sort_store(key, destination, by_pattern=None, limit=None, get_patterns=None, order=None, alpha=None)</code>  <code>async</code>","text":"<p>Sorts the elements in the list, set, or sorted set at <code>key</code> and stores the result in <code>store</code>. The <code>sort</code> command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key. To get the sort result without storing it into a key, see <code>sort</code>.</p> <p>See https://valkey.io/commands/sort for more details.</p> When in cluster mode, <code>key</code>, <code>destination</code>, and any patterns specified in <code>by_pattern</code> or <code>get_patterns</code> <p>must map to the same hash slot. The use of <code>by_pattern</code> and <code>get_patterns</code> in cluster mode is supported only since Valkey version 8.0.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the list, set, or sorted set to be sorted.</p> required <code>destination</code> <code>TEncodable</code> <p>The key where the sorted result will be stored.</p> required <code>by_pattern</code> <code>Optional[TEncodable]</code> <p>A pattern to sort by external keys instead of by the elements stored at the key themselves. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from the key replaces the asterisk to create the key name. For example, if <code>key</code> contains IDs of objects, <code>by_pattern</code> can be used to sort these IDs based on an attribute of the objects, like their weights or timestamps. E.g., if <code>by_pattern</code> is <code>weight_*</code>, the command will sort the elements by the values of the keys <code>weight_&lt;element&gt;</code>. If not provided, elements are sorted by their value. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>limit</code> <code>Optional[Limit]</code> <p>Limiting the range of the query by setting offset and result count. See <code>Limit</code> class for more information.</p> <code>None</code> <code>get_patterns</code> <code>Optional[List[TEncodable]]</code> <p>A pattern used to retrieve external keys' values, instead of the elements at <code>key</code>. The pattern should contain an asterisk (*) as a placeholder for the element values, where the value from <code>key</code> replaces the asterisk to create the key name. This allows the sorted elements to be transformed based on the related keys values. For example, if <code>key</code> contains IDs of users, <code>get_pattern</code> can be used to retrieve specific attributes of these users, such as their names or email addresses. E.g., if <code>get_pattern</code> is <code>name_*</code>, the command will return the values of the keys <code>name_&lt;element&gt;</code> for each sorted element. Multiple <code>get_pattern</code> arguments can be provided to retrieve multiple attributes. The special value <code>#</code> can be used to include the actual element from <code>key</code> being sorted. If not provided, only the sorted elements themselves are returned. Supported in cluster mode since Valkey version 8.0.</p> <code>None</code> <code>order</code> <code>Optional[OrderBy]</code> <p>Specifies the order to sort the elements. Can be <code>OrderBy.ASC</code> (ascending) or <code>OrderBy.DESC</code> (descending).</p> <code>None</code> <code>alpha</code> <code>Optional[bool]</code> <p>When <code>True</code>, sorts elements lexicographically. When <code>False</code> (default), sorts elements numerically. Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted key stored at <code>store</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n&gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n    3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n&gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n    [b'1', b'2', b'3']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sort_store(\n    self,\n    key: TEncodable,\n    destination: TEncodable,\n    by_pattern: Optional[TEncodable] = None,\n    limit: Optional[Limit] = None,\n    get_patterns: Optional[List[TEncodable]] = None,\n    order: Optional[OrderBy] = None,\n    alpha: Optional[bool] = None,\n) -&gt; int:\n    \"\"\"\n    Sorts the elements in the list, set, or sorted set at `key` and stores the result in `store`.\n    The `sort` command can be used to sort elements based on different criteria, apply transformations on sorted elements, and store the result in a new key.\n    To get the sort result without storing it into a key, see `sort`.\n\n    See https://valkey.io/commands/sort for more details.\n\n    Note: When in cluster mode, `key`, `destination`, and any patterns specified in `by_pattern` or `get_patterns`\n        must map to the same hash slot. The use of `by_pattern` and `get_patterns` in cluster mode is supported\n        only since Valkey version 8.0.\n\n    Args:\n        key (TEncodable): The key of the list, set, or sorted set to be sorted.\n        destination (TEncodable): The key where the sorted result will be stored.\n        by_pattern (Optional[TEncodable]): A pattern to sort by external keys instead of by the elements stored at the key themselves.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from the key replaces the asterisk to create the key name. For example, if `key` contains IDs of objects,\n            `by_pattern` can be used to sort these IDs based on an attribute of the objects, like their weights or\n            timestamps.\n            E.g., if `by_pattern` is `weight_*`, the command will sort the elements by the values of the\n            keys `weight_&lt;element&gt;`.\n            If not provided, elements are sorted by their value.\n            Supported in cluster mode since Valkey version 8.0.\n        limit (Optional[Limit]): Limiting the range of the query by setting offset and result count. See `Limit` class for more information.\n        get_patterns (Optional[List[TEncodable]]): A pattern used to retrieve external keys' values, instead of the elements at `key`.\n            The pattern should contain an asterisk (*) as a placeholder for the element values, where the value\n            from `key` replaces the asterisk to create the key name. This allows the sorted elements to be\n            transformed based on the related keys values. For example, if `key` contains IDs of users, `get_pattern`\n            can be used to retrieve specific attributes of these users, such as their names or email addresses.\n            E.g., if `get_pattern` is `name_*`, the command will return the values of the keys `name_&lt;element&gt;`\n            for each sorted element. Multiple `get_pattern` arguments can be provided to retrieve multiple attributes.\n            The special value `#` can be used to include the actual element from `key` being sorted.\n            If not provided, only the sorted elements themselves are returned.\n            Supported in cluster mode since Valkey version 8.0.\n        order (Optional[OrderBy]): Specifies the order to sort the elements.\n            Can be `OrderBy.ASC` (ascending) or `OrderBy.DESC` (descending).\n        alpha (Optional[bool]): When `True`, sorts elements lexicographically. When `False` (default), sorts elements numerically.\n            Use this when the list, set, or sorted set contains string values that cannot be converted into double precision floating point\n\n    Returns:\n        int: The number of elements in the sorted key stored at `store`.\n\n    Examples:\n        &gt;&gt;&gt; await client.lpush(\"mylist\", ['3', '1', '2'])\n        &gt;&gt;&gt; await client.sort_store(\"mylist\", \"{mylist}sorted_list\")\n            3  # Indicates that the sorted list \"{mylist}sorted_list\" contains three elements.\n        &gt;&gt;&gt; await client.lrange(\"{mylist}sorted_list\", 0, -1)\n            [b'1', b'2', b'3']\n    \"\"\"\n    args = _build_sort_args(\n        key, by_pattern, limit, get_patterns, order, alpha, store=destination\n    )\n    result = await self._execute_command(RequestType.Sort, args)\n    return cast(int, result)\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.spop","title":"<code>spop(key)</code>  <code>async</code>","text":"<p>Removes and returns one random member from the set stored at <code>key</code>.</p> <p>See https://valkey-io.github.io/commands/spop/ for more details. To pop multiple members, see <code>spop_count</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: The value of the popped member.</p> <code>Optional[bytes]</code> <p>If <code>key</code> does not exist, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.spop(\"my_set\")\n    b\"value1\" # Removes and returns a random member from the set \"my_set\".\n&gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def spop(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Removes and returns one random member from the set stored at `key`.\n\n    See https://valkey-io.github.io/commands/spop/ for more details.\n    To pop multiple members, see `spop_count`.\n\n    Args:\n        key (TEncodable): The key of the set.\n\n    Returns:\n        Optional[bytes]: The value of the popped member.\n        If `key` does not exist, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.spop(\"my_set\")\n            b\"value1\" # Removes and returns a random member from the set \"my_set\".\n        &gt;&gt;&gt; await client.spop(\"non_exiting_key\")\n            None\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.SPop, [key])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.spop_count","title":"<code>spop_count(key, count)</code>  <code>async</code>","text":"<p>Removes and returns up to <code>count</code> random members from the set stored at <code>key</code>, depending on the set's length.</p> <p>See https://valkey-io.github.io/commands/spop/ for more details. To pop a single member, see <code>spop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>The count of the elements to pop from the set.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of popped elements will be returned depending on the set's length. If <code>key</code> does not exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n    {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n&gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n    Set()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def spop_count(self, key: TEncodable, count: int) -&gt; Set[bytes]:\n    \"\"\"\n    Removes and returns up to `count` random members from the set stored at `key`, depending on the set's length.\n\n    See https://valkey-io.github.io/commands/spop/ for more details.\n    To pop a single member, see `spop`.\n\n    Args:\n        key (TEncodable): The key of the set.\n        count (int): The count of the elements to pop from the set.\n\n    Returns:\n        Set[bytes]: A set of popped elements will be returned depending on the set's length.\n            If `key` does not exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.spop_count(\"my_set\", 2)\n            {b\"value1\", b\"value2\"} # Removes and returns 2 random members from the set \"my_set\".\n        &gt;&gt;&gt; await client.spop_count(\"non_exiting_key\", 2)\n            Set()\n    \"\"\"\n    return cast(\n        Set[bytes], await self._execute_command(RequestType.SPop, [key, str(count)])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.srandmember","title":"<code>srandmember(key)</code>  <code>async</code>","text":"<p>Returns a random element from the set value stored at 'key'.</p> <p>See https://valkey.io/commands/srandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which to retrieve the set member.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random element from the set, or None if 'key' does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.srandmember(b\"my_set\")\n    b\"member1\"  # \"member1\" is a random member of \"my_set\".\n&gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n    None  # \"non_existing_set\" is not an existing key, so None was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random element from the set value stored at 'key'.\n\n    See https://valkey.io/commands/srandmember for more details.\n\n    Args:\n        key (TEncodable): The key from which to retrieve the set member.\n\n    Returns:\n        Optional[bytes]: A random element from the set, or None if 'key' does not exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.srandmember(b\"my_set\")\n            b\"member1\"  # \"member1\" is a random member of \"my_set\".\n        &gt;&gt;&gt; await client.srandmember(\"non_existing_set\")\n            None  # \"non_existing_set\" is not an existing key, so None was returned.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.SRandMember, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.srandmember_count","title":"<code>srandmember_count(key, count)</code>  <code>async</code>","text":"<p>Returns one or more random elements from the set value stored at 'key'.</p> <p>See https://valkey.io/commands/srandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of members from the set. If the set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n    [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n&gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n    []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Returns one or more random elements from the set value stored at 'key'.\n\n    See https://valkey.io/commands/srandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[bytes]: A list of members from the set.\n            If the set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.srandmember(\"my_set\", -3)\n            [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_set\".\n        &gt;&gt;&gt; await client.srandmember(\"non_existing_set\", 3)\n            []  # \"non_existing_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.SRandMember, [key, str(count)]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.srem","title":"<code>srem(key, members)</code>  <code>async</code>","text":"<p>Remove specified members from the set stored at <code>key</code>. Specified members that are not a member of this set are ignored. See https://valkey.io/commands/srem/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key from which members will be removed.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to remove from the set stored at <code>key</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the set, excluding non-existing members. If <code>key</code> does not exist, it is treated as an empty set and this command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n    2\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def srem(self, key: TEncodable, members: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Remove specified members from the set stored at `key`.\n    Specified members that are not a member of this set are ignored.\n    See https://valkey.io/commands/srem/ for details.\n\n    Args:\n        key (TEncodable): The key from which members will be removed.\n        members (List[TEncodable]): A list of members to remove from the set stored at `key`.\n\n    Returns:\n        int: The number of members that were removed from the set, excluding non-existing members.\n            If `key` does not exist, it is treated as an empty set and this command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.srem(\"my_set\", [\"member1\", \"member2\"])\n            2\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.SRem, [key] + members))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sscan","title":"<code>sscan(key, cursor, match=None, count=None)</code>  <code>async</code>","text":"<p>Iterates incrementally over a set.</p> <p>See https://valkey.io/commands/sscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a subset of the set then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the set. <code>COUNT</code> could be ignored until the set is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the set held by <code>key</code>. The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code> returned on the last iteration of the set. The second element is always an <code>Array</code> of the subset of the set held in <code>key</code>.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sscan--assume-key-contains-a-set-with-130-members","title":"Assume \"key\" contains a set with 130 members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor:  48\nMembers: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\nCursor: 24\nMembers: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\nCursor: 0\nMembers: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a set.\n\n    See https://valkey.io/commands/sscan for more details.\n\n    Args:\n        key (TEncodable): The key of the set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the set is large enough for scan commands to return only a\n            subset of the set then there could be a case where the result is empty although there are items that\n            match the pattern specified. This is due to the default `COUNT` being `10` which indicates that it will\n            only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the set.\n            `COUNT` could be ignored until the set is large enough for the `SCAN` commands to represent the results\n            as compact single-allocation packed encoding.\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the set held by `key`.\n            The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n            returned on the last iteration of the set. The second element is always an `Array` of the subset of the\n            set held in `key`.\n\n    Examples:\n        # Assume \"key\" contains a set with 130 members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.sscan(\"key\", \"0\", match=\"*\")\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor:  48\n        Members: [b'3', b'118', b'120', b'86', b'76', b'13', b'61', b'111', b'55', b'45']\n        Cursor: 24\n        Members: [b'38', b'109', b'11', b'119', b'34', b'24', b'40', b'57', b'20', b'17']\n        Cursor: 0\n        Members: [b'47', b'122', b'1', b'53', b'10', b'14', b'80']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.SScan, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.strlen","title":"<code>strlen(key)</code>  <code>async</code>","text":"<p>Get the length of the string value stored at <code>key</code>. See https://valkey.io/commands/strlen/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its length.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the string value stored at <code>key</code>. If <code>key</code> does not exist, it is treated as an empty string and 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n&gt;&gt;&gt; await client.strlen(\"key\")\n    5  # Indicates that the length of the string value stored at `key` is 5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def strlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Get the length of the string value stored at `key`.\n    See https://valkey.io/commands/strlen/ for more details.\n\n    Args:\n        key (TEncodable): The key to return its length.\n\n    Returns:\n        int: The length of the string value stored at `key`.\n            If `key` does not exist, it is treated as an empty string and 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"GLIDE\")\n        &gt;&gt;&gt; await client.strlen(\"key\")\n            5  # Indicates that the length of the string value stored at `key` is 5.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(int, await self._execute_command(RequestType.Strlen, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sunion","title":"<code>sunion(keys)</code>  <code>async</code>","text":"<p>Gets the union of all the given sets.</p> <p>See https://valkey.io/commands/sunion for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sets.</p> required <p>Returns:</p> Type Description <code>Set[bytes]</code> <p>Set[bytes]: A set of members which are present in at least one of the given sets. If none of the sets exist, an empty set will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n&gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n&gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n    {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n&gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n    {b\"member1\", b\"member2\"}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sunion(self, keys: List[TEncodable]) -&gt; Set[bytes]:\n    \"\"\"\n    Gets the union of all the given sets.\n\n    See https://valkey.io/commands/sunion for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sets.\n\n    Returns:\n        Set[bytes]: A set of members which are present in at least one of the given sets.\n            If none of the sets exist, an empty set will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"my_set1\", [\"member1\", \"member2\"])\n        &gt;&gt;&gt; await client.sadd(\"my_set2\", [\"member2\", \"member3\"])\n        &gt;&gt;&gt; await client.sunion([\"my_set1\", \"my_set2\"])\n            {b\"member1\", b\"member2\", b\"member3\"} # sets \"my_set1\" and \"my_set2\" have three unique members\n        &gt;&gt;&gt; await client.sunion([\"my_set1\", \"non_existing_set\"])\n            {b\"member1\", b\"member2\"}\n    \"\"\"\n    return cast(Set[bytes], await self._execute_command(RequestType.SUnion, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.sunionstore","title":"<code>sunionstore(destination, keys)</code>  <code>async</code>","text":"<p>Stores the members of the union of all given sets specified by <code>keys</code> into a new set at <code>destination</code>.</p> <p>See https://valkey.io/commands/sunionstore for more details.</p> Note <p>When in cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys from which to retrieve the set members.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n&gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n&gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n    2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def sunionstore(\n    self,\n    destination: TEncodable,\n    keys: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Stores the members of the union of all given sets specified by `keys` into a new set at `destination`.\n\n    See https://valkey.io/commands/sunionstore for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key of the destination set.\n        keys (List[TEncodable]): The keys from which to retrieve the set members.\n\n    Returns:\n        int: The number of elements in the resulting set.\n\n    Examples:\n        &gt;&gt;&gt; await client.sadd(\"set1\", [\"member1\"])\n        &gt;&gt;&gt; await client.sadd(\"set2\", [\"member2\"])\n        &gt;&gt;&gt; await client.sunionstore(\"my_set\", [\"set1\", \"set2\"])\n            2  # Two elements were stored in \"my_set\", and those two members are the union of \"set1\" and \"set2\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.SUnionStore, [destination] + keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.touch","title":"<code>touch(keys)</code>  <code>async</code>","text":"<p>Updates the last access time of specified keys.</p> <p>See https://valkey.io/commands/touch/ for details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys to update last access time.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were updated, a key is ignored if it doesn't exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n&gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n&gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n    2  # Last access time of 2 keys has been updated.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def touch(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Updates the last access time of specified keys.\n\n    See https://valkey.io/commands/touch/ for details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The keys to update last access time.\n\n    Returns:\n        int: The number of keys that were updated, a key is ignored if it doesn't exist.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"myKey1\", \"value1\")\n        &gt;&gt;&gt; await client.set(\"myKey2\", \"value2\")\n        &gt;&gt;&gt; await client.touch([\"myKey1\", \"myKey2\", \"nonExistentKey\"])\n            2  # Last access time of 2 keys has been updated.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Touch, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.try_get_pubsub_message","title":"<code>try_get_pubsub_message()</code>","text":"<p>Tries to return the next pubsub message. Throws WrongConfiguration in cases: 1. No pubsub subscriptions are configured for the client 2. Callback is configured with the pubsub subsciptions</p> <p>See https://valkey.io/docs/topics/pubsub/ for more details.</p> <p>Returns:</p> Type Description <code>Optional[PubSubMsg]</code> <p>Optional[PubSubMsg]: The next pubsub message or None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>def try_get_pubsub_message(self) -&gt; Optional[PubSubMsg]:\n    \"\"\"\n    Tries to return the next pubsub message.\n    Throws WrongConfiguration in cases:\n    1. No pubsub subscriptions are configured for the client\n    2. Callback is configured with the pubsub subsciptions\n\n    See https://valkey.io/docs/topics/pubsub/ for more details.\n\n    Returns:\n        Optional[PubSubMsg]: The next pubsub message or None\n\n    Examples:\n        &gt;&gt;&gt; pubsub_msg = listening_client.try_get_pubsub_message()\n    \"\"\"\n    ...\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.ttl","title":"<code>ttl(key)</code>  <code>async</code>","text":"<p>Returns the remaining time to live of <code>key</code> that has a timeout. See https://valkey.io/commands/ttl/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to return its timeout.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TTL in seconds, -2 if <code>key</code> does not exist or -1 if <code>key</code> exists but has no associated expire.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ttl(\"my_key\")\n    3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n&gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n    -2  # Returns -2 for a non-existing key.\n&gt;&gt;&gt; await client.ttl(\"key\")\n    -1  # Indicates that \"key: has no has no associated expire.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def ttl(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the remaining time to live of `key` that has a timeout.\n    See https://valkey.io/commands/ttl/ for more details.\n\n    Args:\n        key (TEncodable): The key to return its timeout.\n\n    Returns:\n        int: TTL in seconds, -2 if `key` does not exist or -1 if `key` exists but has no associated expire.\n\n    Examples:\n        &gt;&gt;&gt; await client.ttl(\"my_key\")\n            3600  # Indicates that \"my_key\" has a remaining time to live of 3600 seconds.\n        &gt;&gt;&gt; await client.ttl(\"nonexistent_key\")\n            -2  # Returns -2 for a non-existing key.\n        &gt;&gt;&gt; await client.ttl(\"key\")\n            -1  # Indicates that \"key: has no has no associated expire.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.TTL, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.type","title":"<code>type(key)</code>  <code>async</code>","text":"<p>Returns the bytes string representation of the type of the value stored at <code>key</code>.</p> <p>See https://valkey.io/commands/type/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to check its data type.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>If the key exists, the type of the stored value is returned.</p> <code>bytes</code> <p>Otherwise, a b\"none\" bytes string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\")\n&gt;&gt;&gt; await client.type(\"key\")\n    b'string'\n&gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n&gt;&gt;&gt; await client.type(\"key\")\n    b'list'\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def type(self, key: TEncodable) -&gt; bytes:\n    \"\"\"\n    Returns the bytes string representation of the type of the value stored at `key`.\n\n    See https://valkey.io/commands/type/ for more details.\n\n    Args:\n        key (TEncodable): The key to check its data type.\n\n    Returns:\n        bytes: If the key exists, the type of the stored value is returned.\n        Otherwise, a b\"none\" bytes string is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\")\n        &gt;&gt;&gt; await client.type(\"key\")\n            b'string'\n        &gt;&gt;&gt; await client.lpush(\"key\", [\"value\"])\n        &gt;&gt;&gt; await client.type(\"key\")\n            b'list'\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.Type, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.unlink","title":"<code>unlink(keys)</code>  <code>async</code>","text":"<p>Unlink (delete) multiple keys from the database. A key is ignored if it does not exist. This command, similar to DEL, removes specified keys and ignores non-existent ones. However, this command does not block the server, while DEL does. See https://valkey.io/commands/unlink/ for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The list of keys to unlink.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys that were unlinked.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n    3  # Indicates that all three keys were unlinked from the database.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def unlink(self, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Unlink (delete) multiple keys from the database.\n    A key is ignored if it does not exist.\n    This command, similar to DEL, removes specified keys and ignores non-existent ones.\n    However, this command does not block the server, while [DEL](https://valkey.io/commands/del) does.\n    See https://valkey.io/commands/unlink/ for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The list of keys to unlink.\n\n    Returns:\n        int: The number of keys that were unlinked.\n\n    Examples:\n        &gt;&gt;&gt; await client.unlink([\"key1\", \"key2\", \"key3\"])\n            3  # Indicates that all three keys were unlinked from the database.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.Unlink, keys))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.watch","title":"<code>watch(keys)</code>  <code>async</code>","text":"<p>Marks the given keys to be watched for conditional execution of a transaction. Transactions will only execute commands if the watched keys are not modified before execution of the transaction.</p> <p>See https://valkey.io/commands/watch for more details.</p> Note <p>When in cluster mode, the command may route to multiple nodes when <code>keys</code> map to different hash slots.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys to watch.</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.watch(\"sampleKey\")\n    'OK'\n&gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n&gt;&gt;&gt; await client.exec(transaction)\n    'OK' # Executes successfully and keys are unwatched.\n</code></pre> <pre><code>&gt;&gt;&gt; await client.watch(\"sampleKey\")\n    'OK'\n&gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n&gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n    'OK'\n&gt;&gt;&gt; await client.exec(transaction)\n    None  # None is returned when the watched key is modified before transaction execution.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def watch(self, keys: List[TEncodable]) -&gt; TOK:\n    \"\"\"\n    Marks the given keys to be watched for conditional execution of a transaction. Transactions\n    will only execute commands if the watched keys are not modified before execution of the\n    transaction.\n\n    See https://valkey.io/commands/watch for more details.\n\n    Note:\n        When in cluster mode, the command may route to multiple nodes when `keys` map to different hash slots.\n\n    Args:\n        keys (List[TEncodable]): The keys to watch.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.watch(\"sampleKey\")\n            'OK'\n        &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n        &gt;&gt;&gt; await client.exec(transaction)\n            'OK' # Executes successfully and keys are unwatched.\n\n        &gt;&gt;&gt; await client.watch(\"sampleKey\")\n            'OK'\n        &gt;&gt;&gt; transaction.set(\"sampleKey\", \"foobar\")\n        &gt;&gt;&gt; await client.set(\"sampleKey\", \"hello world\")\n            'OK'\n        &gt;&gt;&gt; await client.exec(transaction)\n            None  # None is returned when the watched key is modified before transaction execution.\n    \"\"\"\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.Watch, keys),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xack","title":"<code>xack(key, group_name, ids)</code>  <code>async</code>","text":"<p>Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group. This command should be called on pending messages so that such messages do not get processed again by the consumer group.</p> <p>See https://valkey.io/commands/xack for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>The stream entry IDs to acknowledge and consume for the given consumer group.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of messages that were successfully acknowledged.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n    {\n        \"mystream\": {\n            \"1-0\": [[\"field1\", \"value1\"]],\n        }\n    }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n&gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n    1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xack(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    ids: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Removes one or multiple messages from the Pending Entries List (PEL) of a stream consumer group.\n    This command should be called on pending messages so that such messages do not get processed again by the\n    consumer group.\n\n    See https://valkey.io/commands/xack for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        ids (List[TEncodable]): The stream entry IDs to acknowledge and consume for the given consumer group.\n\n    Returns:\n        int: The number of messages that were successfully acknowledged.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\")\n            {\n                \"mystream\": {\n                    \"1-0\": [[\"field1\", \"value1\"]],\n                }\n            }  # Read one stream entry, the entry is now in the Pending Entries List for \"mygroup\".\n        &gt;&gt;&gt; await client.xack(\"mystream\", \"mygroup\", [\"1-0\"])\n            1  # 1 pending message was acknowledged and removed from the Pending Entries List for \"mygroup\".\n    \"\"\"\n    args: List[TEncodable] = [key, group_name]\n    args.extend(ids)\n    return cast(\n        int,\n        await self._execute_command(RequestType.XAck, [key, group_name] + ids),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xadd","title":"<code>xadd(key, values, options=None)</code>  <code>async</code>","text":"<p>Adds an entry to the specified stream stored at <code>key</code>. If the <code>key</code> doesn't exist, the stream is created.</p> <p>See https://valkey.io/commands/xadd for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>values</code> <code>List[Tuple[TEncodable, TEncodable]]</code> <p>Field-value pairs to be added to the entry.</p> required <code>options</code> <code>Optional[StreamAddOptions]</code> <p>Additional options for adding entries to the stream. Default to None. See <code>StreamAddOptions</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>Optional[bytes]</code> <p>The id of the added entry, or None if <code>options.make_stream</code> is set to False and no stream with the matching <code>key</code> exists.</p> Example <p>await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])     b\"1615957011958-0\"  # Example stream entry ID. await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))     None  # The key doesn't exist, therefore, None is returned. await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))     b\"0-1\"  # Returns the stream id.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xadd(\n    self,\n    key: TEncodable,\n    values: List[Tuple[TEncodable, TEncodable]],\n    options: Optional[StreamAddOptions] = None,\n) -&gt; Optional[bytes]:\n    \"\"\"\n    Adds an entry to the specified stream stored at `key`. If the `key` doesn't exist, the stream is created.\n\n    See https://valkey.io/commands/xadd for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        values (List[Tuple[TEncodable, TEncodable]]): Field-value pairs to be added to the entry.\n        options (Optional[StreamAddOptions]): Additional options for adding entries to the stream. Default to None. See `StreamAddOptions`.\n\n    Returns:\n        bytes: The id of the added entry, or None if `options.make_stream` is set to False and no stream with the matching `key` exists.\n\n    Example:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")])\n            b\"1615957011958-0\"  # Example stream entry ID.\n        &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\", make_stream=False))\n            None  # The key doesn't exist, therefore, None is returned.\n        &gt;&gt;&gt; await client.xadd(\"non_existing_stream\", [(field, \"foo1\"), (field2, \"bar1\")], StreamAddOptions(id=\"0-1\"))\n            b\"0-1\"  # Returns the stream id.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    if options:\n        args.extend(options.to_args())\n    else:\n        args.append(\"*\")\n    args.extend([field for pair in values for field in pair])\n\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.XAdd, args)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim","title":"<code>xautoclaim(key, group_name, consumer_name, min_idle_time_ms, start, count=None)</code>  <code>async</code>","text":"<p>Transfers ownership of pending stream entries that match the specified criteria.</p> <p>See https://valkey.io/commands/xautoclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>Filters the claimed entries to those that have been idle for more than the specified value.</p> required <code>start</code> <code>TEncodable</code> <p>Filters the claimed entries to those that have an ID equal or greater than the specified value.</p> required <code>count</code> <code>Optional[int]</code> <p>Limits the number of claimed entries to the specified value.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]</code> <p>List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements: - A stream ID to be used as the start argument for the next call to <code>XAUTOCLAIM</code>. This ID is equivalent to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was scanned. - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a 2D list of the field-value pairs in the format <code>[[field1, value1], [field2, value2], ...]</code>. - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are deleted from the Pending Entries List.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim--valkey-version-700","title":"Valkey version &lt; 7.0.0:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [\n        b\"0-0\",\n        {\n            b\"1-1\": [\n                [b\"field1\", b\"value1\"],\n                [b\"field2\", b\"value2\"],\n            ]\n        }\n    ]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned.\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim--valkey-version-700-and-above","title":"Valkey version 7.0.0 and above:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [\n        b\"0-0\",\n        {\n            b\"1-1\": [\n                [b\"field1\", b\"value1\"],\n                [b\"field2\", b\"value2\"],\n            ]\n        },\n        [b\"1-2\"]\n    ]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n    # exists in the stream.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xautoclaim(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    min_idle_time_ms: int,\n    start: TEncodable,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]:\n    \"\"\"\n    Transfers ownership of pending stream entries that match the specified criteria.\n\n    See https://valkey.io/commands/xautoclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name.\n        min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n            value.\n        start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n        count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n    Returns:\n        List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]]: A list containing the following elements:\n            - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n            to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n            scanned.\n            - A mapping of the claimed entries, with the keys being the claimed entry IDs and the values being a\n            2D list of the field-value pairs in the format `[[field1, value1], [field2, value2], ...]`.\n            - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n            message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n            deleted from the Pending Entries List.\n\n    Examples:\n        # Valkey version &lt; 7.0.0:\n        &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [\n                b\"0-0\",\n                {\n                    b\"1-1\": [\n                        [b\"field1\", b\"value1\"],\n                        [b\"field2\", b\"value2\"],\n                    ]\n                }\n            ]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned.\n\n        # Valkey version 7.0.0 and above:\n        &gt;&gt;&gt; await client.xautoclaim(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [\n                b\"0-0\",\n                {\n                    b\"1-1\": [\n                        [b\"field1\", b\"value1\"],\n                        [b\"field2\", b\"value2\"],\n                    ]\n                },\n                [b\"1-2\"]\n            ]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n            # exists in the stream.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [\n        key,\n        group_name,\n        consumer_name,\n        str(min_idle_time_ms),\n        start,\n    ]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        List[Union[bytes, Mapping[bytes, List[List[bytes]]], List[bytes]]],\n        await self._execute_command(RequestType.XAutoClaim, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim_just_id","title":"<code>xautoclaim_just_id(key, group_name, consumer_name, min_idle_time_ms, start, count=None)</code>  <code>async</code>","text":"<p>Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID argument to further specify that the return value should contain a list of claimed IDs without their field-value info.</p> <p>See https://valkey.io/commands/xautoclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>Filters the claimed entries to those that have been idle for more than the specified value.</p> required <code>start</code> <code>TEncodable</code> <p>Filters the claimed entries to those that have an ID equal or greater than the specified value.</p> required <code>count</code> <code>Optional[int]</code> <p>Limits the number of claimed entries to the specified value.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: A list containing the following elements: - A stream ID to be used as the start argument for the next call to <code>XAUTOCLAIM</code>. This ID is equivalent to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was scanned. - A list of the IDs for the claimed entries. - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are deleted from the Pending Entries List.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim_just_id--valkey-version-700","title":"Valkey version &lt; 7.0.0:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [b\"0-0\", [b\"1-1\"]]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned.\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xautoclaim_just_id--valkey-version-700-and-above","title":"Valkey version 7.0.0 and above:","text":"<pre><code>&gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n    [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n    # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n    # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n    # exists in the stream.\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xautoclaim_just_id(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    min_idle_time_ms: int,\n    start: TEncodable,\n    count: Optional[int] = None,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Transfers ownership of pending stream entries that match the specified criteria. This command uses the JUSTID\n    argument to further specify that the return value should contain a list of claimed IDs without their\n    field-value info.\n\n    See https://valkey.io/commands/xautoclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name.\n        min_idle_time_ms (int): Filters the claimed entries to those that have been idle for more than the specified\n            value.\n        start (TEncodable): Filters the claimed entries to those that have an ID equal or greater than the specified value.\n        count (Optional[int]): Limits the number of claimed entries to the specified value.\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: A list containing the following elements:\n            - A stream ID to be used as the start argument for the next call to `XAUTOCLAIM`. This ID is equivalent\n            to the next ID in the stream after the entries that were scanned, or \"0-0\" if the entire stream was\n            scanned.\n            - A list of the IDs for the claimed entries.\n            - If you are using Valkey 7.0.0 or above, the response list will also include a list containing the\n            message IDs that were in the Pending Entries List but no longer exist in the stream. These IDs are\n            deleted from the Pending Entries List.\n\n    Examples:\n        # Valkey version &lt; 7.0.0:\n        &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [b\"0-0\", [b\"1-1\"]]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned.\n\n        # Valkey version 7.0.0 and above:\n        &gt;&gt;&gt; await client.xautoclaim_just_id(\"my_stream\", \"my_group\", \"my_consumer\", 3_600_000, \"0-0\")\n            [b\"0-0\", [b\"1-1\"], [b\"1-2\"]]\n            # Stream entry \"1-1\" was idle for over an hour and was thus claimed by \"my_consumer\". The entire stream\n            # was scanned. Additionally, entry \"1-2\" was removed from the Pending Entries List because it no longer\n            # exists in the stream.\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [\n        key,\n        group_name,\n        consumer_name,\n        str(min_idle_time_ms),\n        start,\n    ]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    args.append(\"JUSTID\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.XAutoClaim, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xclaim","title":"<code>xclaim(key, group, consumer, min_idle_time_ms, ids, options=None)</code>  <code>async</code>","text":"<p>Changes the ownership of a pending message.</p> <p>See https://valkey.io/commands/xclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer</code> <code>TEncodable</code> <p>The group consumer.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>The minimum idle time for the message to be claimed.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>A array of entry ids.</p> required <code>options</code> <code>Optional[StreamClaimOptions]</code> <p>Stream claim options.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, List[List[bytes]]]</code> <p>Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xclaim--read-messages-from-streamid-for-consumer1","title":"read messages from streamId for consumer1","text":"<pre><code>&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }\n    # \"1-0\" is now read, and we can assign the pending messages to consumer2\n&gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n    {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xclaim(\n    self,\n    key: TEncodable,\n    group: TEncodable,\n    consumer: TEncodable,\n    min_idle_time_ms: int,\n    ids: List[TEncodable],\n    options: Optional[StreamClaimOptions] = None,\n) -&gt; Mapping[bytes, List[List[bytes]]]:\n    \"\"\"\n    Changes the ownership of a pending message.\n\n    See https://valkey.io/commands/xclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group (TEncodable): The consumer group name.\n        consumer (TEncodable): The group consumer.\n        min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n        ids (List[TEncodable]): A array of entry ids.\n        options (Optional[StreamClaimOptions]): Stream claim options.\n\n    Returns:\n        Mapping[bytes, List[List[bytes]]]: A Mapping of message entries with the format\n            {\"entryId\": [[\"entry\", \"data\"], ...], ...} that are claimed by the consumer.\n\n    Examples:\n        # read messages from streamId for consumer1\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }\n            # \"1-0\" is now read, and we can assign the pending messages to consumer2\n        &gt;&gt;&gt; await client.xclaim(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n            {b\"1-0\": [[b\"field1\", b\"value1\"]]}\n    \"\"\"\n\n    args = [key, group, consumer, str(min_idle_time_ms), *ids]\n\n    if options:\n        args.extend(options.to_args())\n\n    return cast(\n        Mapping[bytes, List[List[bytes]]],\n        await self._execute_command(RequestType.XClaim, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xclaim_just_id","title":"<code>xclaim_just_id(key, group, consumer, min_idle_time_ms, ids, options=None)</code>  <code>async</code>","text":"<p>Changes the ownership of a pending message. This function returns a List with only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.</p> <p>See https://valkey.io/commands/xclaim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer</code> <code>TEncodable</code> <p>The group consumer.</p> required <code>min_idle_time_ms</code> <code>int</code> <p>The minimum idle time for the message to be claimed.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>A array of entry ids.</p> required <code>options</code> <code>Optional[StreamClaimOptions]</code> <p>Stream claim options.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A List of message ids claimed by the consumer.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xclaim_just_id--read-messages-from-streamid-for-consumer1","title":"read messages from streamId for consumer1","text":"<pre><code>&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }\n    # \"1-0\" is now read, and we can assign the pending messages to consumer2\n&gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n    [b\"1-0\"]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xclaim_just_id(\n    self,\n    key: TEncodable,\n    group: TEncodable,\n    consumer: TEncodable,\n    min_idle_time_ms: int,\n    ids: List[TEncodable],\n    options: Optional[StreamClaimOptions] = None,\n) -&gt; List[bytes]:\n    \"\"\"\n    Changes the ownership of a pending message. This function returns a List with\n    only the message/entry IDs, and is equivalent to using JUSTID in the Valkey API.\n\n    See https://valkey.io/commands/xclaim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group (TEncodable): The consumer group name.\n        consumer (TEncodable): The group consumer.\n        min_idle_time_ms (int): The minimum idle time for the message to be claimed.\n        ids (List[TEncodable]): A array of entry ids.\n        options (Optional[StreamClaimOptions]): Stream claim options.\n\n    Returns:\n        List[bytes]: A List of message ids claimed by the consumer.\n\n    Examples:\n        # read messages from streamId for consumer1\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"consumer1\")\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }\n            # \"1-0\" is now read, and we can assign the pending messages to consumer2\n        &gt;&gt;&gt; await client.xclaim_just_id(\"mystream\", \"mygroup\", \"consumer2\", 0, [\"1-0\"])\n            [b\"1-0\"]\n    \"\"\"\n\n    args = [\n        key,\n        group,\n        consumer,\n        str(min_idle_time_ms),\n        *ids,\n        StreamClaimOptions.JUST_ID_VALKEY_API,\n    ]\n\n    if options:\n        args.extend(options.to_args())\n\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.XClaim, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xdel","title":"<code>xdel(key, ids)</code>  <code>async</code>","text":"<p>Removes the specified entries by id from a stream, and returns the number of entries deleted.</p> <p>See https://valkey.io/commands/xdel for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>ids</code> <code>List[TEncodable]</code> <p>An array of entry ids.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of entries removed from the stream. This number may be less than the number of entries in <code>ids</code>, if the specified <code>ids</code> don't exist in the stream.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n    2  # Stream marked 2 entries as deleted.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xdel(self, key: TEncodable, ids: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Removes the specified entries by id from a stream, and returns the number of entries deleted.\n\n    See https://valkey.io/commands/xdel for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        ids (List[TEncodable]): An array of entry ids.\n\n    Returns:\n        int: The number of entries removed from the stream. This number may be less than the number of entries in\n            `ids`, if the specified `ids` don't exist in the stream.\n\n    Examples:\n        &gt;&gt;&gt; await client.xdel(\"key\", [\"1538561698944-0\", \"1538561698944-1\"])\n            2  # Stream marked 2 entries as deleted.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    args.extend(ids)\n    return cast(\n        int,\n        await self._execute_command(RequestType.XDel, [key] + ids),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xgroup_create","title":"<code>xgroup_create(key, group_name, group_id, options=None)</code>  <code>async</code>","text":"<p>Creates a new consumer group uniquely identified by <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-create for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The newly created consumer group name.</p> required <code>group_id</code> <code>TEncodable</code> <p>The stream entry ID that specifies the last delivered entry in the stream from the new group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.</p> required <code>options</code> <code>Optional[StreamGroupOptions]</code> <p>Options for creating the stream group.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n    OK\n    # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n    # the most recent entry. The stream was created with length 0 if it did not already exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_create(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    group_id: TEncodable,\n    options: Optional[StreamGroupOptions] = None,\n) -&gt; TOK:\n    \"\"\"\n    Creates a new consumer group uniquely identified by `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-create for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The newly created consumer group name.\n        group_id (TEncodable): The stream entry ID that specifies the last delivered entry in the stream from the new\n            group\u2019s perspective. The special ID \"$\" can be used to specify the last entry in the stream.\n        options (Optional[StreamGroupOptions]): Options for creating the stream group.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"$\", StreamGroupOptions(make_stream=True))\n            OK\n            # Created the consumer group \"mygroup\" for the stream \"mystream\", which will track entries created after\n            # the most recent entry. The stream was created with length 0 if it did not already exist.\n    \"\"\"\n    args: List[TEncodable] = [key, group_name, group_id]\n    if options is not None:\n        args.extend(options.to_args())\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.XGroupCreate, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xgroup_create_consumer","title":"<code>xgroup_create_consumer(key, group_name, consumer_name)</code>  <code>async</code>","text":"<p>Creates a consumer named <code>consumer_name</code> in the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-createconsumer for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The newly created consumer.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the consumer is created. Otherwise, returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n    True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_create_consumer(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n) -&gt; bool:\n    \"\"\"\n    Creates a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-createconsumer for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The newly created consumer.\n\n    Returns:\n        bool: True if the consumer is created. Otherwise, returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_create_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n            True  # The consumer \"myconsumer\" was created in consumer group \"mygroup\" for the stream \"mystream\".\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(\n            RequestType.XGroupCreateConsumer, [key, group_name, consumer_name]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xgroup_del_consumer","title":"<code>xgroup_del_consumer(key, group_name, consumer_name)</code>  <code>async</code>","text":"<p>Deletes a consumer named <code>consumer_name</code> in the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-delconsumer for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer to delete.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of pending messages the <code>consumer</code> had before it was deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n    5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_del_consumer(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n) -&gt; int:\n    \"\"\"\n    Deletes a consumer named `consumer_name` in the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-delconsumer for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer to delete.\n\n    Returns:\n        int: The number of pending messages the `consumer` had before it was deleted.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_del_consumer(\"mystream\", \"mygroup\", \"myconsumer\")\n            5  # Consumer \"myconsumer\" was deleted, and had 5 pending messages unclaimed.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.XGroupDelConsumer, [key, group_name, consumer_name]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xgroup_destroy","title":"<code>xgroup_destroy(key, group_name)</code>  <code>async</code>","text":"<p>Destroys the consumer group <code>group_name</code> for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xgroup-destroy for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the consumer group was destroyed. Otherwise, returns False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n    True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_destroy(self, key: TEncodable, group_name: TEncodable) -&gt; bool:\n    \"\"\"\n    Destroys the consumer group `group_name` for the stream stored at `key`.\n\n    See https://valkey.io/commands/xgroup-destroy for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name to delete.\n\n    Returns:\n        bool: True if the consumer group was destroyed. Otherwise, returns False.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_destroy(\"mystream\", \"mygroup\")\n            True  # The consumer group \"mygroup\" for stream \"mystream\" was destroyed.\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.XGroupDestroy, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xgroup_set_id","title":"<code>xgroup_set_id(key, group_name, stream_id, entries_read=None)</code>  <code>async</code>","text":"<p>Set the last delivered ID for a consumer group.</p> <p>See https://valkey.io/commands/xgroup-setid for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>stream_id</code> <code>TEncodable</code> <p>The stream entry ID that should be set as the last delivered ID for the consumer group.</p> required <code>entries_read</code> <code>Optional[int]</code> <p>(Optional[int]): A value representing the number of stream entries already read by the group. This option can only be specified if you are using Valkey version 7.0.0 or above.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n    OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xgroup_set_id(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    stream_id: TEncodable,\n    entries_read: Optional[int] = None,\n) -&gt; TOK:\n    \"\"\"\n    Set the last delivered ID for a consumer group.\n\n    See https://valkey.io/commands/xgroup-setid for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        stream_id (TEncodable): The stream entry ID that should be set as the last delivered ID for the consumer group.\n        entries_read: (Optional[int]): A value representing the number of stream entries already read by the\n            group. This option can only be specified if you are using Valkey version 7.0.0 or above.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xgroup_set_id(\"mystream\", \"mygroup\", \"0\")\n            OK  # The last delivered ID for consumer group \"mygroup\" was set to 0.\n    \"\"\"\n    args: List[TEncodable] = [key, group_name, stream_id]\n    if entries_read is not None:\n        args.extend([\"ENTRIESREAD\", str(entries_read)])\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.XGroupSetId, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xinfo_consumers","title":"<code>xinfo_consumers(key, group_name)</code>  <code>async</code>","text":"<p>Returns the list of all consumers and their attributes for the given consumer group of the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-consumers for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <p>Returns:</p> Type Description <code>List[Mapping[bytes, Union[bytes, int]]]</code> <p>List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a consumer for the given consumer group of the stream at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n    [\n        {\n            b\"name\": b\"Alice\",\n            b\"pending\": 1,\n            b\"idle\": 9104628,\n            b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n        },\n        {\n            b\"name\": b\"Bob\",\n            b\"pending\": 1,\n            b\"idle\": 83841983,\n            b\"inactive\": 993841998,\n        }\n    ]\n    # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_consumers(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n) -&gt; List[Mapping[bytes, Union[bytes, int]]]:\n    \"\"\"\n    Returns the list of all consumers and their attributes for the given consumer group of the stream stored at\n    `key`.\n\n    See https://valkey.io/commands/xinfo-consumers for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n\n    Returns:\n        List[Mapping[bytes, Union[bytes, int]]]: A list of mappings, where each mapping contains the attributes of a\n            consumer for the given consumer group of the stream at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_consumers(\"my_stream\", \"my_group\")\n            [\n                {\n                    b\"name\": b\"Alice\",\n                    b\"pending\": 1,\n                    b\"idle\": 9104628,\n                    b\"inactive\": 18104698,  # The \"inactive\" field was added in Valkey version 7.2.0.\n                },\n                {\n                    b\"name\": b\"Bob\",\n                    b\"pending\": 1,\n                    b\"idle\": 83841983,\n                    b\"inactive\": 993841998,\n                }\n            ]\n            # The list of consumers and their attributes for consumer group \"my_group\" of stream \"my_stream\".\n    \"\"\"\n    return cast(\n        List[Mapping[bytes, Union[bytes, int]]],\n        await self._execute_command(RequestType.XInfoConsumers, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xinfo_groups","title":"<code>xinfo_groups(key)</code>  <code>async</code>","text":"<p>Returns the list of all consumer groups and their attributes for the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-groups for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Type Description <code>List[Mapping[bytes, Union[bytes, int, None]]]</code> <p>List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the attributes of a consumer group for the stream at <code>key</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n    [\n        {\n            b\"name\": b\"mygroup\",\n            b\"consumers\": 2,\n            b\"pending\": 2,\n            b\"last-delivered-id\": b\"1638126030001-0\",\n            b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n            b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n        },\n        {\n            b\"name\": b\"some-other-group\",\n            b\"consumers\": 1,\n            b\"pending\": 0,\n            b\"last-delivered-id\": b\"1638126028070-0\",\n            b\"entries-read\": 1,\n            b\"lag\": 1,\n        }\n    ]\n    # The list of consumer groups and their attributes for stream \"my_stream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_groups(\n    self,\n    key: TEncodable,\n) -&gt; List[Mapping[bytes, Union[bytes, int, None]]]:\n    \"\"\"\n    Returns the list of all consumer groups and their attributes for the stream stored at `key`.\n\n    See https://valkey.io/commands/xinfo-groups for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        List[Mapping[bytes, Union[bytes, int, None]]]: A list of mappings, where each mapping represents the\n            attributes of a consumer group for the stream at `key`.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_groups(\"my_stream\")\n            [\n                {\n                    b\"name\": b\"mygroup\",\n                    b\"consumers\": 2,\n                    b\"pending\": 2,\n                    b\"last-delivered-id\": b\"1638126030001-0\",\n                    b\"entries-read\": 2,  # The \"entries-read\" field was added in Valkey version 7.0.0.\n                    b\"lag\": 0,  # The \"lag\" field was added in Valkey version 7.0.0.\n                },\n                {\n                    b\"name\": b\"some-other-group\",\n                    b\"consumers\": 1,\n                    b\"pending\": 0,\n                    b\"last-delivered-id\": b\"1638126028070-0\",\n                    b\"entries-read\": 1,\n                    b\"lag\": 1,\n                }\n            ]\n            # The list of consumer groups and their attributes for stream \"my_stream\".\n    \"\"\"\n    return cast(\n        List[Mapping[bytes, Union[bytes, int, None]]],\n        await self._execute_command(RequestType.XInfoGroups, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xinfo_stream","title":"<code>xinfo_stream(key)</code>  <code>async</code>","text":"<p>Returns information about the stream stored at <code>key</code>. To get more detailed information, use <code>xinfo_stream_full</code>.</p> <p>See https://valkey.io/commands/xinfo-stream for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Name Type Description <code>TXInfoStreamResponse</code> <code>TXInfoStreamResponse</code> <p>A mapping of stream information for the given <code>key</code>. See the example for a sample response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n    {\n        b\"length\": 4,\n        b\"radix-tree-keys\": 1L,\n        b\"radix-tree-nodes\": 2L,\n        b\"last-generated-id\": b\"1719877599564-0\",\n        b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n        b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n        b\"groups\": 1L,\n        b\"first-entry\": [\n            b\"1719710679916-0\",\n            [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n        ],\n        b\"last-entry\": [\n            b\"1719877599564-0\",\n            [b\"field1\", b\"value1\"],\n        ],\n    }\n    # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n    # the stream is empty.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_stream(\n    self,\n    key: TEncodable,\n) -&gt; TXInfoStreamResponse:\n    \"\"\"\n    Returns information about the stream stored at `key`. To get more detailed information, use `xinfo_stream_full`.\n\n    See https://valkey.io/commands/xinfo-stream for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        TXInfoStreamResponse: A mapping of stream information for the given `key`. See the example for a sample\n            response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_stream(\"my_stream\")\n            {\n                b\"length\": 4,\n                b\"radix-tree-keys\": 1L,\n                b\"radix-tree-nodes\": 2L,\n                b\"last-generated-id\": b\"1719877599564-0\",\n                b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                b\"groups\": 1L,\n                b\"first-entry\": [\n                    b\"1719710679916-0\",\n                    [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                ],\n                b\"last-entry\": [\n                    b\"1719877599564-0\",\n                    [b\"field1\", b\"value1\"],\n                ],\n            }\n            # Stream information for \"my_stream\". Note that \"first-entry\" and \"last-entry\" could both be `None` if\n            # the stream is empty.\n    \"\"\"\n    return cast(\n        TXInfoStreamResponse,\n        await self._execute_command(RequestType.XInfoStream, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xinfo_stream_full","title":"<code>xinfo_stream_full(key, count=None)</code>  <code>async</code>","text":"<p>Returns verbose information about the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xinfo-stream for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of stream and PEL entries that are returned. A value of <code>0</code> means that all entries will be returned. If not provided, defaults to <code>10</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TXInfoStreamFullResponse</code> <code>TXInfoStreamFullResponse</code> <p>A mapping of detailed stream information for the given <code>key</code>. See the example for a sample response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n    {\n        b\"length\": 4,\n        b\"radix-tree-keys\": 1L,\n        b\"radix-tree-nodes\": 2L,\n        b\"last-generated-id\": b\"1719877599564-0\",\n        b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n        b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n        b\"entries\": [\n            [\n                b\"1719710679916-0\",\n                [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n            ],\n            [\n                b\"1719877599564-0\":\n                [b\"field1\", b\"value1\"],\n            ]\n        ],\n        b\"groups\": [\n            {\n                b\"name\": b\"mygroup\",\n                b\"last-delivered-id\": b\"1719710688676-0\",\n                b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                b\"pel-count\": 2,\n                b\"pending\": [\n                    [\n                        b\"1719710679916-0\",\n                        b\"Alice\",\n                        1719710707260,\n                        1,\n                    ],\n                    [\n                        b\"1719710688676-0\",\n                        b\"Alice\",\n                        1719710718373,\n                        1,\n                    ],\n                ],\n                b\"consumers\": [\n                    {\n                        b\"name\": b\"Alice\",\n                        b\"seen-time\": 1719710718373,\n                        b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                        b\"pel-count\": 2,\n                        b\"pending\": [\n                            [\n                                b\"1719710679916-0\",\n                                1719710707260,\n                                1\n                            ],\n                            [\n                                b\"1719710688676-0\",\n                                1719710718373,\n                                1\n                            ]\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\n    # Detailed stream information for \"my_stream\".\n</code></pre> <p>Since: Valkey version 6.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xinfo_stream_full(\n    self,\n    key: TEncodable,\n    count: Optional[int] = None,\n) -&gt; TXInfoStreamFullResponse:\n    \"\"\"\n    Returns verbose information about the stream stored at `key`.\n\n    See https://valkey.io/commands/xinfo-stream for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        count (Optional[int]): The number of stream and PEL entries that are returned. A value of `0` means that all\n            entries will be returned. If not provided, defaults to `10`.\n\n    Returns:\n        TXInfoStreamFullResponse: A mapping of detailed stream information for the given `key`. See the example for\n            a sample response.\n\n    Examples:\n        &gt;&gt;&gt; await client.xinfo_stream_full(\"my_stream\")\n            {\n                b\"length\": 4,\n                b\"radix-tree-keys\": 1L,\n                b\"radix-tree-nodes\": 2L,\n                b\"last-generated-id\": b\"1719877599564-0\",\n                b\"max-deleted-entry-id\": b\"0-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries-added\": 4L,  # This field was added in Valkey version 7.0.0.\n                b\"recorded-first-entry-id\": b\"1719710679916-0\",  # This field was added in Valkey version 7.0.0.\n                b\"entries\": [\n                    [\n                        b\"1719710679916-0\",\n                        [b\"foo1\", b\"bar1\", b\"foo2\", b\"bar2\"],\n                    ],\n                    [\n                        b\"1719877599564-0\":\n                        [b\"field1\", b\"value1\"],\n                    ]\n                ],\n                b\"groups\": [\n                    {\n                        b\"name\": b\"mygroup\",\n                        b\"last-delivered-id\": b\"1719710688676-0\",\n                        b\"entries-read\": 2,  # This field was added in Valkey version 7.0.0.\n                        b\"lag\": 0,  # This field was added in Valkey version 7.0.0.\n                        b\"pel-count\": 2,\n                        b\"pending\": [\n                            [\n                                b\"1719710679916-0\",\n                                b\"Alice\",\n                                1719710707260,\n                                1,\n                            ],\n                            [\n                                b\"1719710688676-0\",\n                                b\"Alice\",\n                                1719710718373,\n                                1,\n                            ],\n                        ],\n                        b\"consumers\": [\n                            {\n                                b\"name\": b\"Alice\",\n                                b\"seen-time\": 1719710718373,\n                                b\"active-time\": 1719710718373,  # This field was added in Valkey version 7.2.0.\n                                b\"pel-count\": 2,\n                                b\"pending\": [\n                                    [\n                                        b\"1719710679916-0\",\n                                        1719710707260,\n                                        1\n                                    ],\n                                    [\n                                        b\"1719710688676-0\",\n                                        1719710718373,\n                                        1\n                                    ]\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }\n            # Detailed stream information for \"my_stream\".\n\n    Since: Valkey version 6.0.0.\n    \"\"\"\n    args = [key, \"FULL\"]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        TXInfoStreamFullResponse,\n        await self._execute_command(RequestType.XInfoStream, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xlen","title":"<code>xlen(key)</code>  <code>async</code>","text":"<p>Returns the number of entries in the stream stored at <code>key</code>.</p> <p>See https://valkey.io/commands/xlen for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of entries in the stream. If <code>key</code> does not exist, returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n&gt;&gt;&gt; await client.xlen(\"mystream\")\n    2  # There are 2 entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xlen(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the number of entries in the stream stored at `key`.\n\n    See https://valkey.io/commands/xlen for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n\n    Returns:\n        int: The number of entries in the stream. If `key` does not exist, returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\")])\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\")])\n        &gt;&gt;&gt; await client.xlen(\"mystream\")\n            2  # There are 2 entries in \"mystream\".\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.XLen, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xpending","title":"<code>xpending(key, group_name)</code>  <code>async</code>","text":"<p>Returns stream message summary information for pending messages for the given consumer group.</p> <p>See https://valkey.io/commands/xpending for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <p>Returns:</p> Type Description <code>List[Union[int, bytes, List[List[bytes]], None]]</code> <p>List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the format <code>[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]</code>, where: - <code>num_group_messages</code>: The total number of pending messages for this consumer group. - <code>start_id</code>: The smallest ID among the pending messages. - <code>end_id</code>: The greatest ID among the pending messages. - <code>[[consumer_name, num_consumer_messages]]</code>: A 2D list of every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</p> <p>If there are no pending messages for the given consumer group, <code>[0, None, None, None]</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n    [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xpending(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n) -&gt; List[Union[int, bytes, List[List[bytes]], None]]:\n    \"\"\"\n    Returns stream message summary information for pending messages for the given consumer group.\n\n    See https://valkey.io/commands/xpending for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n\n    Returns:\n        List[Union[int, bytes, List[List[bytes]], None]]: A list that includes the summary of pending messages, with the\n            format `[num_group_messages, start_id, end_id, [[consumer_name, num_consumer_messages]]]`, where:\n            - `num_group_messages`: The total number of pending messages for this consumer group.\n            - `start_id`: The smallest ID among the pending messages.\n            - `end_id`: The greatest ID among the pending messages.\n            - `[[consumer_name, num_consumer_messages]]`: A 2D list of every consumer in the consumer group with at\n            least one pending message, and the number of pending messages it has.\n\n            If there are no pending messages for the given consumer group, `[0, None, None, None]` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.xpending(\"my_stream\", \"my_group\")\n            [4, \"1-0\", \"1-3\", [[\"my_consumer1\", \"3\"], [\"my_consumer2\", \"1\"]]\n    \"\"\"\n    return cast(\n        List[Union[int, bytes, List[List[bytes]], None]],\n        await self._execute_command(RequestType.XPending, [key, group_name]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xpending_range","title":"<code>xpending_range(key, group_name, start, end, count, options=None)</code>  <code>async</code>","text":"<p>Returns an extended form of stream message information for pending messages matching a given range of IDs.</p> <p>See https://valkey.io/commands/xpending for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>count</code> <code>int</code> <p>Limits the number of messages returned.</p> required <code>options</code> <code>Optional[StreamPendingOptions]</code> <p>The stream pending options.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[List[Union[bytes, int]]]</code> <p>List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended message information with the format <code>[[id, consumer_name, time_elapsed, num_delivered]]</code>, where: - <code>id</code>: The ID of the message. - <code>consumer_name</code>: The name of the consumer that fetched the message and has still to acknowledge it. We call it the current owner of the message. - <code>time_elapsed</code>: The number of milliseconds that elapsed since the last time this message was delivered to this consumer. - <code>num_delivered</code>: The number of times this message was delivered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n    [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n    # Extended stream entry information for the pending entries associated with \"my_consumer\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xpending_range(\n    self,\n    key: TEncodable,\n    group_name: TEncodable,\n    start: StreamRangeBound,\n    end: StreamRangeBound,\n    count: int,\n    options: Optional[StreamPendingOptions] = None,\n) -&gt; List[List[Union[bytes, int]]]:\n    \"\"\"\n    Returns an extended form of stream message information for pending messages matching a given range of IDs.\n\n    See https://valkey.io/commands/xpending for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        group_name (TEncodable): The consumer group name.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        count (int): Limits the number of messages returned.\n        options (Optional[StreamPendingOptions]): The stream pending options.\n\n    Returns:\n        List[List[Union[bytes, int]]]: A list of lists, where each inner list is a length 4 list containing extended\n            message information with the format `[[id, consumer_name, time_elapsed, num_delivered]]`, where:\n            - `id`: The ID of the message.\n            - `consumer_name`: The name of the consumer that fetched the message and has still to acknowledge it. We\n            call it the current owner of the message.\n            - `time_elapsed`: The number of milliseconds that elapsed since the last time this message was delivered\n            to this consumer.\n            - `num_delivered`: The number of times this message was delivered.\n\n    Examples:\n        &gt;&gt;&gt; await client.xpending_range(\"my_stream\", \"my_group\", MinId(), MaxId(), 10, StreamPendingOptions(consumer_name=\"my_consumer\"))\n            [[b\"1-0\", b\"my_consumer\", 1234, 1], [b\"1-1\", b\"my_consumer\", 1123, 1]]\n            # Extended stream entry information for the pending entries associated with \"my_consumer\".\n    \"\"\"\n    args = _create_xpending_range_args(key, group_name, start, end, count, options)\n    return cast(\n        List[List[Union[bytes, int]]],\n        await self._execute_command(RequestType.XPending, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xrange","title":"<code>xrange(key, start, end, count=None)</code>  <code>async</code>","text":"<p>Returns stream entries matching a given range of IDs.</p> <p>See https://valkey.io/commands/xrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>count</code> <code>Optional[int]</code> <p>An optional argument specifying the maximum count of stream entries to return. If <code>count</code> is not provided, all stream entries in the range will be returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[List[bytes]]]]</code> <p>Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the range arguments are not applicable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n    {\n        b\"0-1\": [[b\"field1\", b\"value1\"]],\n        b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n    }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xrange(\n    self,\n    key: TEncodable,\n    start: StreamRangeBound,\n    end: StreamRangeBound,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n    \"\"\"\n    Returns stream entries matching a given range of IDs.\n\n    See https://valkey.io/commands/xrange for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n            If `count` is not provided, all stream entries in the range will be returned.\n\n    Returns:\n        Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n            list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n            arguments are not applicable.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xrange(\"mystream\", MinId(), MaxId())\n            {\n                b\"0-1\": [[b\"field1\", b\"value1\"]],\n                b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n            }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n    \"\"\"\n    args: List[TEncodable] = [key, start.to_arg(), end.to_arg()]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[Mapping[bytes, List[List[bytes]]]],\n        await self._execute_command(RequestType.XRange, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xread","title":"<code>xread(keys_and_ids, options=None)</code>  <code>async</code>","text":"<p>Reads entries from the given streams.</p> <p>See https://valkey.io/commands/xread for more details.</p> Note <p>When in cluster mode, all keys in <code>keys_and_ids</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys_and_ids</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A mapping of keys and entry IDs to read from.</p> required <code>options</code> <code>Optional[StreamReadOptions]</code> <p>Options detailing how to read the stream.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]</code> <p>Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs, to a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. None will be returned under the following conditions: - All key-ID pairs in <code>keys_and_ids</code> have either a non-existing key or a non-existing ID, or there are no entries after the given ID. - The <code>BLOCK</code> option is specified and the timeout is hit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n    {\n        b\"mystream\": {\n            b\"0-1\": [[b\"field1\", b\"value1\"]],\n            b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n        }\n    }\n    # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n    # 1000ms if there is no stream data.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xread(\n    self,\n    keys_and_ids: Mapping[TEncodable, TEncodable],\n    options: Optional[StreamReadOptions] = None,\n) -&gt; Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]:\n    \"\"\"\n    Reads entries from the given streams.\n\n    See https://valkey.io/commands/xread for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n    Args:\n        keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of keys and entry IDs to read from.\n        options (Optional[StreamReadOptions]): Options detailing how to read the stream.\n\n    Returns:\n        Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]]: A mapping of stream keys, to a mapping of stream IDs,\n            to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n            None will be returned under the following conditions:\n            - All key-ID pairs in `keys_and_ids` have either a non-existing key or a non-existing ID, or there are no entries after the given ID.\n            - The `BLOCK` option is specified and the timeout is hit.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xread({\"mystream\": \"0-0\"}, StreamReadOptions(block_ms=1000))\n            {\n                b\"mystream\": {\n                    b\"0-1\": [[b\"field1\", b\"value1\"]],\n                    b\"0-2\": [[b\"field2\", b\"value2\"], [b\"field2\", b\"value3\"]],\n                }\n            }\n            # Indicates the stream entries for \"my_stream\" with IDs greater than \"0-0\". The operation blocks up to\n            # 1000ms if there is no stream data.\n    \"\"\"\n    args: List[TEncodable] = [] if options is None else options.to_args()\n    args.append(\"STREAMS\")\n    args.extend([key for key in keys_and_ids.keys()])\n    args.extend([value for value in keys_and_ids.values()])\n\n    return cast(\n        Optional[Mapping[bytes, Mapping[bytes, List[List[bytes]]]]],\n        await self._execute_command(RequestType.XRead, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xreadgroup","title":"<code>xreadgroup(keys_and_ids, group_name, consumer_name, options=None)</code>  <code>async</code>","text":"<p>Reads entries from the given streams owned by a consumer group.</p> <p>See https://valkey.io/commands/xreadgroup for more details.</p> Note <p>When in cluster mode, all keys in <code>keys_and_ids</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys_and_ids</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A mapping of stream keys to stream entry IDs to read from. Use the special entry ID of <code>\"&gt;\"</code> to receive only new messages.</p> required <code>group_name</code> <code>TEncodable</code> <p>The consumer group name.</p> required <code>consumer_name</code> <code>TEncodable</code> <p>The consumer name. The consumer will be auto-created if it does not already exist.</p> required <code>options</code> <code>Optional[StreamReadGroupOptions]</code> <p>Options detailing how to read the stream.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]</code> <p>Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of stream IDs, to a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n&gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n&gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n    {\n        b\"mystream\": {\n            b\"1-0\": [[b\"field1\", b\"value1\"]],\n        }\n    }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xreadgroup(\n    self,\n    keys_and_ids: Mapping[TEncodable, TEncodable],\n    group_name: TEncodable,\n    consumer_name: TEncodable,\n    options: Optional[StreamReadGroupOptions] = None,\n) -&gt; Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]:\n    \"\"\"\n    Reads entries from the given streams owned by a consumer group.\n\n    See https://valkey.io/commands/xreadgroup for more details.\n\n    Note:\n        When in cluster mode, all keys in `keys_and_ids` must map to the same hash slot.\n\n    Args:\n        keys_and_ids (Mapping[TEncodable, TEncodable]): A mapping of stream keys to stream entry IDs to read from.\n            Use the special entry ID of `\"&gt;\"` to receive only new messages.\n        group_name (TEncodable): The consumer group name.\n        consumer_name (TEncodable): The consumer name. The consumer will be auto-created if it does not already exist.\n        options (Optional[StreamReadGroupOptions]): Options detailing how to read the stream.\n\n    Returns:\n        Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]]: A mapping of stream keys, to a mapping of\n            stream IDs, to a list of pairings with format `[[field, entry], [field, entry], ...]`.\n            Returns None if the BLOCK option is given and a timeout occurs, or if there is no stream that can be served.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"1-0\"))\n        &gt;&gt;&gt; await client.xgroup_create(\"mystream\", \"mygroup\", \"0-0\")\n        &gt;&gt;&gt; await client.xreadgroup({\"mystream\": \"&gt;\"}, \"mygroup\", \"myconsumer\", StreamReadGroupOptions(count=1))\n            {\n                b\"mystream\": {\n                    b\"1-0\": [[b\"field1\", b\"value1\"]],\n                }\n            }  # Read one stream entry from \"mystream\" using \"myconsumer\" in the consumer group \"mygroup\".\n    \"\"\"\n    args: List[TEncodable] = [\"GROUP\", group_name, consumer_name]\n    if options is not None:\n        args.extend(options.to_args())\n\n    args.append(\"STREAMS\")\n    args.extend([key for key in keys_and_ids.keys()])\n    args.extend([value for value in keys_and_ids.values()])\n\n    return cast(\n        Optional[Mapping[bytes, Mapping[bytes, Optional[List[List[bytes]]]]]],\n        await self._execute_command(RequestType.XReadGroup, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xrevrange","title":"<code>xrevrange(key, end, start, count=None)</code>  <code>async</code>","text":"<p>Returns stream entries matching a given range of IDs in reverse order. Equivalent to <code>XRANGE</code> but returns the entries in reverse order.</p> <p>See https://valkey.io/commands/xrevrange for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>end</code> <code>StreamRangeBound</code> <p>The ending stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MaxId</code> to end with the maximum available ID.</p> required <code>start</code> <code>StreamRangeBound</code> <p>The starting stream ID bound for the range. - Use <code>IdBound</code> to specify a stream ID. - Use <code>ExclusiveIdBound</code> to specify an exclusive bounded stream ID. - Use <code>MinId</code> to start with the minimum available ID.</p> required <code>count</code> <code>Optional[int]</code> <p>An optional argument specifying the maximum count of stream entries to return. If <code>count</code> is not provided, all stream entries in the range will be returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Mapping[bytes, List[List[bytes]]]]</code> <p>Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a list of pairings with format <code>[[field, entry], [field, entry], ...]</code>. Returns None if the range arguments are not applicable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n&gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n&gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n    {\n        \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n        \"0-1\": [[\"field1\", \"value1\"]],\n    }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xrevrange(\n    self,\n    key: TEncodable,\n    end: StreamRangeBound,\n    start: StreamRangeBound,\n    count: Optional[int] = None,\n) -&gt; Optional[Mapping[bytes, List[List[bytes]]]]:\n    \"\"\"\n    Returns stream entries matching a given range of IDs in reverse order. Equivalent to `XRANGE` but returns the\n    entries in reverse order.\n\n    See https://valkey.io/commands/xrevrange for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        end (StreamRangeBound): The ending stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MaxId` to end with the maximum available ID.\n        start (StreamRangeBound): The starting stream ID bound for the range.\n            - Use `IdBound` to specify a stream ID.\n            - Use `ExclusiveIdBound` to specify an exclusive bounded stream ID.\n            - Use `MinId` to start with the minimum available ID.\n        count (Optional[int]): An optional argument specifying the maximum count of stream entries to return.\n            If `count` is not provided, all stream entries in the range will be returned.\n\n    Returns:\n        Optional[Mapping[bytes, List[List[bytes]]]]: A mapping of stream IDs to stream entry data, where entry data is a\n            list of pairings with format `[[field, entry], [field, entry], ...]`. Returns None if the range\n            arguments are not applicable.\n\n    Examples:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field1\", \"value1\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field2\", \"value2\"), (\"field2\", \"value3\")], StreamAddOptions(id=\"0-2\"))\n        &gt;&gt;&gt; await client.xrevrange(\"mystream\", MaxId(), MinId())\n            {\n                \"0-2\": [[\"field2\", \"value2\"], [\"field2\", \"value3\"]],\n                \"0-1\": [[\"field1\", \"value1\"]],\n            }  # Indicates the stream IDs and their associated field-value pairs for all stream entries in \"mystream\".\n    \"\"\"\n    args: List[TEncodable] = [key, end.to_arg(), start.to_arg()]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[Mapping[bytes, List[List[bytes]]]],\n        await self._execute_command(RequestType.XRevRange, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.xtrim","title":"<code>xtrim(key, options)</code>  <code>async</code>","text":"<p>Trims the stream stored at <code>key</code> by evicting older entries.</p> <p>See https://valkey.io/commands/xtrim for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the stream.</p> required <code>options</code> <code>StreamTrimOptions</code> <p>Options detailing how to trim the stream. See <code>StreamTrimOptions</code>.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>TThe number of entries deleted from the stream. If <code>key</code> doesn't exist, 0 is returned.</p> Example <p>await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\")) await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))     1 # One entry was deleted from the stream.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def xtrim(\n    self,\n    key: TEncodable,\n    options: StreamTrimOptions,\n) -&gt; int:\n    \"\"\"\n    Trims the stream stored at `key` by evicting older entries.\n\n    See https://valkey.io/commands/xtrim for more details.\n\n    Args:\n        key (TEncodable): The key of the stream.\n        options (StreamTrimOptions): Options detailing how to trim the stream. See `StreamTrimOptions`.\n\n    Returns:\n        int: TThe number of entries deleted from the stream. If `key` doesn't exist, 0 is returned.\n\n    Example:\n        &gt;&gt;&gt; await client.xadd(\"mystream\", [(\"field\", \"value\"), (\"field2\", \"value2\")], StreamAddOptions(id=\"0-1\"))\n        &gt;&gt;&gt; await client.xtrim(\"mystream\", TrimByMinId(exact=True, threshold=\"0-2\")))\n            1 # One entry was deleted from the stream.\n    \"\"\"\n    args = [key]\n    if options:\n        args.extend(options.to_args())\n\n    return cast(int, await self._execute_command(RequestType.XTrim, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zadd","title":"<code>zadd(key, members_scores, existing_options=None, update_condition=None, changed=False)</code>  <code>async</code>","text":"<p>Adds members with their scores to the sorted set stored at <code>key</code>. If a member is already a part of the sorted set, its score is updated.</p> <p>See https://valkey.io/commands/zadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members_scores</code> <code>Mapping[TEncodable, float]</code> <p>A mapping of members to their corresponding scores.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling existing members. - NX: Only add new elements. - XX: Only update existing elements.</p> <code>None</code> <code>update_condition</code> <code>Optional[UpdateOptions]</code> <p>Options for updating scores. - GT: Only update scores greater than the current values. - LT: Only update scores less than the current values.</p> <code>None</code> <code>changed</code> <code>bool</code> <p>Modify the return value to return the number of changed elements, instead of the number of new elements added.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements added to the sorted set.</p> <code>int</code> <p>If <code>changed</code> is set, returns the number of elements updated in the sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n    2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n&gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n    2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zadd(\n    self,\n    key: TEncodable,\n    members_scores: Mapping[TEncodable, float],\n    existing_options: Optional[ConditionalChange] = None,\n    update_condition: Optional[UpdateOptions] = None,\n    changed: bool = False,\n) -&gt; int:\n    \"\"\"\n    Adds members with their scores to the sorted set stored at `key`.\n    If a member is already a part of the sorted set, its score is updated.\n\n    See https://valkey.io/commands/zadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members_scores (Mapping[TEncodable, float]): A mapping of members to their corresponding scores.\n        existing_options (Optional[ConditionalChange]): Options for handling existing members.\n            - NX: Only add new elements.\n            - XX: Only update existing elements.\n        update_condition (Optional[UpdateOptions]): Options for updating scores.\n            - GT: Only update scores greater than the current values.\n            - LT: Only update scores less than the current values.\n        changed (bool): Modify the return value to return the number of changed elements, instead of the number of new elements added.\n\n    Returns:\n        int: The number of elements added to the sorted set.\n        If `changed` is set, returns the number of elements updated in the sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2})\n            2  # Indicates that two elements have been added to the sorted set \"my_sorted_set.\"\n        &gt;&gt;&gt; await client.zadd(\"existing_sorted_set\", {\"member1\": 15.0, \"member2\": 5.5}, existing_options=ConditionalChange.XX, changed=True)\n            2  # Updates the scores of two existing members in the sorted set \"existing_sorted_set.\"\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if update_condition:\n        args.append(update_condition.value)\n\n    if changed:\n        args.append(\"CH\")\n\n    if existing_options and update_condition:\n        if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n            raise ValueError(\n                \"The GT, LT and NX options are mutually exclusive. \"\n                f\"Cannot choose both {update_condition.value} and NX.\"\n            )\n\n    members_scores_list = [\n        str(item) for pair in members_scores.items() for item in pair[::-1]\n    ]\n    args += members_scores_list\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZAdd, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zadd_incr","title":"<code>zadd_incr(key, member, increment, existing_options=None, update_condition=None)</code>  <code>async</code>","text":"<p>Increments the score of member in the sorted set stored at <code>key</code> by <code>increment</code>. If <code>member</code> does not exist in the sorted set, it is added with <code>increment</code> as its score (as if its previous score was 0.0). If <code>key</code> does not exist, a new sorted set with the specified member as its sole member is created.</p> <p>See https://valkey.io/commands/zadd/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>A member in the sorted set to increment.</p> required <code>increment</code> <code>float</code> <p>The score to increment the member.</p> required <code>existing_options</code> <code>Optional[ConditionalChange]</code> <p>Options for handling the member's existence. - NX: Only increment a member that doesn't exist. - XX: Only increment an existing member.</p> <code>None</code> <code>update_condition</code> <code>Optional[UpdateOptions]</code> <p>Options for updating the score. - GT: Only increment the score of the member if the new score will be greater than the current score. - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The score of the member.</p> <code>Optional[float]</code> <p>If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n    5.0\n&gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zadd_incr(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n    increment: float,\n    existing_options: Optional[ConditionalChange] = None,\n    update_condition: Optional[UpdateOptions] = None,\n) -&gt; Optional[float]:\n    \"\"\"\n    Increments the score of member in the sorted set stored at `key` by `increment`.\n    If `member` does not exist in the sorted set, it is added with `increment` as its score (as if its previous score was 0.0).\n    If `key` does not exist, a new sorted set with the specified member as its sole member is created.\n\n    See https://valkey.io/commands/zadd/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): A member in the sorted set to increment.\n        increment (float): The score to increment the member.\n        existing_options (Optional[ConditionalChange]): Options for handling the member's existence.\n            - NX: Only increment a member that doesn't exist.\n            - XX: Only increment an existing member.\n        update_condition (Optional[UpdateOptions]): Options for updating the score.\n            - GT: Only increment the score of the member if the new score will be greater than the current score.\n            - LT: Only increment (decrement) the score of the member if the new score will be less than the current score.\n\n    Returns:\n        Optional[float]: The score of the member.\n        If there was a conflict with choosing the XX/NX/LT/GT options, the operation aborts and None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd_incr(\"my_sorted_set\", member , 5.0)\n            5.0\n        &gt;&gt;&gt; await client.zadd_incr(\"existing_sorted_set\", member , \"3.0\" , UpdateOptions.LESS_THAN)\n            None\n    \"\"\"\n    args = [key]\n    if existing_options:\n        args.append(existing_options.value)\n\n    if update_condition:\n        args.append(update_condition.value)\n\n    args.append(\"INCR\")\n\n    if existing_options and update_condition:\n        if existing_options == ConditionalChange.ONLY_IF_DOES_NOT_EXIST:\n            raise ValueError(\n                \"The GT, LT and NX options are mutually exclusive. \"\n                f\"Cannot choose both {update_condition.value} and NX.\"\n            )\n\n    args += [str(increment), member]\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.ZAdd, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zcard","title":"<code>zcard(key)</code>  <code>async</code>","text":"<p>Returns the cardinality (number of elements) of the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zcard/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted set.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n    3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n    0\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zcard(self, key: TEncodable) -&gt; int:\n    \"\"\"\n    Returns the cardinality (number of elements) of the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zcard/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n\n    Returns:\n        int: The number of elements in the sorted set.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.zcard(\"my_sorted_set\")\n            3  # Indicates that there are 3 elements in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zcard(\"non_existing_key\")\n            0\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.ZCard, [key]))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zcount","title":"<code>zcount(key, min_score, max_score)</code>  <code>async</code>","text":"<p>Returns the number of members in the sorted set stored at <code>key</code> with scores between <code>min_score</code> and <code>max_score</code>.</p> <p>See https://valkey.io/commands/zcount/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The minimum score to count from. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <code>max_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The maximum score to count up to. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the specified score range.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <code>int</code> <p>If <code>max_score</code> &lt; <code>min_score</code>, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n    2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n    1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zcount(\n    self,\n    key: TEncodable,\n    min_score: Union[InfBound, ScoreBoundary],\n    max_score: Union[InfBound, ScoreBoundary],\n) -&gt; int:\n    \"\"\"\n    Returns the number of members in the sorted set stored at `key` with scores between `min_score` and `max_score`.\n\n    See https://valkey.io/commands/zcount/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_score (Union[InfBound, ScoreBoundary]): The minimum score to count from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n        max_score (Union[InfBound, ScoreBoundary]): The maximum score to count up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n\n    Returns:\n        int: The number of members in the specified score range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n        If `max_score` &lt; `min_score`, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n            2  # Indicates that there are 2 members with scores between 5.0 (not exclusive) and +inf in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zcount(\"my_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n            1  # Indicates that there is one ScoreBoundary with 5.0 &lt; score &lt;= 10.0 in the sorted set \"my_sorted_set\".\n    \"\"\"\n    score_min = (\n        min_score.value[\"score_arg\"]\n        if type(min_score) == InfBound\n        else min_score.value\n    )\n    score_max = (\n        max_score.value[\"score_arg\"]\n        if type(max_score) == InfBound\n        else max_score.value\n    )\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZCount, [key, score_min, score_max]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zdiff","title":"<code>zdiff(keys)</code>  <code>async</code>","text":"<p>Returns the difference between the first sorted set and all the successive sorted sets. To get the elements with their scores, see <code>zdiff_withscores</code>.</p> <p>When in Cluster mode, all keys must map to the same hash slot.</p> <p>See https://valkey.io/commands/zdiff for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements representing the difference between the sorted sets. If the first key does not exist, it is treated as an empty sorted set, and the command returns an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n&gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n    [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiff(self, keys: List[TEncodable]) -&gt; List[bytes]:\n    \"\"\"\n    Returns the difference between the first sorted set and all the successive sorted sets.\n    To get the elements with their scores, see `zdiff_withscores`.\n\n    When in Cluster mode, all keys must map to the same hash slot.\n\n    See https://valkey.io/commands/zdiff for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: A list of elements representing the difference between the sorted sets.\n            If the first key does not exist, it is treated as an empty sorted set, and the command returns an\n            empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n        &gt;&gt;&gt; await client.zdiff(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n            [b\"element1\"]  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZDiff, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zdiff_withscores","title":"<code>zdiff_withscores(keys)</code>  <code>async</code>","text":"<p>Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores. When in Cluster mode, all keys must map to the same hash slot.</p> <p>See https://valkey.io/commands/zdiff for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted sets. If the first <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n&gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n&gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n    {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiff_withscores(self, keys: List[TEncodable]) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Returns the difference between the first sorted set and all the successive sorted sets, with the associated scores.\n    When in Cluster mode, all keys must map to the same hash slot.\n\n    See https://valkey.io/commands/zdiff for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        Mapping[bytes, float]: A mapping of elements and their scores representing the difference between the sorted\n            sets.\n            If the first `key` does not exist, it is treated as an empty sorted set, and the command returns an\n            empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"sorted_set1\", {\"element1\":1.0, \"element2\": 2.0, \"element3\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set2\", {\"element2\": 2.0})\n        &gt;&gt;&gt; await client.zadd(\"sorted_set3\", {\"element3\": 3.0})\n        &gt;&gt;&gt; await client.zdiff_withscores(\"sorted_set1\", \"sorted_set2\", \"sorted_set3\")\n            {b\"element1\": 1.0}  # Indicates that \"element1\" is in \"sorted_set1\" but not \"sorted_set2\" or \"sorted_set3\".\n    \"\"\"\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(\n            RequestType.ZDiff, [str(len(keys))] + keys + [\"WITHSCORES\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zdiffstore","title":"<code>zdiffstore(destination, keys)</code>  <code>async</code>","text":"<p>Calculates the difference between the first sorted set and all the successive sorted sets at <code>keys</code> and stores the difference as a sorted set to <code>destination</code>, overwriting it if it already exists. Non-existent keys are treated as empty sets. See https://valkey.io/commands/zdiffstore for more details.</p> Note <p>When in Cluster mode, all keys in <code>keys</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key for the resulting sorted set.</p> required <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n    2  # Indicates that two elements have been added to the sorted set at \"key1\".\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n    1  # Indicates that one element has been added to the sorted set at \"key2\".\n&gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n    ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zdiffstore(self, destination: TEncodable, keys: List[TEncodable]) -&gt; int:\n    \"\"\"\n    Calculates the difference between the first sorted set and all the successive sorted sets at `keys` and stores\n    the difference as a sorted set to `destination`, overwriting it if it already exists. Non-existent keys are\n    treated as empty sets.\n    See https://valkey.io/commands/zdiffstore for more details.\n\n    Note:\n        When in Cluster mode, all keys in `keys` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key for the resulting sorted set.\n        keys (List[TEncodable]): The keys of the sorted sets to compare.\n\n    Returns:\n        int: The number of members in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n            2  # Indicates that two elements have been added to the sorted set at \"key1\".\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5})\n            1  # Indicates that one element has been added to the sorted set at \"key2\".\n        &gt;&gt;&gt; await client.zdiffstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            1  # One member exists in \"key1\" but not \"key2\", and this member was stored in \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n            ['member2']  # \"member2\" is now stored in \"my_sorted_set\"\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZDiffStore, [destination, str(len(keys))] + keys\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zincrby","title":"<code>zincrby(key, increment, member)</code>  <code>async</code>","text":"<p>Increments the score of <code>member</code> in the sorted set stored at <code>key</code> by <code>increment</code>. If <code>member</code> does not exist in the sorted set, it is added with <code>increment</code> as its score. If <code>key</code> does not exist, a new sorted set is created with the specified member as its sole member.</p> <p>See https://valkey.io/commands/zincrby/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>increment</code> <code>float</code> <p>The score increment.</p> required <code>member</code> <code>TEncodable</code> <p>A member of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The new score of <code>member</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n    11.7  # The member existed in the set before score was altered, the new score is 11.7.\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n    10.0 # Negative increment, decrements the score.\n&gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n    5.5  # A new member is added to the sorted set with the score being 5.5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zincrby(\n    self, key: TEncodable, increment: float, member: TEncodable\n) -&gt; float:\n    \"\"\"\n    Increments the score of `member` in the sorted set stored at `key` by `increment`.\n    If `member` does not exist in the sorted set, it is added with `increment` as its score.\n    If `key` does not exist, a new sorted set is created with the specified member as its sole member.\n\n    See https://valkey.io/commands/zincrby/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        increment (float): The score increment.\n        member (TEncodable): A member of the sorted set.\n\n    Returns:\n        float: The new score of `member`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 1.2, \"member\")\n            11.7  # The member existed in the set before score was altered, the new score is 11.7.\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", -1.7, \"member\")\n            10.0 # Negative increment, decrements the score.\n        &gt;&gt;&gt; await client.zincrby(\"my_sorted_set\", 5.5, \"non_existing_member\")\n            5.5  # A new member is added to the sorted set with the score being 5.5.\n    \"\"\"\n    return cast(\n        float,\n        await self._execute_command(\n            RequestType.ZIncrBy, [key, str(increment), member]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zinter","title":"<code>zinter(keys)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and returns a list of intersecting elements. To get the scores as well, see <code>zinter_withscores</code>. To store the result in a key as a sorted set, see <code>zinterstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinter/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: The resulting array of intersecting elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n    [b'member1']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinter(\n    self,\n    keys: List[TEncodable],\n) -&gt; List[bytes]:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and returns a list of intersecting elements.\n    To get the scores as well, see `zinter_withscores`.\n    To store the result in a key as a sorted set, see `zinterstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinter/ for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: The resulting array of intersecting elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinter([\"key1\", \"key2\"])\n            [b'member1']\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZInter, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zinter_withscores","title":"<code>zinter_withscores(keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and returns a sorted set of intersecting elements with scores. To get the elements only, see <code>zinter</code>. To store the result in a key as a sorted set, see <code>zinterstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinter/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: The resulting sorted set with scores.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n    {b'member1': 20}  # \"member1\" with score of 20 is the result\n&gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n    {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinter_withscores(\n    self,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and returns a sorted set of intersecting elements with scores.\n    To get the elements only, see `zinter`.\n    To store the result in a key as a sorted set, see `zinterstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinter/ for more details.\n\n    Args:\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        Mapping[bytes, float]: The resulting sorted set with scores.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"])\n            {b'member1': 20}  # \"member1\" with score of 20 is the result\n        &gt;&gt;&gt; await client.zinter_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n            {b'member1': 10.5}  # \"member1\" with score of 10.5 is the result.\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n    args.append(\"WITHSCORES\")\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZInter, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zintercard","title":"<code>zintercard(keys, limit=None)</code>  <code>async</code>","text":"<p>Returns the cardinality of the intersection of the sorted sets specified by <code>keys</code>. When provided with the optional <code>limit</code> argument, if the intersection cardinality reaches <code>limit</code> partway through the computation, the algorithm will exit early and yield <code>limit</code> as the cardinality.</p> <p>See https://valkey.io/commands/zintercard for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets to intersect.</p> required <code>limit</code> <code>Optional[int]</code> <p>An optional argument that can be used to specify a maximum number for the intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.</p> <code>None</code> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The cardinality of the intersection of the given sorted sets, or the <code>limit</code> if reached.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n&gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n    2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n&gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n    1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zintercard(\n    self, keys: List[TEncodable], limit: Optional[int] = None\n) -&gt; int:\n    \"\"\"\n    Returns the cardinality of the intersection of the sorted sets specified by `keys`. When provided with the\n    optional `limit` argument, if the intersection cardinality reaches `limit` partway through the computation, the\n    algorithm will exit early and yield `limit` as the cardinality.\n\n    See https://valkey.io/commands/zintercard for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets to intersect.\n        limit (Optional[int]): An optional argument that can be used to specify a maximum number for the\n            intersection cardinality. If limit is not supplied, or if it is set to 0, there will be no limit.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Returns:\n        int: The cardinality of the intersection of the given sorted sets, or the `limit` if reached.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 10.5, \"member2\": 3.5})\n        &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"])\n            2  # Indicates that the intersection of the sorted sets at \"key1\" and \"key2\" has a cardinality of 2.\n        &gt;&gt;&gt; await client.zintercard([\"key1\", \"key2\"], 1)\n            1  # A `limit` of 1 was provided, so the intersection computation exits early and yields the `limit` value of 1.\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args = [str(len(keys))] + keys\n    if limit is not None:\n        args.extend([\"LIMIT\", str(limit)])\n\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZInterCard, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zinterstore","title":"<code>zinterstore(destination, keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the intersection of sorted sets given by the specified <code>keys</code> and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created. To get the result directly, see <code>zinter_withscores</code>.</p> <p>When in cluster mode, <code>destination</code> and all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zinterstore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination sorted set.</p> required <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n&gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n    1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zinterstore(\n    self,\n    destination: TEncodable,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; int:\n    \"\"\"\n    Computes the intersection of sorted sets given by the specified `keys` and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n    To get the result directly, see `zinter_withscores`.\n\n    When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zinterstore/ for more details.\n\n    Args:\n        destination (TEncodable): The key of the destination sorted set.\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            1 # Indicates that the sorted set \"my_sorted_set\" contains one element.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 20}  # \"member1\" is now stored in \"my_sorted_set\" with score of 20.\n        &gt;&gt;&gt; await client.zinterstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n            1 # Indicates that the sorted set \"my_sorted_set\" contains one element, and its score is the maximum score between the sets.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 10.5}  # \"member1\" is now stored in \"my_sorted_set\" with score of 10.5.\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZInterStore, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zlexcount","title":"<code>zlexcount(key, min_lex, max_lex)</code>  <code>async</code>","text":"<p>Returns the number of members in the sorted set stored at <code>key</code> with lexicographical values between <code>min_lex</code> and <code>max_lex</code>.</p> <p>See https://valkey.io/commands/zlexcount/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The minimum lexicographical value to count from. Can be an instance of InfBound representing positive/negative infinity, or LexBoundary representing a specific lexicographical value and inclusivity.</p> required <code>max_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The maximum lexicographical to count up to. Can be an instance of InfBound representing positive/negative infinity, or LexBoundary representing a specific lexicographical value and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members in the specified lexicographical range. If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns <code>0</code>. If <code>max_lex &lt; min_lex</code>, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n    2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n    1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zlexcount(\n    self,\n    key: TEncodable,\n    min_lex: Union[InfBound, LexBoundary],\n    max_lex: Union[InfBound, LexBoundary],\n) -&gt; int:\n    \"\"\"\n    Returns the number of members in the sorted set stored at `key` with lexicographical values between `min_lex` and `max_lex`.\n\n    See https://valkey.io/commands/zlexcount/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_lex (Union[InfBound, LexBoundary]): The minimum lexicographical value to count from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or LexBoundary representing a specific lexicographical value and inclusivity.\n        max_lex (Union[InfBound, LexBoundary]): The maximum lexicographical to count up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or LexBoundary representing a specific lexicographical value and inclusivity.\n\n    Returns:\n        int: The number of members in the specified lexicographical range.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n            If `max_lex &lt; min_lex`, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\",  LexBoundary(\"c\" , is_inclusive=True), InfBound.POS_INF)\n            2  # Indicates that there are 2 members with lexicographical values between \"c\" (inclusive) and positive infinity in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zlexcount(\"my_sorted_set\", LexBoundary(\"c\" , is_inclusive=True), LexBoundary(\"k\" , is_inclusive=False))\n            1  # Indicates that there is one member with LexBoundary \"c\" &lt;= lexicographical value &lt; \"k\" in the sorted set \"my_sorted_set\".\n    \"\"\"\n    min_lex_arg = (\n        min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n    )\n    max_lex_arg = (\n        max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZLexCount, [key, min_lex_arg, max_lex_arg]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zmpop","title":"<code>zmpop(keys, filter, count=None)</code>  <code>async</code>","text":"<p>Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order that they are given.</p> <p>The optional <code>count</code> argument can be used to specify the number of elements to pop, and is set to 1 by default.</p> <p>The number of popped elements is the minimum from the sorted set's cardinality and <code>count</code>.</p> <p>See https://valkey.io/commands/zmpop for more details.</p> Note <p>When in cluster mode, all <code>keys</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <code>filter</code> <code>ScoreFilter</code> <p>The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop members with the lowest/highest scores accordingly.</p> required <code>count</code> <code>Optional[int]</code> <p>The number of elements to pop.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[List[Union[bytes, Mapping[bytes, float]]]]</code> <p>Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from which elements were popped, and a member-score mapping of the popped elements. If no members could be popped, returns None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n&gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n&gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n    [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zmpop(\n    self,\n    keys: List[TEncodable],\n    filter: ScoreFilter,\n    count: Optional[int] = None,\n) -&gt; Optional[List[Union[bytes, Mapping[bytes, float]]]]:\n    \"\"\"\n    Pops a member-score pair from the first non-empty sorted set, with the given keys being checked in the order\n    that they are given.\n\n    The optional `count` argument can be used to specify the number of elements to pop, and is\n    set to 1 by default.\n\n    The number of popped elements is the minimum from the sorted set's cardinality and `count`.\n\n    See https://valkey.io/commands/zmpop for more details.\n\n    Note:\n        When in cluster mode, all `keys` must map to the same hash slot.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n        filter (ScoreFilter): The element pop criteria - either ScoreFilter.MIN or ScoreFilter.MAX to pop\n            members with the lowest/highest scores accordingly.\n        count (Optional[int]): The number of elements to pop.\n\n    Returns:\n        Optional[List[Union[bytes, Mapping[bytes, float]]]]: A two-element list containing the key name of the set from\n            which elements were popped, and a member-score mapping of the popped elements. If no members could be\n            popped, returns None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"zSet1\", {\"one\": 1.0, \"two\": 2.0, \"three\": 3.0})\n        &gt;&gt;&gt; await client.zadd(\"zSet2\", {\"four\": 4.0})\n        &gt;&gt;&gt; await client.zmpop([\"zSet1\", \"zSet2\"], ScoreFilter.MAX, 2)\n            [b'zSet1', {b'three': 3.0, b'two': 2.0}]  # \"three\" with score 3.0 and \"two\" with score 2.0 were popped from \"zSet1\".\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))] + keys + [filter.value]\n    if count is not None:\n        args.extend([\"COUNT\", str(count)])\n\n    return cast(\n        Optional[List[Union[bytes, Mapping[bytes, float]]]],\n        await self._execute_command(RequestType.ZMPop, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zmscore","title":"<code>zmscore(key, members)</code>  <code>async</code>","text":"<p>Returns the scores associated with the specified <code>members</code> in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zmscore for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members in the sorted set.</p> required <p>Returns:</p> Type Description <code>List[Optional[float]]</code> <p>List[Optional[float]]: A list of scores corresponding to <code>members</code>. If a member does not exist in the sorted set, the corresponding value in the list will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n    [1.0, None, 3.0]\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zmscore(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; List[Optional[float]]:\n    \"\"\"\n    Returns the scores associated with the specified `members` in the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zmscore for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): A list of members in the sorted set.\n\n    Returns:\n        List[Optional[float]]: A list of scores corresponding to `members`.\n            If a member does not exist in the sorted set, the corresponding value in the list will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zmscore(\"my_sorted_set\", [\"one\", \"non_existent_member\", \"three\"])\n            [1.0, None, 3.0]\n    \"\"\"\n    return cast(\n        List[Optional[float]],\n        await self._execute_command(RequestType.ZMScore, [key] + members),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zpopmax","title":"<code>zpopmax(key, count=None)</code>  <code>async</code>","text":"<p>Removes and returns the members with the highest scores from the sorted set stored at <code>key</code>. If <code>count</code> is provided, up to <code>count</code> members with the highest scores are removed and returned. Otherwise, only one member with the highest score is removed and returned.</p> <p>See https://valkey.io/commands/zpopmax for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>Optional[int]</code> <p>Specifies the quantity of members to pop. If not specified, pops one member.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n    {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n&gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n    {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zpopmax(\n    self, key: TEncodable, count: Optional[int] = None\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Removes and returns the members with the highest scores from the sorted set stored at `key`.\n    If `count` is provided, up to `count` members with the highest scores are removed and returned.\n    Otherwise, only one member with the highest score is removed and returned.\n\n    See https://valkey.io/commands/zpopmax for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n        If `count` is higher than the sorted set's cardinality, returns all members and their scores, ordered from highest to lowest.\n\n    Returns:\n        Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the highest score to the one with the lowest.\n        If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\")\n            {b'member1': 10.0}  # Indicates that 'member1' with a score of 10.0 has been removed from the sorted set.\n        &gt;&gt;&gt; await client.zpopmax(\"my_sorted_set\", 2)\n            {b'member2': 8.0, b'member3': 7.5}  # Indicates that 'member2' with a score of 8.0 and 'member3' with a score of 7.5 have been removed from the sorted set.\n    \"\"\"\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(\n            RequestType.ZPopMax, [key, str(count)] if count else [key]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zpopmin","title":"<code>zpopmin(key, count=None)</code>  <code>async</code>","text":"<p>Removes and returns the members with the lowest scores from the sorted set stored at <code>key</code>. If <code>count</code> is provided, up to <code>count</code> members with the lowest scores are removed and returned. Otherwise, only one member with the lowest score is removed and returned.</p> <p>See https://valkey.io/commands/zpopmin for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>Optional[int]</code> <p>Specifies the quantity of members to pop. If not specified, pops one member.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n    {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n&gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n    {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zpopmin(\n    self, key: TEncodable, count: Optional[int] = None\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Removes and returns the members with the lowest scores from the sorted set stored at `key`.\n    If `count` is provided, up to `count` members with the lowest scores are removed and returned.\n    Otherwise, only one member with the lowest score is removed and returned.\n\n    See https://valkey.io/commands/zpopmin for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (Optional[int]): Specifies the quantity of members to pop. If not specified, pops one member.\n        If `count` is higher than the sorted set's cardinality, returns all members and their scores.\n\n    Returns:\n        Mapping[bytes, float]: A map of the removed members and their scores, ordered from the one with the lowest score to the one with the highest.\n        If `key` doesn't exist, it will be treated as an empy sorted set and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\")\n            {b'member1': 5.0}  # Indicates that 'member1' with a score of 5.0 has been removed from the sorted set.\n        &gt;&gt;&gt; await client.zpopmin(\"my_sorted_set\", 2)\n            {b'member3': 7.5 , b'member2': 8.0}  # Indicates that 'member3' with a score of 7.5 and 'member2' with a score of 8.0 have been removed from the sorted set.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count)] if count else [key]\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZPopMin, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrandmember","title":"<code>zrandmember(key)</code>  <code>async</code>","text":"<p>Returns a random member from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random member from the sorted set. If the sorted set does not exist or is empty, the response will be None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n    b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n    None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember(self, key: TEncodable) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random member from the sorted set stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n\n    Returns:\n        Optional[bytes]: A random member from the sorted set.\n            If the sorted set does not exist or is empty, the response will be None.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\")\n            b\"member1\"  # \"member1\" is a random member of \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\")\n            None  # \"non_existing_sorted_set\" is not an existing key, so None was returned.\n    \"\"\"\n    args: List[TEncodable] = [key]\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.ZRandMember, [key]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrandmember_count","title":"<code>zrandmember_count(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to the absolute value of <code>count</code> random members from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of members from the sorted set. If the sorted set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n    [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n    []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember_count(self, key: TEncodable, count: int) -&gt; List[bytes]:\n    \"\"\"\n    Retrieves up to the absolute value of `count` random members from the sorted set stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[bytes]: A list of members from the sorted set.\n            If the sorted set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember(\"my_sorted_set\", -3)\n            [b\"member1\", b\"member1\", b\"member2\"]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrandmember(\"non_existing_sorted_set\", 3)\n            []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count)]\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZRandMember, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrandmember_withscores","title":"<code>zrandmember_withscores(key, count)</code>  <code>async</code>","text":"<p>Retrieves up to the absolute value of <code>count</code> random members along with their scores from the sorted set stored at 'key'.</p> <p>See https://valkey.io/commands/zrandmember for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>The number of members to return. If <code>count</code> is positive, returns unique members. If <code>count</code> is negative, allows for duplicates members.</p> required <p>Returns:</p> Type Description <code>List[List[Union[bytes, float]]]</code> <p>List[List[Union[bytes, float]]]: A list of <code>[member, score]</code> lists, where <code>member</code> is a random member from the sorted set and <code>score</code> is the associated score. If the sorted set does not exist or is empty, the response will be an empty list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n&gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n    [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n&gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n    []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrandmember_withscores(\n    self, key: TEncodable, count: int\n) -&gt; List[List[Union[bytes, float]]]:\n    \"\"\"\n    Retrieves up to the absolute value of `count` random members along with their scores from the sorted set\n    stored at 'key'.\n\n    See https://valkey.io/commands/zrandmember for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        count (int): The number of members to return.\n            If `count` is positive, returns unique members.\n            If `count` is negative, allows for duplicates members.\n\n    Returns:\n        List[List[Union[bytes, float]]]: A list of `[member, score]` lists, where `member` is a random member from\n            the sorted set and `score` is the associated score.\n            If the sorted set does not exist or is empty, the response will be an empty list.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 1.0, \"member2\": 2.0})\n        &gt;&gt;&gt; await client.zrandmember_withscores(\"my_sorted_set\", -3)\n            [[b\"member1\", 1.0], [b\"member1\", 1.0], [b\"member2\", 2.0]]  # \"member1\" and \"member2\" are random members of \"my_sorted_set\", and have scores of 1.0 and 2.0, respectively.\n        &gt;&gt;&gt; await client.zrandmember_withscores(\"non_existing_sorted_set\", 3)\n            []  # \"non_existing_sorted_set\" is not an existing key, so an empty list was returned.\n    \"\"\"\n    args: List[TEncodable] = [key, str(count), \"WITHSCORES\"]\n    return cast(\n        List[List[Union[bytes, float]]],\n        await self._execute_command(RequestType.ZRandMember, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrange","title":"<code>zrange(key, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Returns the specified range of elements in the sorted set stored at <code>key</code>.</p> <p>ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.</p> <p>See https://valkey.io/commands/zrange/ for more details.</p> <p>To get the elements with their scores, see zrange_withscores.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByLex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by lexicographical order, use RangeByLex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: A list of elements within the specified range.</p> <code>List[bytes]</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n    [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n&gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n    [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrange(\n    self,\n    key: TEncodable,\n    range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n    reverse: bool = False,\n) -&gt; List[bytes]:\n    \"\"\"\n    Returns the specified range of elements in the sorted set stored at `key`.\n\n    ZRANGE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.\n\n    See https://valkey.io/commands/zrange/ for more details.\n\n    To get the elements with their scores, see zrange_withscores.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by lexicographical order, use RangeByLex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        List[bytes]: A list of elements within the specified range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty array.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByIndex(0, -1))\n            [b'member1', b'member2', b'member3']  # Returns all members in ascending order.\n        &gt;&gt;&gt; await client.zrange(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            [b'member2', b'member3'] # Returns members with scores within the range of negative infinity to 3, in ascending order.\n    \"\"\"\n    args = _create_zrange_args(key, range_query, reverse, with_scores=False)\n\n    return cast(List[bytes], await self._execute_command(RequestType.ZRange, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrange_withscores","title":"<code>zrange_withscores(key, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Returns the specified range of elements with their scores in the sorted set stored at <code>key</code>. Similar to ZRANGE but with a WITHSCORE flag.</p> <p>See https://valkey.io/commands/zrange/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes , float]: A map of elements and their scores within the specified range.</p> <code>Mapping[bytes, float]</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns an empty map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n    {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n</code></pre> <p>await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))         {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrange_withscores(\n    self,\n    key: TEncodable,\n    range_query: Union[RangeByIndex, RangeByScore],\n    reverse: bool = False,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Returns the specified range of elements with their scores in the sorted set stored at `key`.\n    Similar to ZRANGE but with a WITHSCORE flag.\n\n    See https://valkey.io/commands/zrange/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        range_query (Union[RangeByIndex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        Mapping[bytes , float]: A map of elements and their scores within the specified range.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns an empty map.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(ScoreBoundary(10), ScoreBoundary(20)))\n            {b'member1': 10.5, b'member2': 15.2}  # Returns members with scores between 10 and 20 with their scores.\n       &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            {b'member4': -2.0, b'member7': 1.5} # Returns members with with scores within the range of negative infinity to 3, with their scores.\n    \"\"\"\n    args = _create_zrange_args(key, range_query, reverse, with_scores=True)\n\n    return cast(\n        Mapping[bytes, float], await self._execute_command(RequestType.ZRange, args)\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrangestore","title":"<code>zrangestore(destination, source, range_query, reverse=False)</code>  <code>async</code>","text":"<p>Stores a specified range of elements from the sorted set at <code>source</code>, into a new sorted set at <code>destination</code>. If <code>destination</code> doesn't exist, a new sorted set is created; if it exists, it's overwritten.</p> <p>ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical order.</p> <p>See https://valkey.io/commands/zrangestore for more details.</p> Note <p>When in Cluster mode, <code>source</code> and <code>destination</code> must map to the same hash slot.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key for the destination sorted set.</p> required <code>source</code> <code>TEncodable</code> <p>The key of the source sorted set.</p> required <code>range_query</code> <code>Union[RangeByIndex, RangeByLex, RangeByScore]</code> <p>The range query object representing the type of range query to perform. - For range queries by index (rank), use RangeByIndex. - For range queries by lexicographical order, use RangeByLex. - For range queries by score, use RangeByScore.</p> required <code>reverse</code> <code>bool</code> <p>If True, reverses the sorted set, with index 0 as the element with the highest score.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n    3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n&gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n    2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrangestore(\n    self,\n    destination: TEncodable,\n    source: TEncodable,\n    range_query: Union[RangeByIndex, RangeByLex, RangeByScore],\n    reverse: bool = False,\n) -&gt; int:\n    \"\"\"\n    Stores a specified range of elements from the sorted set at `source`, into a new sorted set at `destination`. If\n    `destination` doesn't exist, a new sorted set is created; if it exists, it's overwritten.\n\n    ZRANGESTORE can perform different types of range queries: by index (rank), by the score, or by lexicographical\n    order.\n\n    See https://valkey.io/commands/zrangestore for more details.\n\n    Note:\n        When in Cluster mode, `source` and `destination` must map to the same hash slot.\n\n    Args:\n        destination (TEncodable): The key for the destination sorted set.\n        source (TEncodable): The key of the source sorted set.\n        range_query (Union[RangeByIndex, RangeByLex, RangeByScore]): The range query object representing the type of range query to perform.\n            - For range queries by index (rank), use RangeByIndex.\n            - For range queries by lexicographical order, use RangeByLex.\n            - For range queries by score, use RangeByScore.\n        reverse (bool): If True, reverses the sorted set, with index 0 as the element with the highest score.\n\n    Returns:\n        int: The number of elements in the resulting sorted set.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByIndex(0, 2), True)\n            3  # The 3 members with the highest scores from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n        &gt;&gt;&gt; await client.zrangestore(\"destination_key\", \"my_sorted_set\", RangeByScore(InfBound.NEG_INF, ScoreBoundary(3)))\n            2  # The 2 members with scores between negative infinity and 3 (inclusive) from \"my_sorted_set\" were stored in the sorted set at \"destination_key\".\n    \"\"\"\n    args = _create_zrange_args(source, range_query, reverse, False, destination)\n\n    return cast(int, await self._execute_command(RequestType.ZRangeStore, args))\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrank","title":"<code>zrank(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code>, with scores ordered from low to high.</p> <p>See https://valkey.io/commands/zrank for more details.</p> <p>To get the rank of <code>member</code> with its score, see <code>zrank_withscore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>Optional[int]</code> <p>Optional[int]: The rank of <code>member</code> in the sorted set.</p> <code>Optional[int]</code> <p>If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, None will be returned.</p> <code>Examples</code> <code>Optional[int]</code> <code>Optional[int]</code> <p>await client.zrank(\"my_sorted_set\", \"member2\") 1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".</p> <code>Optional[int]</code> <p>await client.zrank(\"my_sorted_set\", \"non_existing_member\") None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrank(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; Optional[int]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key`, with scores ordered from low to high.\n\n    See https://valkey.io/commands/zrank for more details.\n\n    To get the rank of `member` with its score, see `zrank_withscore`.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[int]: The rank of `member` in the sorted set.\n        If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n        Examples:\n        &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"member2\")\n            1  # Indicates that \"member2\" has the second-lowest score in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrank(\"my_sorted_set\", \"non_existing_member\")\n            None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n    \"\"\"\n    return cast(\n        Optional[int], await self._execute_command(RequestType.ZRank, [key, member])\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrank_withscore","title":"<code>zrank_withscore(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code> with its score, where scores are ordered from the lowest to highest.</p> <p>See https://valkey.io/commands/zrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[int, float]]]</code> <p>Optional[List[Union[int, float]]]: A list containing the rank and score of <code>member</code> in the sorted set.</p> <code>Optional[List[Union[int, float]]]</code> <p>If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, None will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n    [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n    None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n</code></pre> <p>Since: Valkey version 7.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrank_withscore(\n    self,\n    key: TEncodable,\n    member: TEncodable,\n) -&gt; Optional[List[Union[int, float]]]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the lowest to highest.\n\n    See https://valkey.io/commands/zrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[List[Union[int, float]]]: A list containing the rank and score of `member` in the sorted set.\n        If `key` doesn't exist, or if `member` is not present in the set, None will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"member2\")\n            [1 , 6.0]  # Indicates that \"member2\" with score 6.0 has the second-lowest score in the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zrank_withscore(\"my_sorted_set\", \"non_existing_member\")\n            None  # Indicates that \"non_existing_member\" is not present in the sorted set \"my_sorted_set\".\n\n    Since: Valkey version 7.2.0.\n    \"\"\"\n    return cast(\n        Optional[List[Union[int, float]]],\n        await self._execute_command(RequestType.ZRank, [key, member, \"WITHSCORE\"]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrem","title":"<code>zrem(key, members)</code>  <code>async</code>","text":"<p>Removes the specified members from the sorted set stored at <code>key</code>. Specified members that are not a member of this set are ignored.</p> <p>See https://valkey.io/commands/zrem/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>members</code> <code>List[TEncodable]</code> <p>A list of members to remove from the sorted set.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the sorted set, not including non-existing members.</p> <code>int</code> <p>If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n    2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n&gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrem(\n    self,\n    key: TEncodable,\n    members: List[TEncodable],\n) -&gt; int:\n    \"\"\"\n    Removes the specified members from the sorted set stored at `key`.\n    Specified members that are not a member of this set are ignored.\n\n    See https://valkey.io/commands/zrem/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        members (List[TEncodable]): A list of members to remove from the sorted set.\n\n    Returns:\n        int: The number of members that were removed from the sorted set, not including non-existing members.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n\n    Examples:\n        &gt;&gt;&gt; await client.zrem(\"my_sorted_set\", [\"member1\", \"member2\"])\n            2  # Indicates that two members have been removed from the sorted set \"my_sorted_set.\"\n        &gt;&gt;&gt; await client.zrem(\"non_existing_sorted_set\", [\"member1\", \"member2\"])\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZRem, [key] + members),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zremrangebylex","title":"<code>zremrangebylex(key, min_lex, max_lex)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with a lexicographical order between <code>min_lex</code> and <code>max_lex</code>.</p> <p>See https://valkey.io/commands/zremrangebylex/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The minimum bound of the lexicographical range. Can be an instance of <code>InfBound</code> representing positive/negative infinity, or <code>LexBoundary</code> representing a specific lex and inclusivity.</p> required <code>max_lex</code> <code>Union[InfBound, LexBoundary]</code> <p>The maximum bound of the lexicographical range. Can be an instance of <code>InfBound</code> representing positive/negative infinity, or <code>LexBoundary</code> representing a specific lex and inclusivity.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of members that were removed from the sorted set. If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns <code>0</code>. If <code>min_lex</code> is greater than <code>max_lex</code>, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n    4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebylex(\n    self,\n    key: TEncodable,\n    min_lex: Union[InfBound, LexBoundary],\n    max_lex: Union[InfBound, LexBoundary],\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with a lexicographical order between `min_lex` and\n    `max_lex`.\n\n    See https://valkey.io/commands/zremrangebylex/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_lex (Union[InfBound, LexBoundary]): The minimum bound of the lexicographical range.\n            Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n            representing a specific lex and inclusivity.\n        max_lex (Union[InfBound, LexBoundary]): The maximum bound of the lexicographical range.\n            Can be an instance of `InfBound` representing positive/negative infinity, or `LexBoundary`\n            representing a specific lex and inclusivity.\n\n    Returns:\n        int: The number of members that were removed from the sorted set.\n            If `key` does not exist, it is treated as an empty sorted set, and the command returns `0`.\n            If `min_lex` is greater than `max_lex`, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebylex(\"my_sorted_set\",  LexBoundary(\"a\", is_inclusive=False), LexBoundary(\"e\"))\n            4  # Indicates that 4 members, with lexicographical values ranging from \"a\" (exclusive) to \"e\" (inclusive), have been removed from \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebylex(\"non_existing_sorted_set\", InfBound.NEG_INF, LexBoundary(\"e\"))\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    min_lex_arg = (\n        min_lex.value[\"lex_arg\"] if type(min_lex) == InfBound else min_lex.value\n    )\n    max_lex_arg = (\n        max_lex.value[\"lex_arg\"] if type(max_lex) == InfBound else max_lex.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByLex, [key, min_lex_arg, max_lex_arg]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zremrangebyrank","title":"<code>zremrangebyrank(key, start, end)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with rank between <code>start</code> and <code>end</code>. Both <code>start</code> and <code>end</code> are zero-based indexes with 0 being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.</p> <p>See https://valkey.io/commands/zremrangebyrank/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting point of the range.</p> required <code>end</code> <code>int</code> <p>The end of the range.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements that were removed. If <code>start</code> exceeds the end of the sorted set, or if <code>start</code> is greater than <code>end</code>, <code>0</code> is returned. If <code>end</code> exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set. If <code>key</code> does not exist, <code>0</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n    5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n    0  # Indicates that nothing was removed.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebyrank(\n    self,\n    key: TEncodable,\n    start: int,\n    end: int,\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with rank between `start` and `end`.\n    Both `start` and `end` are zero-based indexes with 0 being the element with the lowest score.\n    These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score.\n\n    See https://valkey.io/commands/zremrangebyrank/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        start (int): The starting point of the range.\n        end (int): The end of the range.\n\n    Returns:\n        int: The number of elements that were removed.\n            If `start` exceeds the end of the sorted set, or if `start` is greater than `end`, `0` is returned.\n            If `end` exceeds the actual end of the sorted set, the range will stop at the actual end of the sorted set.\n            If `key` does not exist, `0` is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n            5  # Indicates that 5 elements, with ranks ranging from 0 to 4 (inclusive), have been removed from \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebyrank(\"my_sorted_set\", 0, 4)\n            0  # Indicates that nothing was removed.\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByRank, [key, str(start), str(end)]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zremrangebyscore","title":"<code>zremrangebyscore(key, min_score, max_score)</code>  <code>async</code>","text":"<p>Removes all elements in the sorted set stored at <code>key</code> with a score between <code>min_score</code> and <code>max_score</code>.</p> <p>See https://valkey.io/commands/zremrangebyscore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>min_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The minimum score to remove from. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <code>max_score</code> <code>Union[InfBound, ScoreBoundary]</code> <p>The maximum score to remove up to. Can be an instance of InfBound representing positive/negative infinity, or ScoreBoundary representing a specific score and inclusivity.</p> required <p>Returns:     int: The number of members that were removed from the sorted set.     If <code>key</code> does not exist, it is treated as an empty sorted set, and the command returns 0.     If <code>min_score</code> is greater than <code>max_score</code>, 0 is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n    2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n&gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n    0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zremrangebyscore(\n    self,\n    key: TEncodable,\n    min_score: Union[InfBound, ScoreBoundary],\n    max_score: Union[InfBound, ScoreBoundary],\n) -&gt; int:\n    \"\"\"\n    Removes all elements in the sorted set stored at `key` with a score between `min_score` and `max_score`.\n\n    See https://valkey.io/commands/zremrangebyscore/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        min_score (Union[InfBound, ScoreBoundary]): The minimum score to remove from.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n        max_score (Union[InfBound, ScoreBoundary]): The maximum score to remove up to.\n            Can be an instance of InfBound representing positive/negative infinity,\n            or ScoreBoundary representing a specific score and inclusivity.\n    Returns:\n        int: The number of members that were removed from the sorted set.\n        If `key` does not exist, it is treated as an empty sorted set, and the command returns 0.\n        If `min_score` is greater than `max_score`, 0 is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zremrangebyscore(\"my_sorted_set\",  ScoreBoundary(5.0 , is_inclusive=true) , InfBound.POS_INF)\n            2  # Indicates that  2 members with scores between 5.0 (not exclusive) and +inf have been removed from the sorted set \"my_sorted_set\".\n        &gt;&gt;&gt; await client.zremrangebyscore(\"non_existing_sorted_set\", ScoreBoundary(5.0 , is_inclusive=true) , ScoreBoundary(10.0 , is_inclusive=false))\n            0  # Indicates that no members were removed as the sorted set \"non_existing_sorted_set\" does not exist.\n    \"\"\"\n    score_min = (\n        min_score.value[\"score_arg\"]\n        if type(min_score) == InfBound\n        else min_score.value\n    )\n    score_max = (\n        max_score.value[\"score_arg\"]\n        if type(max_score) == InfBound\n        else max_score.value\n    )\n\n    return cast(\n        int,\n        await self._execute_command(\n            RequestType.ZRemRangeByScore, [key, score_min, score_max]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrevrank","title":"<code>zrevrank(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code>, where scores are ordered from the highest to lowest, starting from <code>0</code>.</p> <p>To get the rank of <code>member</code> with its score, see <code>zrevrank_withscore</code>.</p> <p>See https://valkey.io/commands/zrevrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The rank of <code>member</code> in the sorted set, where ranks are ordered from high to low based on scores. If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n    2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrevrank(self, key: TEncodable, member: TEncodable) -&gt; Optional[int]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key`, where scores are ordered from the highest to\n    lowest, starting from `0`.\n\n    To get the rank of `member` with its score, see `zrevrank_withscore`.\n\n    See https://valkey.io/commands/zrevrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[int]: The rank of `member` in the sorted set, where ranks are ordered from high to low based on scores.\n            If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n            2  # \"member2\" has the third-highest score in the sorted set \"my_sorted_set\"\n    \"\"\"\n    return cast(\n        Optional[int],\n        await self._execute_command(RequestType.ZRevRank, [key, member]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zrevrank_withscore","title":"<code>zrevrank_withscore(key, member)</code>  <code>async</code>","text":"<p>Returns the rank of <code>member</code> in the sorted set stored at <code>key</code> with its score, where scores are ordered from the highest to lowest, starting from <code>0</code>.</p> <p>See https://valkey.io/commands/zrevrank for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose rank is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[List[Union[int, float]]]</code> <p>Optional[List[Union[int, float]]]: A list containing the rank (as <code>int</code>) and score (as <code>float</code>) of <code>member</code> in the sorted set, where ranks are ordered from high to low based on scores. If <code>key</code> doesn't exist, or if <code>member</code> is not present in the set, <code>None</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n&gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n    [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n</code></pre> <p>Since: Valkey version 7.2.0.</p> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zrevrank_withscore(\n    self, key: TEncodable, member: TEncodable\n) -&gt; Optional[List[Union[int, float]]]:\n    \"\"\"\n    Returns the rank of `member` in the sorted set stored at `key` with its score, where scores are ordered from the\n    highest to lowest, starting from `0`.\n\n    See https://valkey.io/commands/zrevrank for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose rank is to be retrieved.\n\n    Returns:\n        Optional[List[Union[int, float]]]: A list containing the rank (as `int`) and score (as `float`) of `member`\n            in the sorted set, where ranks are ordered from high to low based on scores.\n            If `key` doesn't exist, or if `member` is not present in the set, `None` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"my_sorted_set\", {\"member1\": 10.5, \"member2\": 8.2, \"member3\": 9.6})\n        &gt;&gt;&gt; await client.zrevrank(\"my_sorted_set\", \"member2\")\n            [2, 8.2]  # \"member2\" with score 8.2 has the third-highest score in the sorted set \"my_sorted_set\"\n\n    Since: Valkey version 7.2.0.\n    \"\"\"\n    return cast(\n        Optional[List[Union[int, float]]],\n        await self._execute_command(\n            RequestType.ZRevRank, [key, member, \"WITHSCORE\"]\n        ),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zscan","title":"<code>zscan(key, cursor, match=None, count=None, no_scores=False)</code>  <code>async</code>","text":"<p>Iterates incrementally over a sorted set.</p> <p>See https://valkey.io/commands/zscan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>cursor</code> <code>TEncodable</code> <p>The cursor that points to the next iteration of results. A value of \"0\" indicates the start of the search.</p> required <code>match</code> <code>Optional[TEncodable]</code> <p>The match filter is applied to the result of the command and will only include strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return only a subset of the sorted set then there could be a case where the result is empty although there are items that match the pattern specified. This is due to the default <code>COUNT</code> being <code>10</code> which indicates that it will only fetch and match <code>10</code> items from the list.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p><code>COUNT</code> is a just a hint for the command for how many elements to fetch from the sorted set. <code>COUNT</code> could be ignored until the sorted set is large enough for the <code>SCAN</code> commands to represent the results as compact single-allocation packed encoding.</p> <code>None</code> <code>no_scores</code> <code>bool</code> <p>If <code>True</code>, the command will not return scores associated with the members. Since Valkey \"8.0.0\".</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: An <code>Array</code> of the <code>cursor</code> and the subset of the sorted set held by <code>key</code>.</p> <code>List[Union[bytes, List[bytes]]]</code> <p>The first element is always the <code>cursor</code> for the next iteration of results. <code>0</code> will be the <code>cursor</code></p> <code>List[Union[bytes, List[bytes]]]</code> <p>returned on the last iteration of the sorted set. The second element is always an <code>Array</code> of the subset</p> <code>List[Union[bytes, List[bytes]]]</code> <p>of the sorted set held in <code>key</code>. The <code>Array</code> in the second element is a flattened series of</p> <code>List[Union[bytes, List[bytes]]]</code> <p><code>String</code> pairs, where the value is at even indices and the score is at odd indices.</p> <code>List[Union[bytes, List[bytes]]]</code> <p>If <code>no_scores</code> is set to<code>True</code>, the second element will only contain the members without scores.</p> <p>Examples:</p>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zscan--assume-key-contains-a-sorted-set-with-multiple-members","title":"Assume \"key\" contains a sorted set with multiple members","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n...     new_cursor = str(result [0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 123\nMembers: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\nCursor: 47\nMembers: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\nCursor: 0\nMembers: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zscan--using-no-score","title":"Using no-score","text":"<pre><code>&gt;&gt;&gt; result_cursor = \"0\"\n&gt;&gt;&gt; while True:\n...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n...     new_cursor = str(result[0])\n...     print(\"Cursor: \", new_cursor)\n...     print(\"Members: \", result[1])\n...     if new_cursor == \"0\":\n...         break\n...     result_cursor = new_cursor\nCursor: 123\nMembers: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\nCursor: 47\nMembers: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\nCursor: 0\nMembers: [b'value 55', b'value 24', b'value 90', b'value 113']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zscan(\n    self,\n    key: TEncodable,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    no_scores: bool = False,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Iterates incrementally over a sorted set.\n\n    See https://valkey.io/commands/zscan for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        cursor (TEncodable): The cursor that points to the next iteration of results. A value of \"0\" indicates the start of\n            the search.\n        match (Optional[TEncodable]): The match filter is applied to the result of the command and will only include\n            strings or byte strings that match the pattern specified. If the sorted set is large enough for scan commands to return\n            only a subset of the sorted set then there could be a case where the result is empty although there are\n            items that match the pattern specified. This is due to the default `COUNT` being `10` which indicates\n            that it will only fetch and match `10` items from the list.\n        count (Optional[int]): `COUNT` is a just a hint for the command for how many elements to fetch from the\n            sorted set. `COUNT` could be ignored until the sorted set is large enough for the `SCAN` commands to\n            represent the results as compact single-allocation packed encoding.\n        no_scores (bool): If `True`, the command will not return scores associated with the members. Since Valkey \"8.0.0\".\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: An `Array` of the `cursor` and the subset of the sorted set held by `key`.\n        The first element is always the `cursor` for the next iteration of results. `0` will be the `cursor`\n        returned on the last iteration of the sorted set. The second element is always an `Array` of the subset\n        of the sorted set held in `key`. The `Array` in the second element is a flattened series of\n        `String` pairs, where the value is at even indices and the score is at odd indices.\n        If `no_scores` is set to`True`, the second element will only contain the members without scores.\n\n    Examples:\n        # Assume \"key\" contains a sorted set with multiple members\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5)\n        ...     new_cursor = str(result [0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 123\n        Members: [b'value 163', b'163', b'value 114', b'114', b'value 25', b'25', b'value 82', b'82', b'value 64', b'64']\n        Cursor: 47\n        Members: [b'value 39', b'39', b'value 127', b'127', b'value 43', b'43', b'value 139', b'139', b'value 211', b'211']\n        Cursor: 0\n        Members: [b'value 55', b'55', b'value 24', b'24', b'value 90', b'90', b'value 113', b'113']\n\n        # Using no-score\n        &gt;&gt;&gt; result_cursor = \"0\"\n        &gt;&gt;&gt; while True:\n        ...     result = await client.zscan(\"key\", \"0\", match=\"*\", count=5, no_scores=True)\n        ...     new_cursor = str(result[0])\n        ...     print(\"Cursor: \", new_cursor)\n        ...     print(\"Members: \", result[1])\n        ...     if new_cursor == \"0\":\n        ...         break\n        ...     result_cursor = new_cursor\n        Cursor: 123\n        Members: [b'value 163', b'value 114', b'value 25', b'value 82', b'value 64']\n        Cursor: 47\n        Members: [b'value 39', b'value 127', b'value 43', b'value 139', b'value 211']\n        Cursor: 0\n        Members: [b'value 55', b'value 24', b'value 90', b'value 113']\n    \"\"\"\n    args: List[TEncodable] = [key, cursor]\n    if match is not None:\n        args += [\"MATCH\", match]\n    if count is not None:\n        args += [\"COUNT\", str(count)]\n    if no_scores:\n        args.append(\"NOSCORES\")\n\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.ZScan, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zscore","title":"<code>zscore(key, member)</code>  <code>async</code>","text":"<p>Returns the score of <code>member</code> in the sorted set stored at <code>key</code>.</p> <p>See https://valkey.io/commands/zscore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key of the sorted set.</p> required <code>member</code> <code>TEncodable</code> <p>The member whose score is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: The score of the member.</p> <code>Optional[float]</code> <p>If <code>member</code> does not exist in the sorted set, None is returned.</p> <code>Optional[float]</code> <p>If <code>key</code> does not exist,  None is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n    10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n&gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n    None\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zscore(self, key: TEncodable, member: TEncodable) -&gt; Optional[float]:\n    \"\"\"\n    Returns the score of `member` in the sorted set stored at `key`.\n\n    See https://valkey.io/commands/zscore/ for more details.\n\n    Args:\n        key (TEncodable): The key of the sorted set.\n        member (TEncodable): The member whose score is to be retrieved.\n\n    Returns:\n        Optional[float]: The score of the member.\n        If `member` does not exist in the sorted set, None is returned.\n        If `key` does not exist,  None is returned.\n\n    Examples:\n        &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"member\")\n            10.5  # Indicates that the score of \"member\" in the sorted set \"my_sorted_set\" is 10.5.\n        &gt;&gt;&gt; await client.zscore(\"my_sorted_set\", \"non_existing_member\")\n            None\n    \"\"\"\n    return cast(\n        Optional[float],\n        await self._execute_command(RequestType.ZScore, [key, member]),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zunion","title":"<code>zunion(keys)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and returns a list of union elements. To get the scores as well, see <code>zunion_withscores</code>. To store the result in a key as a sorted set, see <code>zunionstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunion/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[TEncodable]</code> <p>The keys of the sorted sets.</p> required <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]: The resulting array of union elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n    [b'member1', b'member2']\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunion(\n    self,\n    keys: List[TEncodable],\n) -&gt; List[bytes]:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and returns a list of union elements.\n    To get the scores as well, see `zunion_withscores`.\n    To store the result in a key as a sorted set, see `zunionstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunion/ for more details.\n\n    Args:\n        keys (List[TEncodable]): The keys of the sorted sets.\n\n    Returns:\n        List[bytes]: The resulting array of union elements.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunion([\"key1\", \"key2\"])\n            [b'member1', b'member2']\n    \"\"\"\n    args: List[TEncodable] = [str(len(keys))]\n    args.extend(keys)\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.ZUnion, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zunion_withscores","title":"<code>zunion_withscores(keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and returns a sorted set of union elements with scores. To get the elements only, see <code>zunion</code>. To store the result in a key as a sorted set, see <code>zunionstore</code>.</p> <p>When in cluster mode, all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunion/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[bytes, float]</code> <p>Mapping[bytes, float]: The resulting sorted set with scores.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n    {b'member1': 20, b'member2': 8.2}\n&gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n    {b'member1': 10.5, b'member2': 8.2}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunion_withscores(\n    self,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; Mapping[bytes, float]:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and returns a sorted set of union elements with scores.\n    To get the elements only, see `zunion`.\n    To store the result in a key as a sorted set, see `zunionstore`.\n\n    When in cluster mode, all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunion/ for more details.\n\n    Args:\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        Mapping[bytes, float]: The resulting sorted set with scores.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"])\n            {b'member1': 20, b'member2': 8.2}\n        &gt;&gt;&gt; await client.zunion_withscores([\"key1\", \"key2\"], AggregationType.MAX)\n            {b'member1': 10.5, b'member2': 8.2}\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type)\n    args.append(\"WITHSCORES\")\n    return cast(\n        Mapping[bytes, float],\n        await self._execute_command(RequestType.ZUnion, args),\n    )\n</code></pre>"},{"location":"python/core_commands/#glide.async_commands.CoreCommands.zunionstore","title":"<code>zunionstore(destination, keys, aggregation_type=None)</code>  <code>async</code>","text":"<p>Computes the union of sorted sets given by the specified <code>keys</code> and stores the result in <code>destination</code>. If <code>destination</code> already exists, it is overwritten. Otherwise, a new sorted set will be created. To get the result directly, see <code>zunion_withscores</code>.</p> <p>When in cluster mode, <code>destination</code> and all keys in <code>keys</code> must map to the same hash slot.</p> <p>See https://valkey.io/commands/zunionstore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>TEncodable</code> <p>The key of the destination sorted set.</p> required <code>keys</code> <code>Union[List[TEncodable], List[Tuple[TEncodable, float]]]</code> <p>The keys of the sorted sets with possible formats: List[TEncodable] - for keys only. List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.</p> required <code>aggregation_type</code> <code>Optional[AggregationType]</code> <p>Specifies the aggregation strategy to apply when combining the scores of elements. See <code>AggregationType</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the resulting sorted set stored at <code>destination</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n&gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n&gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n    2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 20, b'member2': 8.2}\n&gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n    2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n&gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n    {b'member1': 10.5, b'member2': 8.2}\n</code></pre> Source code in <code>glide/async_commands/core.py</code> <pre><code>async def zunionstore(\n    self,\n    destination: TEncodable,\n    keys: Union[List[TEncodable], List[Tuple[TEncodable, float]]],\n    aggregation_type: Optional[AggregationType] = None,\n) -&gt; int:\n    \"\"\"\n    Computes the union of sorted sets given by the specified `keys` and stores the result in `destination`.\n    If `destination` already exists, it is overwritten. Otherwise, a new sorted set will be created.\n    To get the result directly, see `zunion_withscores`.\n\n    When in cluster mode, `destination` and all keys in `keys` must map to the same hash slot.\n\n    See https://valkey.io/commands/zunionstore/ for more details.\n\n    Args:\n        destination (TEncodable): The key of the destination sorted set.\n        keys (Union[List[TEncodable], List[Tuple[TEncodable, float]]]): The keys of the sorted sets with possible formats:\n            List[TEncodable] - for keys only.\n            List[Tuple[TEncodable, float]] - for weighted keys with score multipliers.\n        aggregation_type (Optional[AggregationType]): Specifies the aggregation strategy to apply\n            when combining the scores of elements. See `AggregationType`.\n\n    Returns:\n        int: The number of elements in the resulting sorted set stored at `destination`.\n\n    Examples:\n        &gt;&gt;&gt; await client.zadd(\"key1\", {\"member1\": 10.5, \"member2\": 8.2})\n        &gt;&gt;&gt; await client.zadd(\"key2\", {\"member1\": 9.5})\n        &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"])\n            2 # Indicates that the sorted set \"my_sorted_set\" contains two elements.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 20, b'member2': 8.2}\n        &gt;&gt;&gt; await client.zunionstore(\"my_sorted_set\", [\"key1\", \"key2\"], AggregationType.MAX)\n            2 # Indicates that the sorted set \"my_sorted_set\" contains two elements, and each score is the maximum score between the sets.\n        &gt;&gt;&gt; await client.zrange_withscores(\"my_sorted_set\", RangeByIndex(0, -1))\n            {b'member1': 10.5, b'member2': 8.2}\n    \"\"\"\n    args = _create_zinter_zunion_cmd_args(keys, aggregation_type, destination)\n    return cast(\n        int,\n        await self._execute_command(RequestType.ZUnionStore, args),\n    )\n</code></pre>"},{"location":"python/glide_client/","title":"Standalone","text":"<p>               Bases: <code>BaseClient</code>, <code>StandaloneCommands</code></p> <p>Client used for connection to standalone servers. For full documentation, see https://github.com/valkey-io/valkey-glide/wiki/Python-wrapper#standalone</p> Source code in <code>glide/glide_client.py</code> <pre><code>class GlideClient(BaseClient, StandaloneCommands):\n    \"\"\"\n    Client used for connection to standalone servers.\n    For full documentation, see\n    https://github.com/valkey-io/valkey-glide/wiki/Python-wrapper#standalone\n    \"\"\"\n</code></pre>"},{"location":"python/glide_cluster_client/","title":"Cluster","text":"<p>               Bases: <code>BaseClient</code>, <code>ClusterCommands</code></p> <p>Client used for connection to cluster servers. For full documentation, see https://github.com/valkey-io/valkey-glide/wiki/Python-wrapper#cluster</p> Source code in <code>glide/glide_client.py</code> <pre><code>class GlideClusterClient(BaseClient, ClusterCommands):\n    \"\"\"\n    Client used for connection to cluster servers.\n    For full documentation, see\n    https://github.com/valkey-io/valkey-glide/wiki/Python-wrapper#cluster\n    \"\"\"\n\n    async def _cluster_scan(\n        self,\n        cursor: ClusterScanCursor,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        type: Optional[ObjectType] = None,\n    ) -&gt; List[Union[ClusterScanCursor, List[bytes]]]:\n        if self._is_closed:\n            raise ClosingError(\n                \"Unable to execute requests; the client is closed. Please create a new client.\"\n            )\n        request = CommandRequest()\n        request.callback_idx = self._get_callback_index()\n        # Take out the id string from the wrapping object\n        cursor_string = cursor.get_cursor()\n        request.cluster_scan.cursor = cursor_string\n        if match is not None:\n            request.cluster_scan.match_pattern = (\n                self._encode_arg(match) if isinstance(match, str) else match\n            )\n        if count is not None:\n            request.cluster_scan.count = count\n        if type is not None:\n            request.cluster_scan.object_type = type.value\n        response = await self._write_request_await_response(request)\n        return [ClusterScanCursor(bytes(response[0]).decode()), response[1]]\n\n    def _get_protobuf_conn_request(self) -&gt; ConnectionRequest:\n        return self.config._create_a_protobuf_conn_request(cluster_mode=True)\n</code></pre>"},{"location":"python/standalone_commands/","title":"StandaloneCommands","text":"<p>               Bases: <code>CoreCommands</code></p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>class StandaloneCommands(CoreCommands):\n    async def custom_command(self, command_args: List[TEncodable]) -&gt; TResult:\n        \"\"\"\n        Executes a single command, without checking inputs.\n        See the [Valkey GLIDE Wiki](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#custom-command)\n        for details on the restrictions and limitations of the custom command API.\n\n            @example - Return a list of all pub/sub clients:\n\n                connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"])\n        Args:\n            command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.\n            Every part of the command, including the command name and subcommands, should be added as a separate value in args.\n\n        Returns:\n            TResult: The returning value depends on the executed command.\n        \"\"\"\n        return await self._execute_command(RequestType.CustomCommand, command_args)\n\n    async def info(\n        self,\n        sections: Optional[List[InfoSection]] = None,\n    ) -&gt; bytes:\n        \"\"\"\n        Get information and statistics about the server.\n        See https://valkey.io/commands/info/ for details.\n\n        Args:\n            sections (Optional[List[InfoSection]]): A list of InfoSection values specifying which sections of\n            information to retrieve. When no parameter is provided, the default option is assumed.\n\n\n        Returns:\n            bytes: Returns bytes containing the information for the sections requested.\n        \"\"\"\n        args: List[TEncodable] = (\n            [section.value for section in sections] if sections else []\n        )\n        return cast(bytes, await self._execute_command(RequestType.Info, args))\n\n    async def exec(\n        self,\n        transaction: Transaction,\n    ) -&gt; Optional[List[TResult]]:\n        \"\"\"\n        Execute a transaction by processing the queued commands.\n        See https://valkey.io/docs/topics/transactions/ for details on Transactions.\n\n        Args:\n            transaction (Transaction): A `Transaction` object containing a list of commands to be executed.\n\n        Returns:\n            Optional[List[TResult]]: A list of results corresponding to the execution of each command\n                in the transaction. If a command returns a value, it will be included in the list. If a command\n                doesn't return a value, the list entry will be `None`.\n                If the transaction failed due to a WATCH command, `exec` will return `None`.\n        \"\"\"\n        commands = transaction.commands[:]\n        return await self._execute_transaction(commands)\n\n    async def select(self, index: int) -&gt; TOK:\n        \"\"\"\n        Change the currently selected database.\n        See https://valkey.io/commands/select/ for details.\n\n        Args:\n            index (int): The index of the database to select.\n\n        Returns:\n            A simple OK response.\n        \"\"\"\n        return cast(TOK, await self._execute_command(RequestType.Select, [str(index)]))\n\n    async def config_resetstat(self) -&gt; TOK:\n        \"\"\"\n        Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands.\n        See https://valkey.io/commands/config-resetstat/ for details.\n\n        Returns:\n            OK: Returns \"OK\" to confirm that the statistics were successfully reset.\n        \"\"\"\n        return cast(TOK, await self._execute_command(RequestType.ConfigResetStat, []))\n\n    async def config_rewrite(self) -&gt; TOK:\n        \"\"\"\n        Rewrite the configuration file with the current configuration.\n        See https://valkey.io/commands/config-rewrite/ for details.\n\n        Returns:\n            OK: OK is returned when the configuration was rewritten properly. Otherwise, an error is raised.\n        \"\"\"\n        return cast(TOK, await self._execute_command(RequestType.ConfigRewrite, []))\n\n    async def client_id(\n        self,\n    ) -&gt; int:\n        \"\"\"\n        Returns the current connection id.\n        See https://valkey.io/commands/client-id/ for more information.\n\n        Returns:\n            int: the id of the client.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.ClientId, []))\n\n    async def ping(self, message: Optional[TEncodable] = None) -&gt; bytes:\n        \"\"\"\n        Ping the server.\n        See https://valkey.io/commands/ping/ for more details.\n\n        Args:\n           message (Optional[TEncodable]): An optional message to include in the PING command. If not provided,\n            the server will respond with b\"PONG\". If provided, the server will respond with a copy of the message.\n\n        Returns:\n           bytes: b\"PONG\" if `message` is not provided, otherwise return a copy of `message`.\n\n        Examples:\n            &gt;&gt;&gt; await client.ping()\n                b\"PONG\"\n            &gt;&gt;&gt; await client.ping(\"Hello\")\n                b\"Hello\"\n        \"\"\"\n        argument = [] if message is None else [message]\n        return cast(bytes, await self._execute_command(RequestType.Ping, argument))\n\n    async def config_get(self, parameters: List[TEncodable]) -&gt; Dict[bytes, bytes]:\n        \"\"\"\n        Get the values of configuration parameters.\n        See https://valkey.io/commands/config-get/ for details.\n\n        Args:\n            parameters (List[TEncodable]): A list of configuration parameter names to retrieve values for.\n\n        Returns:\n            Dict[bytes, bytes]: A dictionary of values corresponding to the configuration parameters.\n\n        Examples:\n            &gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n                {b'timeout': b'1000'}\n            &gt;&gt;&gt; await client.config_get([b\"timeout\" , \"maxmemory\"])\n                {b'timeout': b'1000', b'maxmemory': b'1GB'}\n        \"\"\"\n        return cast(\n            Dict[bytes, bytes],\n            await self._execute_command(RequestType.ConfigGet, parameters),\n        )\n\n    async def config_set(self, parameters_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n        \"\"\"\n        Set configuration parameters to the specified values.\n        See https://valkey.io/commands/config-set/ for details.\n\n        Args:\n            parameters_map (Mapping[TEncodable, TEncodable]): A map consisting of configuration\n            parameters and their respective values to set.\n\n        Returns:\n            OK: Returns OK if all configurations have been successfully set. Otherwise, raises an error.\n\n        Examples:\n            &gt;&gt;&gt; config_set({\"timeout\": \"1000\", \"maxmemory\": \"1GB\"})\n                OK\n        \"\"\"\n        parameters: List[TEncodable] = []\n        for pair in parameters_map.items():\n            parameters.extend(pair)\n        return cast(TOK, await self._execute_command(RequestType.ConfigSet, parameters))\n\n    async def client_getname(self) -&gt; Optional[bytes]:\n        \"\"\"\n        Get the name of the primary's connection.\n        See https://valkey.io/commands/client-getname/ for more details.\n\n        Returns:\n            Optional[bytes]: Returns the name of the client connection as a byte string if a name is set,\n            or None if no name is assigned.\n\n        Examples:\n            &gt;&gt;&gt; await client.client_getname()\n                b'Connection Name'\n        \"\"\"\n        return cast(\n            Optional[bytes], await self._execute_command(RequestType.ClientGetName, [])\n        )\n\n    async def dbsize(self) -&gt; int:\n        \"\"\"\n        Returns the number of keys in the currently selected database.\n        See https://valkey.io/commands/dbsize for more details.\n\n        Returns:\n            int: The number of keys in the currently selected database.\n\n        Examples:\n            &gt;&gt;&gt; await client.dbsize()\n                10  # Indicates there are 10 keys in the current database.\n        \"\"\"\n        return cast(int, await self._execute_command(RequestType.DBSize, []))\n\n    async def echo(self, message: TEncodable) -&gt; bytes:\n        \"\"\"\n        Echoes the provided `message` back.\n\n        See https://valkey.io/commands/echo for more details.\n\n        Args:\n            message (TEncodable): The message to be echoed back.\n\n        Returns:\n            bytes: The provided `message`.\n\n        Examples:\n            &gt;&gt;&gt; await client.echo(\"Valkey GLIDE\")\n                b'Valkey GLIDE'\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.Echo, [message]))\n\n    async def function_load(\n        self, library_code: TEncodable, replace: bool = False\n    ) -&gt; bytes:\n        \"\"\"\n        Loads a library to Valkey.\n\n        See https://valkey.io/commands/function-load/ for more details.\n\n        Args:\n            library_code (TEncodable): The source code that implements the library.\n            replace (bool): Whether the given library should overwrite a library with the same name if\n                it already exists.\n\n        Returns:\n            bytes: The library name that was loaded.\n\n        Examples:\n            &gt;&gt;&gt; code = \"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n            &gt;&gt;&gt; await client.function_load(code, True)\n                b\"mylib\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            bytes,\n            await self._execute_command(\n                RequestType.FunctionLoad,\n                [\"REPLACE\", library_code] if replace else [library_code],\n            ),\n        )\n\n    async def function_list(\n        self, library_name_pattern: Optional[TEncodable] = None, with_code: bool = False\n    ) -&gt; TFunctionListResponse:\n        \"\"\"\n        Returns information about the functions and libraries.\n\n        See https://valkey.io/commands/function-list/ for more details.\n\n        Args:\n            library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n            with_code (bool): Specifies whether to request the library code from the server or not.\n\n        Returns:\n            TFunctionListResponse: Info about all or\n                selected libraries and their functions.\n\n        Examples:\n            &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n                [{\n                    b\"library_name\": b\"myLib5_backup\",\n                    b\"engine\": b\"LUA\",\n                    b\"functions\": [{\n                        b\"name\": b\"myfunc\",\n                        b\"description\": None,\n                        b\"flags\": {b\"no-writes\"},\n                    }],\n                    b\"library_code\": b\"#!lua name=mylib \\n sever.register_function('myfunc', function(keys, args) return args[1] end)\"\n                }]\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        args = []\n        if library_name_pattern is not None:\n            args.extend([\"LIBRARYNAME\", library_name_pattern])\n        if with_code:\n            args.append(\"WITHCODE\")\n        return cast(\n            TFunctionListResponse,\n            await self._execute_command(\n                RequestType.FunctionList,\n                args,\n            ),\n        )\n\n    async def function_flush(self, mode: Optional[FlushMode] = None) -&gt; TOK:\n        \"\"\"\n        Deletes all function libraries.\n\n        See https://valkey.io/commands/function-flush/ for more details.\n\n        Args:\n            mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.FunctionFlush,\n                [mode.value] if mode else [],\n            ),\n        )\n\n    async def function_delete(self, library_name: TEncodable) -&gt; TOK:\n        \"\"\"\n        Deletes a library and all its functions.\n\n        See https://valkey.io/commands/function-delete/ for more details.\n\n        Args:\n            library_code (TEncodable): The library name to delete\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_delete(\"my_lib\")\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.FunctionDelete,\n                [library_name],\n            ),\n        )\n\n    async def function_kill(self) -&gt; TOK:\n        \"\"\"\n        Kills a function that is currently executing.\n        This command only terminates read-only functions.\n\n        FUNCTION KILL runs on all nodes of the server, including primary and replicas.\n\n        See https://valkey.io/commands/function-kill/ for more details.\n\n        Returns:\n            TOK: A simple `OK`.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_kill()\n                \"OK\"\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.FunctionKill, []),\n        )\n\n    async def function_stats(self) -&gt; TFunctionStatsFullResponse:\n        \"\"\"\n        Returns information about the function that's currently running and information about the\n        available execution engines.\n\n        FUNCTION STATS runs on all nodes of the server, including primary and replicas.\n        The response includes a mapping from node address to the command response for that node.\n\n        See https://valkey.io/commands/function-stats/ for more details\n\n        Returns:\n            TFunctionStatsFullResponse: A Map where the key is the node address and the value is a Map of two keys:\n                - `running_script` with information about the running script.\n                - `engines` with information about available engines and their stats.\n                See example for more details.\n\n        Examples:\n            &gt;&gt;&gt; await client.function_stats()\n                {b\"addr\": {                         # Response from the master node\n                    b'running_script': {\n                        b'name': b'foo',\n                        b'command': [b'FCALL', b'foo', b'0', b'hello'],\n                        b'duration_ms': 7758\n                    },\n                    b'engines': {\n                        b'LUA': {\n                            b'libraries_count': 1,\n                            b'functions_count': 1,\n                        }\n                    }\n                },\n                b\"addr2\": {                         # Response from a replica\n                    b'running_script': None,\n                    b\"engines\": {\n                        b'LUA': {\n                            b'libraries_count': 1,\n                            b'functions_count': 1,\n                        }\n                    }\n                }}\n\n        Since: Valkey version 7.0.0.\n        \"\"\"\n        return cast(\n            TFunctionStatsFullResponse,\n            await self._execute_command(RequestType.FunctionStats, []),\n        )\n\n    async def function_dump(self) -&gt; bytes:\n        \"\"\"\n        Returns the serialized payload of all loaded libraries.\n\n        See https://valkey.io/docs/latest/commands/function-dump/ for more details.\n\n        Returns:\n            bytes: The serialized payload of all loaded libraries.\n\n        Examples:\n            &gt;&gt;&gt; payload = await client.function_dump()\n                # The serialized payload of all loaded libraries. This response can\n                # be used to restore loaded functions on any Valkey instance.\n            &gt;&gt;&gt; await client.function_restore(payload)\n                \"OK\" # The serialized dump response was used to restore the libraries.\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        return cast(bytes, await self._execute_command(RequestType.FunctionDump, []))\n\n    async def function_restore(\n        self, payload: TEncodable, policy: Optional[FunctionRestorePolicy] = None\n    ) -&gt; TOK:\n        \"\"\"\n        Restores libraries from the serialized payload returned by the `function_dump` command.\n\n        See https://valkey.io/docs/latest/commands/function-restore/ for more details.\n\n        Args:\n            payload (TEncodable): The serialized data from the `function_dump` command.\n            policy (Optional[FunctionRestorePolicy]): A policy for handling existing libraries.\n\n        Returns:\n            TOK: OK.\n\n        Examples:\n            &gt;&gt;&gt; payload = await client.function_dump()\n                # The serialized payload of all loaded libraries. This response can\n                # be used to restore loaded functions on any Valkey instance.\n            &gt;&gt;&gt; await client.function_restore(payload)\n                \"OK\" # The serialized dump response was used to restore the libraries.\n            &gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH)\n                \"OK\" # The serialized dump response was used to restore the libraries with the specified policy.\n\n        Since: Valkey 7.0.0.\n        \"\"\"\n        args: List[TEncodable] = [payload]\n        if policy is not None:\n            args.append(policy.value)\n\n        return cast(TOK, await self._execute_command(RequestType.FunctionRestore, args))\n\n    async def time(self) -&gt; List[bytes]:\n        \"\"\"\n        Returns the server time.\n\n        See https://valkey.io/commands/time/ for more details.\n\n        Returns:\n            List[bytes]:  The current server time as a two items `array`:\n            A Unix timestamp and the amount of microseconds already elapsed in the current second.\n            The returned `array` is in a [Unix timestamp, Microseconds already elapsed] format.\n\n        Examples:\n            &gt;&gt;&gt; await client.time()\n                [b'1710925775', b'913580']\n        \"\"\"\n        return cast(\n            List[bytes],\n            await self._execute_command(RequestType.Time, []),\n        )\n\n    async def lastsave(self) -&gt; int:\n        \"\"\"\n        Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.\n\n        See https://valkey.io/commands/lastsave for more details.\n\n        Returns:\n            int: The Unix time of the last successful DB save.\n\n        Examples:\n            &gt;&gt;&gt; await client.lastsave()\n                1710925775  # Unix time of the last DB save\n        \"\"\"\n        return cast(\n            int,\n            await self._execute_command(RequestType.LastSave, []),\n        )\n\n    async def move(self, key: TEncodable, db_index: int) -&gt; bool:\n        \"\"\"\n        Move `key` from the currently selected database to the database specified by `db_index`.\n\n        See https://valkey.io/commands/move/ for more details.\n\n        Args:\n            key (TEncodable): The key to move.\n            db_index (int): The index of the database to move `key` to.\n\n        Returns:\n            bool: True if `key` was moved, or False if the `key` already exists in the destination database\n                or does not exist in the source database.\n\n        Example:\n            &gt;&gt;&gt; await client.move(\"some_key\", 1)\n                True\n        \"\"\"\n        return cast(\n            bool,\n            await self._execute_command(RequestType.Move, [key, str(db_index)]),\n        )\n\n    async def publish(self, message: TEncodable, channel: TEncodable) -&gt; int:\n        \"\"\"\n        Publish a message on pubsub channel.\n        See https://valkey.io/commands/publish for more details.\n\n        Args:\n            message (TEncodable): Message to publish\n            channel (TEncodable): Channel to publish the message on.\n\n        Returns:\n            int: Number of subscriptions in primary node that received the message.\n            Note that this value does not include subscriptions that configured on replicas.\n\n        Examples:\n            &gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\")\n                1 # This message was posted to 1 subscription which is configured on primary node\n        \"\"\"\n        return cast(\n            int, await self._execute_command(RequestType.Publish, [channel, message])\n        )\n\n    async def flushall(self, flush_mode: Optional[FlushMode] = None) -&gt; TOK:\n        \"\"\"\n        Deletes all the keys of all the existing databases. This command never fails.\n\n        See https://valkey.io/commands/flushall for more details.\n\n        Args:\n            flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n        Returns:\n            TOK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n                OK  # This command never fails.\n        \"\"\"\n        args: List[TEncodable] = []\n        if flush_mode is not None:\n            args.append(flush_mode.value)\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.FlushAll, args),\n        )\n\n    async def flushdb(self, flush_mode: Optional[FlushMode] = None) -&gt; TOK:\n        \"\"\"\n        Deletes all the keys of the currently selected database. This command never fails.\n\n        See https://valkey.io/commands/flushdb for more details.\n\n        Args:\n            flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n        Returns:\n            TOK: A simple OK response.\n\n        Examples:\n            &gt;&gt;&gt; await client.flushdb()\n                OK  # The keys of the currently selected database were deleted.\n            &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n                OK  # The keys of the currently selected database were deleted asynchronously.\n        \"\"\"\n        args: List[TEncodable] = []\n        if flush_mode is not None:\n            args.append(flush_mode.value)\n\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.FlushDB, args),\n        )\n\n    async def copy(\n        self,\n        source: TEncodable,\n        destination: TEncodable,\n        destinationDB: Optional[int] = None,\n        replace: Optional[bool] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Copies the value stored at the `source` to the `destination` key. If `destinationDB`\n        is specified, the value will be copied to the database specified by `destinationDB`,\n        otherwise the current database will be used. When `replace` is True, removes the\n        `destination` key first if it already exists, otherwise performs no action.\n\n        See https://valkey.io/commands/copy for more details.\n\n        Args:\n            source (TEncodable): The key to the source value.\n            destination (TEncodable): The key where the value should be copied to.\n            destinationDB (Optional[int]): The alternative logical database index for the destination key.\n            replace (Optional[bool]): If the destination key should be removed before copying the value to it.\n\n        Returns:\n            bool: True if the source was copied. Otherwise, return False.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n            &gt;&gt;&gt; await client.copy(b\"source\", b\"destination\", 1, False)\n                True # Source was copied\n            &gt;&gt;&gt; await client.select(1)\n            &gt;&gt;&gt; await client.get(\"destination\")\n                b\"sheep\"\n\n        Since: Valkey version 6.2.0.\n        \"\"\"\n        args: List[TEncodable] = [source, destination]\n        if destinationDB is not None:\n            args.extend([\"DB\", str(destinationDB)])\n        if replace is True:\n            args.append(\"REPLACE\")\n        return cast(\n            bool,\n            await self._execute_command(RequestType.Copy, args),\n        )\n\n    async def lolwut(\n        self,\n        version: Optional[int] = None,\n        parameters: Optional[List[int]] = None,\n    ) -&gt; bytes:\n        \"\"\"\n        Displays a piece of generative computer art and the Valkey version.\n\n        See https://valkey.io/commands/lolwut for more details.\n\n        Args:\n            version (Optional[int]): Version of computer art to generate.\n            parameters (Optional[List[int]]): Additional set of arguments in order to change the output:\n                For version `5`, those are length of the line, number of squares per row, and number of squares per column.\n                For version `6`, those are number of columns and number of lines.\n\n        Returns:\n            bytes: A piece of generative computer art along with the current Valkey version.\n\n        Examples:\n            &gt;&gt;&gt; await client.lolwut(6, [40, 20]);\n                b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n            &gt;&gt;&gt; await client.lolwut(5, [30, 5, 5]);\n                b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n        \"\"\"\n        args: List[TEncodable] = []\n        if version is not None:\n            args.extend([\"VERSION\", str(version)])\n        if parameters:\n            for var in parameters:\n                args.extend(str(var))\n        return cast(\n            bytes,\n            await self._execute_command(RequestType.Lolwut, args),\n        )\n\n    async def random_key(self) -&gt; Optional[bytes]:\n        \"\"\"\n        Returns a random existing key name from the currently selected database.\n\n        See https://valkey.io/commands/randomkey for more details.\n\n        Returns:\n            Optional[bytes]: A random existing key name from the currently selected database.\n\n        Examples:\n            &gt;&gt;&gt; await client.random_key()\n                b\"random_key_name\"  # \"random_key_name\" is a random existing key name from the currently selected database.\n        \"\"\"\n        return cast(\n            Optional[bytes],\n            await self._execute_command(RequestType.RandomKey, []),\n        )\n\n    async def wait(\n        self,\n        numreplicas: int,\n        timeout: int,\n    ) -&gt; int:\n        \"\"\"\n        Blocks the current client until all the previous write commands are successfully transferred\n        and acknowledged by at least `numreplicas` of replicas. If `timeout` is\n        reached, the command returns even if the specified number of replicas were not yet reached.\n\n        See https://valkey.io/commands/wait for more details.\n\n        Args:\n            numreplicas (int): The number of replicas to reach.\n            timeout (int): The timeout value specified in milliseconds. A value of 0 will block indefinitely.\n\n        Returns:\n            int: The number of replicas reached by all the writes performed in the context of the current connection.\n\n        Examples:\n            &gt;&gt;&gt; await client.set(\"key\", \"value\");\n            &gt;&gt;&gt; await client.wait(1, 1000);\n            // return 1 when a replica is reached or 0 if 1000ms is reached.\n        \"\"\"\n        args: List[TEncodable] = [str(numreplicas), str(timeout)]\n        return cast(\n            int,\n            await self._execute_command(RequestType.Wait, args),\n        )\n\n    async def unwatch(self) -&gt; TOK:\n        \"\"\"\n        Flushes all the previously watched keys for a transaction. Executing a transaction will\n        automatically flush all previously watched keys.\n\n        See https://valkey.io/commands/unwatch for more details.\n\n        Returns:\n            TOK: A simple \"OK\" response.\n\n        Examples:\n            &gt;&gt;&gt; await client.watch(\"sampleKey\")\n                'OK'\n            &gt;&gt;&gt; await client.unwatch()\n                'OK'\n        \"\"\"\n        return cast(\n            TOK,\n            await self._execute_command(RequestType.UnWatch, []),\n        )\n\n    async def scan(\n        self,\n        cursor: TEncodable,\n        match: Optional[TEncodable] = None,\n        count: Optional[int] = None,\n        type: Optional[ObjectType] = None,\n    ) -&gt; List[Union[bytes, List[bytes]]]:\n        \"\"\"\n        Incrementally iterate over a collection of keys.\n        SCAN is a cursor based iterator. This means that at every call of the command,\n        the server returns an updated cursor that the user needs to use as the cursor argument in the next call.\n        An iteration starts when the cursor is set to \"0\", and terminates when the cursor returned by the server is \"0\".\n\n        A full iteration always retrieves all the elements that were present\n        in the collection from the start to the end of a full iteration.\n        Elements that were not constantly present in the collection during a full iteration, may be returned or not.\n\n        See https://valkey.io/commands/scan for more details.\n\n        Args:\n            cursor (TResult): The cursor used for iteration. For the first iteration, the cursor should be set to \"0\".\n              Using a non-zero cursor in the first iteration,\n              or an invalid cursor at any iteration, will lead to undefined results.\n              Using the same cursor in multiple iterations will, in case nothing changed between the iterations,\n                return the same elements multiple times.\n                If the the db has changed, it may result an undefined behavior.\n            match (Optional[TResult]): A pattern to match keys against.\n            count (Optional[int]): The number of keys to return per iteration.\n                The number of keys returned per iteration is not guaranteed to be the same as the count argument.\n                the argument is used as a hint for the server to know how many \"steps\" it can use to retrieve the keys.\n                The default value is 10.\n            type (ObjectType): The type of object to scan for.\n\n        Returns:\n            List[Union[bytes, List[bytes]]]: A List containing the next cursor value and a list of keys,\n                formatted as [cursor, [key1, key2, ...]]\n\n        Examples:\n        &gt;&gt;&gt; result = await client.scan(b'0')\n            print(result) #[b'17', [b'key1', b'key2', b'key3', b'key4', b'key5', b'set1', b'set2', b'set3']]\n            first_cursor_result = result[0]\n            result = await client.scan(first_cursor_result)\n            print(result) #[b'349', [b'key4', b'key5', b'set1', b'hash1', b'zset1', b'list1', b'list2',\n                                    b'list3', b'zset2', b'zset3', b'zset4', b'zset5', b'zset6']]\n            result = await client.scan(result[0])\n            print(result) #[b'0', [b'key6', b'key7']]\n\n        &gt;&gt;&gt; result = await client.scan(first_cursor_result, match=b'key*', count=2)\n            print(result) #[b'6', [b'key4', b'key5']]\n\n        &gt;&gt;&gt; result = await client.scan(\"0\", type=ObjectType.Set)\n            print(result) #[b'362', [b'set1', b'set2', b'set3']]\n        \"\"\"\n        args = [cursor]\n        if match:\n            args.extend([\"MATCH\", match])\n        if count:\n            args.extend([\"COUNT\", str(count)])\n        if type:\n            args.extend([\"TYPE\", type.value])\n        return cast(\n            List[Union[bytes, List[bytes]]],\n            await self._execute_command(RequestType.Scan, args),\n        )\n\n    async def script_exists(self, sha1s: List[TEncodable]) -&gt; List[bool]:\n        \"\"\"\n        Check existence of scripts in the script cache by their SHA1 digest.\n\n        See https://valkey.io/commands/script-exists for more details.\n\n        Args:\n            sha1s (List[TEncodable]): List of SHA1 digests of the scripts to check.\n\n        Returns:\n            List[bool]: A list of boolean values indicating the existence of each script.\n\n        Examples:\n            &gt;&gt;&gt; await client.script_exists([\"sha1_digest1\", \"sha1_digest2\"])\n                [True, False]\n        \"\"\"\n        return cast(\n            List[bool], await self._execute_command(RequestType.ScriptExists, sha1s)\n        )\n\n    async def script_flush(self, mode: Optional[FlushMode] = None) -&gt; TOK:\n        \"\"\"\n        Flush the Lua scripts cache.\n\n        See https://valkey.io/commands/script-flush for more details.\n\n        Args:\n            mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n        Returns:\n            TOK: A simple `OK` response.\n\n        Examples:\n            &gt;&gt;&gt; await client.script_flush()\n                \"OK\"\n\n            &gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n                \"OK\"\n        \"\"\"\n\n        return cast(\n            TOK,\n            await self._execute_command(\n                RequestType.ScriptFlush, [mode.value] if mode else []\n            ),\n        )\n\n    async def script_kill(self) -&gt; TOK:\n        \"\"\"\n        Kill the currently executing Lua script, assuming no write operation was yet performed by the script.\n\n        See https://valkey.io/commands/script-kill for more details.\n\n        Returns:\n            TOK: A simple `OK` response.\n\n        Examples:\n            &gt;&gt;&gt; await client.script_kill()\n                \"OK\"\n        \"\"\"\n        return cast(TOK, await self._execute_command(RequestType.ScriptKill, []))\n\n    async def invoke_script(\n        self,\n        script: Script,\n        keys: Optional[List[TEncodable]] = None,\n        args: Optional[List[TEncodable]] = None,\n    ) -&gt; TResult:\n        \"\"\"\n        Invokes a Lua script with its keys and arguments.\n        This method simplifies the process of invoking scripts on a the server by using an object that represents a Lua script.\n        The script loading, argument preparation, and execution will all be handled internally.\n        If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n        After that, it will be invoked using the `EVALSHA` command.\n\n        See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n        Args:\n            script (Script): The Lua script to execute.\n            keys (Optional[List[TEncodable]]): The keys that are used in the script.\n            args (Optional[List[TEncodable]]): The arguments for the script.\n\n        Returns:\n            TResult: a value that depends on the script that was executed.\n\n        Examples:\n            &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n            &gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n                [b\"foo\", b\"bar\"]\n        \"\"\"\n        return await self._execute_script(script.get_hash(), keys, args)\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.client_getname","title":"<code>client_getname()</code>  <code>async</code>","text":"<p>Get the name of the primary's connection. See https://valkey.io/commands/client-getname/ for more details.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: Returns the name of the client connection as a byte string if a name is set,</p> <code>Optional[bytes]</code> <p>or None if no name is assigned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.client_getname()\n    b'Connection Name'\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def client_getname(self) -&gt; Optional[bytes]:\n    \"\"\"\n    Get the name of the primary's connection.\n    See https://valkey.io/commands/client-getname/ for more details.\n\n    Returns:\n        Optional[bytes]: Returns the name of the client connection as a byte string if a name is set,\n        or None if no name is assigned.\n\n    Examples:\n        &gt;&gt;&gt; await client.client_getname()\n            b'Connection Name'\n    \"\"\"\n    return cast(\n        Optional[bytes], await self._execute_command(RequestType.ClientGetName, [])\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.client_id","title":"<code>client_id()</code>  <code>async</code>","text":"<p>Returns the current connection id. See https://valkey.io/commands/client-id/ for more information.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id of the client.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def client_id(\n    self,\n) -&gt; int:\n    \"\"\"\n    Returns the current connection id.\n    See https://valkey.io/commands/client-id/ for more information.\n\n    Returns:\n        int: the id of the client.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.ClientId, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.config_get","title":"<code>config_get(parameters)</code>  <code>async</code>","text":"<p>Get the values of configuration parameters. See https://valkey.io/commands/config-get/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>List[TEncodable]</code> <p>A list of configuration parameter names to retrieve values for.</p> required <p>Returns:</p> Type Description <code>Dict[bytes, bytes]</code> <p>Dict[bytes, bytes]: A dictionary of values corresponding to the configuration parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n    {b'timeout': b'1000'}\n&gt;&gt;&gt; await client.config_get([b\"timeout\" , \"maxmemory\"])\n    {b'timeout': b'1000', b'maxmemory': b'1GB'}\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def config_get(self, parameters: List[TEncodable]) -&gt; Dict[bytes, bytes]:\n    \"\"\"\n    Get the values of configuration parameters.\n    See https://valkey.io/commands/config-get/ for details.\n\n    Args:\n        parameters (List[TEncodable]): A list of configuration parameter names to retrieve values for.\n\n    Returns:\n        Dict[bytes, bytes]: A dictionary of values corresponding to the configuration parameters.\n\n    Examples:\n        &gt;&gt;&gt; await client.config_get([\"timeout\"] , RandomNode())\n            {b'timeout': b'1000'}\n        &gt;&gt;&gt; await client.config_get([b\"timeout\" , \"maxmemory\"])\n            {b'timeout': b'1000', b'maxmemory': b'1GB'}\n    \"\"\"\n    return cast(\n        Dict[bytes, bytes],\n        await self._execute_command(RequestType.ConfigGet, parameters),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.config_resetstat","title":"<code>config_resetstat()</code>  <code>async</code>","text":"<p>Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands. See https://valkey.io/commands/config-resetstat/ for details.</p> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>Returns \"OK\" to confirm that the statistics were successfully reset.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def config_resetstat(self) -&gt; TOK:\n    \"\"\"\n    Resets the statistics reported by the server using the INFO and LATENCY HISTOGRAM commands.\n    See https://valkey.io/commands/config-resetstat/ for details.\n\n    Returns:\n        OK: Returns \"OK\" to confirm that the statistics were successfully reset.\n    \"\"\"\n    return cast(TOK, await self._execute_command(RequestType.ConfigResetStat, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.config_rewrite","title":"<code>config_rewrite()</code>  <code>async</code>","text":"<p>Rewrite the configuration file with the current configuration. See https://valkey.io/commands/config-rewrite/ for details.</p> <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>OK is returned when the configuration was rewritten properly. Otherwise, an error is raised.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def config_rewrite(self) -&gt; TOK:\n    \"\"\"\n    Rewrite the configuration file with the current configuration.\n    See https://valkey.io/commands/config-rewrite/ for details.\n\n    Returns:\n        OK: OK is returned when the configuration was rewritten properly. Otherwise, an error is raised.\n    \"\"\"\n    return cast(TOK, await self._execute_command(RequestType.ConfigRewrite, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.config_set","title":"<code>config_set(parameters_map)</code>  <code>async</code>","text":"<p>Set configuration parameters to the specified values. See https://valkey.io/commands/config-set/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>parameters_map</code> <code>Mapping[TEncodable, TEncodable]</code> <p>A map consisting of configuration</p> required <p>Returns:</p> Name Type Description <code>OK</code> <code>TOK</code> <p>Returns OK if all configurations have been successfully set. Otherwise, raises an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config_set({\"timeout\": \"1000\", \"maxmemory\": \"1GB\"})\n    OK\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def config_set(self, parameters_map: Mapping[TEncodable, TEncodable]) -&gt; TOK:\n    \"\"\"\n    Set configuration parameters to the specified values.\n    See https://valkey.io/commands/config-set/ for details.\n\n    Args:\n        parameters_map (Mapping[TEncodable, TEncodable]): A map consisting of configuration\n        parameters and their respective values to set.\n\n    Returns:\n        OK: Returns OK if all configurations have been successfully set. Otherwise, raises an error.\n\n    Examples:\n        &gt;&gt;&gt; config_set({\"timeout\": \"1000\", \"maxmemory\": \"1GB\"})\n            OK\n    \"\"\"\n    parameters: List[TEncodable] = []\n    for pair in parameters_map.items():\n        parameters.extend(pair)\n    return cast(TOK, await self._execute_command(RequestType.ConfigSet, parameters))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.copy","title":"<code>copy(source, destination, destinationDB=None, replace=None)</code>  <code>async</code>","text":"<p>Copies the value stored at the <code>source</code> to the <code>destination</code> key. If <code>destinationDB</code> is specified, the value will be copied to the database specified by <code>destinationDB</code>, otherwise the current database will be used. When <code>replace</code> is True, removes the <code>destination</code> key first if it already exists, otherwise performs no action.</p> <p>See https://valkey.io/commands/copy for more details.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>TEncodable</code> <p>The key to the source value.</p> required <code>destination</code> <code>TEncodable</code> <p>The key where the value should be copied to.</p> required <code>destinationDB</code> <code>Optional[int]</code> <p>The alternative logical database index for the destination key.</p> <code>None</code> <code>replace</code> <code>Optional[bool]</code> <p>If the destination key should be removed before copying the value to it.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the source was copied. Otherwise, return False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n&gt;&gt;&gt; await client.copy(b\"source\", b\"destination\", 1, False)\n    True # Source was copied\n&gt;&gt;&gt; await client.select(1)\n&gt;&gt;&gt; await client.get(\"destination\")\n    b\"sheep\"\n</code></pre> <p>Since: Valkey version 6.2.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def copy(\n    self,\n    source: TEncodable,\n    destination: TEncodable,\n    destinationDB: Optional[int] = None,\n    replace: Optional[bool] = None,\n) -&gt; bool:\n    \"\"\"\n    Copies the value stored at the `source` to the `destination` key. If `destinationDB`\n    is specified, the value will be copied to the database specified by `destinationDB`,\n    otherwise the current database will be used. When `replace` is True, removes the\n    `destination` key first if it already exists, otherwise performs no action.\n\n    See https://valkey.io/commands/copy for more details.\n\n    Args:\n        source (TEncodable): The key to the source value.\n        destination (TEncodable): The key where the value should be copied to.\n        destinationDB (Optional[int]): The alternative logical database index for the destination key.\n        replace (Optional[bool]): If the destination key should be removed before copying the value to it.\n\n    Returns:\n        bool: True if the source was copied. Otherwise, return False.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"source\", \"sheep\")\n        &gt;&gt;&gt; await client.copy(b\"source\", b\"destination\", 1, False)\n            True # Source was copied\n        &gt;&gt;&gt; await client.select(1)\n        &gt;&gt;&gt; await client.get(\"destination\")\n            b\"sheep\"\n\n    Since: Valkey version 6.2.0.\n    \"\"\"\n    args: List[TEncodable] = [source, destination]\n    if destinationDB is not None:\n        args.extend([\"DB\", str(destinationDB)])\n    if replace is True:\n        args.append(\"REPLACE\")\n    return cast(\n        bool,\n        await self._execute_command(RequestType.Copy, args),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.custom_command","title":"<code>custom_command(command_args)</code>  <code>async</code>","text":"<p>Executes a single command, without checking inputs. See the Valkey GLIDE Wiki for details on the restrictions and limitations of the custom command API.</p> <pre><code>@example - Return a list of all pub/sub clients:\n\n    connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"])\n</code></pre> <p>Args:     command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.     Every part of the command, including the command name and subcommands, should be added as a separate value in args.</p> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TResult</code> <p>The returning value depends on the executed command.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def custom_command(self, command_args: List[TEncodable]) -&gt; TResult:\n    \"\"\"\n    Executes a single command, without checking inputs.\n    See the [Valkey GLIDE Wiki](https://github.com/valkey-io/valkey-glide/wiki/General-Concepts#custom-command)\n    for details on the restrictions and limitations of the custom command API.\n\n        @example - Return a list of all pub/sub clients:\n\n            connection.customCommand([\"CLIENT\", \"LIST\",\"TYPE\", \"PUBSUB\"])\n    Args:\n        command_args (List[TEncodable]): List of the command's arguments, where each argument is either a string or bytes.\n        Every part of the command, including the command name and subcommands, should be added as a separate value in args.\n\n    Returns:\n        TResult: The returning value depends on the executed command.\n    \"\"\"\n    return await self._execute_command(RequestType.CustomCommand, command_args)\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.dbsize","title":"<code>dbsize()</code>  <code>async</code>","text":"<p>Returns the number of keys in the currently selected database. See https://valkey.io/commands/dbsize for more details.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of keys in the currently selected database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.dbsize()\n    10  # Indicates there are 10 keys in the current database.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def dbsize(self) -&gt; int:\n    \"\"\"\n    Returns the number of keys in the currently selected database.\n    See https://valkey.io/commands/dbsize for more details.\n\n    Returns:\n        int: The number of keys in the currently selected database.\n\n    Examples:\n        &gt;&gt;&gt; await client.dbsize()\n            10  # Indicates there are 10 keys in the current database.\n    \"\"\"\n    return cast(int, await self._execute_command(RequestType.DBSize, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.echo","title":"<code>echo(message)</code>  <code>async</code>","text":"<p>Echoes the provided <code>message</code> back.</p> <p>See https://valkey.io/commands/echo for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>TEncodable</code> <p>The message to be echoed back.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The provided <code>message</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.echo(\"Valkey GLIDE\")\n    b'Valkey GLIDE'\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def echo(self, message: TEncodable) -&gt; bytes:\n    \"\"\"\n    Echoes the provided `message` back.\n\n    See https://valkey.io/commands/echo for more details.\n\n    Args:\n        message (TEncodable): The message to be echoed back.\n\n    Returns:\n        bytes: The provided `message`.\n\n    Examples:\n        &gt;&gt;&gt; await client.echo(\"Valkey GLIDE\")\n            b'Valkey GLIDE'\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.Echo, [message]))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.exec","title":"<code>exec(transaction)</code>  <code>async</code>","text":"<p>Execute a transaction by processing the queued commands. See https://valkey.io/docs/topics/transactions/ for details on Transactions.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>A <code>Transaction</code> object containing a list of commands to be executed.</p> required <p>Returns:</p> Type Description <code>Optional[List[TResult]]</code> <p>Optional[List[TResult]]: A list of results corresponding to the execution of each command in the transaction. If a command returns a value, it will be included in the list. If a command doesn't return a value, the list entry will be <code>None</code>. If the transaction failed due to a WATCH command, <code>exec</code> will return <code>None</code>.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def exec(\n    self,\n    transaction: Transaction,\n) -&gt; Optional[List[TResult]]:\n    \"\"\"\n    Execute a transaction by processing the queued commands.\n    See https://valkey.io/docs/topics/transactions/ for details on Transactions.\n\n    Args:\n        transaction (Transaction): A `Transaction` object containing a list of commands to be executed.\n\n    Returns:\n        Optional[List[TResult]]: A list of results corresponding to the execution of each command\n            in the transaction. If a command returns a value, it will be included in the list. If a command\n            doesn't return a value, the list entry will be `None`.\n            If the transaction failed due to a WATCH command, `exec` will return `None`.\n    \"\"\"\n    commands = transaction.commands[:]\n    return await self._execute_transaction(commands)\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.flushall","title":"<code>flushall(flush_mode=None)</code>  <code>async</code>","text":"<p>Deletes all the keys of all the existing databases. This command never fails.</p> <p>See https://valkey.io/commands/flushall for more details.</p> <p>Parameters:</p> Name Type Description Default <code>flush_mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n    OK  # This command never fails.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def flushall(self, flush_mode: Optional[FlushMode] = None) -&gt; TOK:\n    \"\"\"\n    Deletes all the keys of all the existing databases. This command never fails.\n\n    See https://valkey.io/commands/flushall for more details.\n\n    Args:\n        flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n    Returns:\n        TOK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.flushall(FlushMode.ASYNC)\n            OK  # This command never fails.\n    \"\"\"\n    args: List[TEncodable] = []\n    if flush_mode is not None:\n        args.append(flush_mode.value)\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.FlushAll, args),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.flushdb","title":"<code>flushdb(flush_mode=None)</code>  <code>async</code>","text":"<p>Deletes all the keys of the currently selected database. This command never fails.</p> <p>See https://valkey.io/commands/flushdb for more details.</p> <p>Parameters:</p> Name Type Description Default <code>flush_mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple OK response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.flushdb()\n    OK  # The keys of the currently selected database were deleted.\n&gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n    OK  # The keys of the currently selected database were deleted asynchronously.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def flushdb(self, flush_mode: Optional[FlushMode] = None) -&gt; TOK:\n    \"\"\"\n    Deletes all the keys of the currently selected database. This command never fails.\n\n    See https://valkey.io/commands/flushdb for more details.\n\n    Args:\n        flush_mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n    Returns:\n        TOK: A simple OK response.\n\n    Examples:\n        &gt;&gt;&gt; await client.flushdb()\n            OK  # The keys of the currently selected database were deleted.\n        &gt;&gt;&gt; await client.flushdb(FlushMode.ASYNC)\n            OK  # The keys of the currently selected database were deleted asynchronously.\n    \"\"\"\n    args: List[TEncodable] = []\n    if flush_mode is not None:\n        args.append(flush_mode.value)\n\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.FlushDB, args),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_delete","title":"<code>function_delete(library_name)</code>  <code>async</code>","text":"<p>Deletes a library and all its functions.</p> <p>See https://valkey.io/commands/function-delete/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>library_code</code> <code>TEncodable</code> <p>The library name to delete</p> required <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_delete(\"my_lib\")\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_delete(self, library_name: TEncodable) -&gt; TOK:\n    \"\"\"\n    Deletes a library and all its functions.\n\n    See https://valkey.io/commands/function-delete/ for more details.\n\n    Args:\n        library_code (TEncodable): The library name to delete\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_delete(\"my_lib\")\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.FunctionDelete,\n            [library_name],\n        ),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_dump","title":"<code>function_dump()</code>  <code>async</code>","text":"<p>Returns the serialized payload of all loaded libraries.</p> <p>See https://valkey.io/docs/latest/commands/function-dump/ for more details.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The serialized payload of all loaded libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payload = await client.function_dump()\n    # The serialized payload of all loaded libraries. This response can\n    # be used to restore loaded functions on any Valkey instance.\n&gt;&gt;&gt; await client.function_restore(payload)\n    \"OK\" # The serialized dump response was used to restore the libraries.\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_dump(self) -&gt; bytes:\n    \"\"\"\n    Returns the serialized payload of all loaded libraries.\n\n    See https://valkey.io/docs/latest/commands/function-dump/ for more details.\n\n    Returns:\n        bytes: The serialized payload of all loaded libraries.\n\n    Examples:\n        &gt;&gt;&gt; payload = await client.function_dump()\n            # The serialized payload of all loaded libraries. This response can\n            # be used to restore loaded functions on any Valkey instance.\n        &gt;&gt;&gt; await client.function_restore(payload)\n            \"OK\" # The serialized dump response was used to restore the libraries.\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(bytes, await self._execute_command(RequestType.FunctionDump, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_flush","title":"<code>function_flush(mode=None)</code>  <code>async</code>","text":"<p>Deletes all function libraries.</p> <p>See https://valkey.io/commands/function-flush/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_flush(self, mode: Optional[FlushMode] = None) -&gt; TOK:\n    \"\"\"\n    Deletes all function libraries.\n\n    See https://valkey.io/commands/function-flush/ for more details.\n\n    Args:\n        mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_flush(FlushMode.SYNC)\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.FunctionFlush,\n            [mode.value] if mode else [],\n        ),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_kill","title":"<code>function_kill()</code>  <code>async</code>","text":"<p>Kills a function that is currently executing. This command only terminates read-only functions.</p> <p>FUNCTION KILL runs on all nodes of the server, including primary and replicas.</p> <p>See https://valkey.io/commands/function-kill/ for more details.</p> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_kill()\n    \"OK\"\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_kill(self) -&gt; TOK:\n    \"\"\"\n    Kills a function that is currently executing.\n    This command only terminates read-only functions.\n\n    FUNCTION KILL runs on all nodes of the server, including primary and replicas.\n\n    See https://valkey.io/commands/function-kill/ for more details.\n\n    Returns:\n        TOK: A simple `OK`.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_kill()\n            \"OK\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.FunctionKill, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_list","title":"<code>function_list(library_name_pattern=None, with_code=False)</code>  <code>async</code>","text":"<pre><code>   Returns information about the functions and libraries.\n\n   See https://valkey.io/commands/function-list/ for more details.\n\n   Args:\n       library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n       with_code (bool): Specifies whether to request the library code from the server or not.\n\n   Returns:\n       TFunctionListResponse: Info about all or\n           selected libraries and their functions.\n\n   Examples:\n       &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n           [{\n               b\"library_name\": b\"myLib5_backup\",\n               b\"engine\": b\"LUA\",\n               b\"functions\": [{\n                   b\"name\": b\"myfunc\",\n                   b\"description\": None,\n                   b\"flags\": {b\"no-writes\"},\n               }],\n               b\"library_code\": b\"#!lua name=mylib\n</code></pre> <p>sever.register_function('myfunc', function(keys, args) return args[1] end)\"                }]</p> <pre><code>   Since: Valkey 7.0.0.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_list(\n    self, library_name_pattern: Optional[TEncodable] = None, with_code: bool = False\n) -&gt; TFunctionListResponse:\n    \"\"\"\n    Returns information about the functions and libraries.\n\n    See https://valkey.io/commands/function-list/ for more details.\n\n    Args:\n        library_name_pattern (Optional[TEncodable]):  A wildcard pattern for matching library names.\n        with_code (bool): Specifies whether to request the library code from the server or not.\n\n    Returns:\n        TFunctionListResponse: Info about all or\n            selected libraries and their functions.\n\n    Examples:\n        &gt;&gt;&gt; response = await client.function_list(\"myLib?_backup\", True)\n            [{\n                b\"library_name\": b\"myLib5_backup\",\n                b\"engine\": b\"LUA\",\n                b\"functions\": [{\n                    b\"name\": b\"myfunc\",\n                    b\"description\": None,\n                    b\"flags\": {b\"no-writes\"},\n                }],\n                b\"library_code\": b\"#!lua name=mylib \\n sever.register_function('myfunc', function(keys, args) return args[1] end)\"\n            }]\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    args = []\n    if library_name_pattern is not None:\n        args.extend([\"LIBRARYNAME\", library_name_pattern])\n    if with_code:\n        args.append(\"WITHCODE\")\n    return cast(\n        TFunctionListResponse,\n        await self._execute_command(\n            RequestType.FunctionList,\n            args,\n        ),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_load","title":"<code>function_load(library_code, replace=False)</code>  <code>async</code>","text":"<pre><code>   Loads a library to Valkey.\n\n   See https://valkey.io/commands/function-load/ for more details.\n\n   Args:\n       library_code (TEncodable): The source code that implements the library.\n       replace (bool): Whether the given library should overwrite a library with the same name if\n           it already exists.\n\n   Returns:\n       bytes: The library name that was loaded.\n\n   Examples:\n       &gt;&gt;&gt; code = \"#!lua name=mylib\n</code></pre> <p>redis.register_function('myfunc', function(keys, args) return args[1] end)\"            &gt;&gt;&gt; await client.function_load(code, True)                b\"mylib\"</p> <pre><code>   Since: Valkey 7.0.0.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_load(\n    self, library_code: TEncodable, replace: bool = False\n) -&gt; bytes:\n    \"\"\"\n    Loads a library to Valkey.\n\n    See https://valkey.io/commands/function-load/ for more details.\n\n    Args:\n        library_code (TEncodable): The source code that implements the library.\n        replace (bool): Whether the given library should overwrite a library with the same name if\n            it already exists.\n\n    Returns:\n        bytes: The library name that was loaded.\n\n    Examples:\n        &gt;&gt;&gt; code = \"#!lua name=mylib \\n redis.register_function('myfunc', function(keys, args) return args[1] end)\"\n        &gt;&gt;&gt; await client.function_load(code, True)\n            b\"mylib\"\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    return cast(\n        bytes,\n        await self._execute_command(\n            RequestType.FunctionLoad,\n            [\"REPLACE\", library_code] if replace else [library_code],\n        ),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_restore","title":"<code>function_restore(payload, policy=None)</code>  <code>async</code>","text":"<p>Restores libraries from the serialized payload returned by the <code>function_dump</code> command.</p> <p>See https://valkey.io/docs/latest/commands/function-restore/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>TEncodable</code> <p>The serialized data from the <code>function_dump</code> command.</p> required <code>policy</code> <code>Optional[FunctionRestorePolicy]</code> <p>A policy for handling existing libraries.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>OK.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payload = await client.function_dump()\n    # The serialized payload of all loaded libraries. This response can\n    # be used to restore loaded functions on any Valkey instance.\n&gt;&gt;&gt; await client.function_restore(payload)\n    \"OK\" # The serialized dump response was used to restore the libraries.\n&gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH)\n    \"OK\" # The serialized dump response was used to restore the libraries with the specified policy.\n</code></pre> <p>Since: Valkey 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_restore(\n    self, payload: TEncodable, policy: Optional[FunctionRestorePolicy] = None\n) -&gt; TOK:\n    \"\"\"\n    Restores libraries from the serialized payload returned by the `function_dump` command.\n\n    See https://valkey.io/docs/latest/commands/function-restore/ for more details.\n\n    Args:\n        payload (TEncodable): The serialized data from the `function_dump` command.\n        policy (Optional[FunctionRestorePolicy]): A policy for handling existing libraries.\n\n    Returns:\n        TOK: OK.\n\n    Examples:\n        &gt;&gt;&gt; payload = await client.function_dump()\n            # The serialized payload of all loaded libraries. This response can\n            # be used to restore loaded functions on any Valkey instance.\n        &gt;&gt;&gt; await client.function_restore(payload)\n            \"OK\" # The serialized dump response was used to restore the libraries.\n        &gt;&gt;&gt; await client.function_restore(payload, FunctionRestorePolicy.FLUSH)\n            \"OK\" # The serialized dump response was used to restore the libraries with the specified policy.\n\n    Since: Valkey 7.0.0.\n    \"\"\"\n    args: List[TEncodable] = [payload]\n    if policy is not None:\n        args.append(policy.value)\n\n    return cast(TOK, await self._execute_command(RequestType.FunctionRestore, args))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.function_stats","title":"<code>function_stats()</code>  <code>async</code>","text":"<p>Returns information about the function that's currently running and information about the available execution engines.</p> <p>FUNCTION STATS runs on all nodes of the server, including primary and replicas. The response includes a mapping from node address to the command response for that node.</p> <p>See https://valkey.io/commands/function-stats/ for more details</p> <p>Returns:</p> Name Type Description <code>TFunctionStatsFullResponse</code> <code>TFunctionStatsFullResponse</code> <p>A Map where the key is the node address and the value is a Map of two keys: - <code>running_script</code> with information about the running script. - <code>engines</code> with information about available engines and their stats. See example for more details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.function_stats()\n    {b\"addr\": {                         # Response from the master node\n        b'running_script': {\n            b'name': b'foo',\n            b'command': [b'FCALL', b'foo', b'0', b'hello'],\n            b'duration_ms': 7758\n        },\n        b'engines': {\n            b'LUA': {\n                b'libraries_count': 1,\n                b'functions_count': 1,\n            }\n        }\n    },\n    b\"addr2\": {                         # Response from a replica\n        b'running_script': None,\n        b\"engines\": {\n            b'LUA': {\n                b'libraries_count': 1,\n                b'functions_count': 1,\n            }\n        }\n    }}\n</code></pre> <p>Since: Valkey version 7.0.0.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def function_stats(self) -&gt; TFunctionStatsFullResponse:\n    \"\"\"\n    Returns information about the function that's currently running and information about the\n    available execution engines.\n\n    FUNCTION STATS runs on all nodes of the server, including primary and replicas.\n    The response includes a mapping from node address to the command response for that node.\n\n    See https://valkey.io/commands/function-stats/ for more details\n\n    Returns:\n        TFunctionStatsFullResponse: A Map where the key is the node address and the value is a Map of two keys:\n            - `running_script` with information about the running script.\n            - `engines` with information about available engines and their stats.\n            See example for more details.\n\n    Examples:\n        &gt;&gt;&gt; await client.function_stats()\n            {b\"addr\": {                         # Response from the master node\n                b'running_script': {\n                    b'name': b'foo',\n                    b'command': [b'FCALL', b'foo', b'0', b'hello'],\n                    b'duration_ms': 7758\n                },\n                b'engines': {\n                    b'LUA': {\n                        b'libraries_count': 1,\n                        b'functions_count': 1,\n                    }\n                }\n            },\n            b\"addr2\": {                         # Response from a replica\n                b'running_script': None,\n                b\"engines\": {\n                    b'LUA': {\n                        b'libraries_count': 1,\n                        b'functions_count': 1,\n                    }\n                }\n            }}\n\n    Since: Valkey version 7.0.0.\n    \"\"\"\n    return cast(\n        TFunctionStatsFullResponse,\n        await self._execute_command(RequestType.FunctionStats, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.info","title":"<code>info(sections=None)</code>  <code>async</code>","text":"<p>Get information and statistics about the server. See https://valkey.io/commands/info/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>Optional[List[InfoSection]]</code> <p>A list of InfoSection values specifying which sections of</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Returns bytes containing the information for the sections requested.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def info(\n    self,\n    sections: Optional[List[InfoSection]] = None,\n) -&gt; bytes:\n    \"\"\"\n    Get information and statistics about the server.\n    See https://valkey.io/commands/info/ for details.\n\n    Args:\n        sections (Optional[List[InfoSection]]): A list of InfoSection values specifying which sections of\n        information to retrieve. When no parameter is provided, the default option is assumed.\n\n\n    Returns:\n        bytes: Returns bytes containing the information for the sections requested.\n    \"\"\"\n    args: List[TEncodable] = (\n        [section.value for section in sections] if sections else []\n    )\n    return cast(bytes, await self._execute_command(RequestType.Info, args))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.invoke_script","title":"<code>invoke_script(script, keys=None, args=None)</code>  <code>async</code>","text":"<p>Invokes a Lua script with its keys and arguments. This method simplifies the process of invoking scripts on a the server by using an object that represents a Lua script. The script loading, argument preparation, and execution will all be handled internally. If the script has not already been loaded, it will be loaded automatically using the <code>SCRIPT LOAD</code> command. After that, it will be invoked using the <code>EVALSHA</code> command.</p> <p>See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>Script</code> <p>The Lua script to execute.</p> required <code>keys</code> <code>Optional[List[TEncodable]]</code> <p>The keys that are used in the script.</p> <code>None</code> <code>args</code> <code>Optional[List[TEncodable]]</code> <p>The arguments for the script.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TResult</code> <code>TResult</code> <p>a value that depends on the script that was executed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n&gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n    [b\"foo\", b\"bar\"]\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def invoke_script(\n    self,\n    script: Script,\n    keys: Optional[List[TEncodable]] = None,\n    args: Optional[List[TEncodable]] = None,\n) -&gt; TResult:\n    \"\"\"\n    Invokes a Lua script with its keys and arguments.\n    This method simplifies the process of invoking scripts on a the server by using an object that represents a Lua script.\n    The script loading, argument preparation, and execution will all be handled internally.\n    If the script has not already been loaded, it will be loaded automatically using the `SCRIPT LOAD` command.\n    After that, it will be invoked using the `EVALSHA` command.\n\n    See https://valkey.io/commands/script-load/ and https://valkey.io/commands/evalsha/ for more details.\n\n    Args:\n        script (Script): The Lua script to execute.\n        keys (Optional[List[TEncodable]]): The keys that are used in the script.\n        args (Optional[List[TEncodable]]): The arguments for the script.\n\n    Returns:\n        TResult: a value that depends on the script that was executed.\n\n    Examples:\n        &gt;&gt;&gt; lua_script = Script(\"return { KEYS[1], ARGV[1] }\")\n        &gt;&gt;&gt; await invoke_script(lua_script, keys=[\"foo\"], args=[\"bar\"] );\n            [b\"foo\", b\"bar\"]\n    \"\"\"\n    return await self._execute_script(script.get_hash(), keys, args)\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.lastsave","title":"<code>lastsave()</code>  <code>async</code>","text":"<p>Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.</p> <p>See https://valkey.io/commands/lastsave for more details.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The Unix time of the last successful DB save.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lastsave()\n    1710925775  # Unix time of the last DB save\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def lastsave(self) -&gt; int:\n    \"\"\"\n    Returns the Unix time of the last DB save timestamp or startup timestamp if no save was made since then.\n\n    See https://valkey.io/commands/lastsave for more details.\n\n    Returns:\n        int: The Unix time of the last successful DB save.\n\n    Examples:\n        &gt;&gt;&gt; await client.lastsave()\n            1710925775  # Unix time of the last DB save\n    \"\"\"\n    return cast(\n        int,\n        await self._execute_command(RequestType.LastSave, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.lolwut","title":"<code>lolwut(version=None, parameters=None)</code>  <code>async</code>","text":"<p>Displays a piece of generative computer art and the Valkey version.</p> <p>See https://valkey.io/commands/lolwut for more details.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Optional[int]</code> <p>Version of computer art to generate.</p> <code>None</code> <code>parameters</code> <code>Optional[List[int]]</code> <p>Additional set of arguments in order to change the output: For version <code>5</code>, those are length of the line, number of squares per row, and number of squares per column. For version <code>6</code>, those are number of columns and number of lines.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>A piece of generative computer art along with the current Valkey version.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.lolwut(6, [40, 20]);\n    b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n&gt;&gt;&gt; await client.lolwut(5, [30, 5, 5]);\n    b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def lolwut(\n    self,\n    version: Optional[int] = None,\n    parameters: Optional[List[int]] = None,\n) -&gt; bytes:\n    \"\"\"\n    Displays a piece of generative computer art and the Valkey version.\n\n    See https://valkey.io/commands/lolwut for more details.\n\n    Args:\n        version (Optional[int]): Version of computer art to generate.\n        parameters (Optional[List[int]]): Additional set of arguments in order to change the output:\n            For version `5`, those are length of the line, number of squares per row, and number of squares per column.\n            For version `6`, those are number of columns and number of lines.\n\n    Returns:\n        bytes: A piece of generative computer art along with the current Valkey version.\n\n    Examples:\n        &gt;&gt;&gt; await client.lolwut(6, [40, 20]);\n            b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n        &gt;&gt;&gt; await client.lolwut(5, [30, 5, 5]);\n            b\"Redis ver. 7.2.3\" # Indicates the current Valkey version\n    \"\"\"\n    args: List[TEncodable] = []\n    if version is not None:\n        args.extend([\"VERSION\", str(version)])\n    if parameters:\n        for var in parameters:\n            args.extend(str(var))\n    return cast(\n        bytes,\n        await self._execute_command(RequestType.Lolwut, args),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.move","title":"<code>move(key, db_index)</code>  <code>async</code>","text":"<p>Move <code>key</code> from the currently selected database to the database specified by <code>db_index</code>.</p> <p>See https://valkey.io/commands/move/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TEncodable</code> <p>The key to move.</p> required <code>db_index</code> <code>int</code> <p>The index of the database to move <code>key</code> to.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>key</code> was moved, or False if the <code>key</code> already exists in the destination database or does not exist in the source database.</p> Example <p>await client.move(\"some_key\", 1)     True</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def move(self, key: TEncodable, db_index: int) -&gt; bool:\n    \"\"\"\n    Move `key` from the currently selected database to the database specified by `db_index`.\n\n    See https://valkey.io/commands/move/ for more details.\n\n    Args:\n        key (TEncodable): The key to move.\n        db_index (int): The index of the database to move `key` to.\n\n    Returns:\n        bool: True if `key` was moved, or False if the `key` already exists in the destination database\n            or does not exist in the source database.\n\n    Example:\n        &gt;&gt;&gt; await client.move(\"some_key\", 1)\n            True\n    \"\"\"\n    return cast(\n        bool,\n        await self._execute_command(RequestType.Move, [key, str(db_index)]),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.ping","title":"<code>ping(message=None)</code>  <code>async</code>","text":"<p>Ping the server. See https://valkey.io/commands/ping/ for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[TEncodable]</code> <p>An optional message to include in the PING command. If not provided, the server will respond with b\"PONG\". If provided, the server will respond with a copy of the message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>b\"PONG\" if <code>message</code> is not provided, otherwise return a copy of <code>message</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.ping()\n    b\"PONG\"\n&gt;&gt;&gt; await client.ping(\"Hello\")\n    b\"Hello\"\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def ping(self, message: Optional[TEncodable] = None) -&gt; bytes:\n    \"\"\"\n    Ping the server.\n    See https://valkey.io/commands/ping/ for more details.\n\n    Args:\n       message (Optional[TEncodable]): An optional message to include in the PING command. If not provided,\n        the server will respond with b\"PONG\". If provided, the server will respond with a copy of the message.\n\n    Returns:\n       bytes: b\"PONG\" if `message` is not provided, otherwise return a copy of `message`.\n\n    Examples:\n        &gt;&gt;&gt; await client.ping()\n            b\"PONG\"\n        &gt;&gt;&gt; await client.ping(\"Hello\")\n            b\"Hello\"\n    \"\"\"\n    argument = [] if message is None else [message]\n    return cast(bytes, await self._execute_command(RequestType.Ping, argument))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.publish","title":"<code>publish(message, channel)</code>  <code>async</code>","text":"<p>Publish a message on pubsub channel. See https://valkey.io/commands/publish for more details.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>TEncodable</code> <p>Message to publish</p> required <code>channel</code> <code>TEncodable</code> <p>Channel to publish the message on.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of subscriptions in primary node that received the message.</p> <code>int</code> <p>Note that this value does not include subscriptions that configured on replicas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\")\n    1 # This message was posted to 1 subscription which is configured on primary node\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def publish(self, message: TEncodable, channel: TEncodable) -&gt; int:\n    \"\"\"\n    Publish a message on pubsub channel.\n    See https://valkey.io/commands/publish for more details.\n\n    Args:\n        message (TEncodable): Message to publish\n        channel (TEncodable): Channel to publish the message on.\n\n    Returns:\n        int: Number of subscriptions in primary node that received the message.\n        Note that this value does not include subscriptions that configured on replicas.\n\n    Examples:\n        &gt;&gt;&gt; await client.publish(\"Hi all!\", \"global-channel\")\n            1 # This message was posted to 1 subscription which is configured on primary node\n    \"\"\"\n    return cast(\n        int, await self._execute_command(RequestType.Publish, [channel, message])\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.random_key","title":"<code>random_key()</code>  <code>async</code>","text":"<p>Returns a random existing key name from the currently selected database.</p> <p>See https://valkey.io/commands/randomkey for more details.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Optional[bytes]: A random existing key name from the currently selected database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.random_key()\n    b\"random_key_name\"  # \"random_key_name\" is a random existing key name from the currently selected database.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def random_key(self) -&gt; Optional[bytes]:\n    \"\"\"\n    Returns a random existing key name from the currently selected database.\n\n    See https://valkey.io/commands/randomkey for more details.\n\n    Returns:\n        Optional[bytes]: A random existing key name from the currently selected database.\n\n    Examples:\n        &gt;&gt;&gt; await client.random_key()\n            b\"random_key_name\"  # \"random_key_name\" is a random existing key name from the currently selected database.\n    \"\"\"\n    return cast(\n        Optional[bytes],\n        await self._execute_command(RequestType.RandomKey, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.scan","title":"<code>scan(cursor, match=None, count=None, type=None)</code>  <code>async</code>","text":"<p>Incrementally iterate over a collection of keys. SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call. An iteration starts when the cursor is set to \"0\", and terminates when the cursor returned by the server is \"0\".</p> <p>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. Elements that were not constantly present in the collection during a full iteration, may be returned or not.</p> <p>See https://valkey.io/commands/scan for more details.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>TResult</code> <p>The cursor used for iteration. For the first iteration, the cursor should be set to \"0\". Using a non-zero cursor in the first iteration, or an invalid cursor at any iteration, will lead to undefined results. Using the same cursor in multiple iterations will, in case nothing changed between the iterations, return the same elements multiple times. If the the db has changed, it may result an undefined behavior.</p> required <code>match</code> <code>Optional[TResult]</code> <p>A pattern to match keys against.</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>The number of keys to return per iteration. The number of keys returned per iteration is not guaranteed to be the same as the count argument. the argument is used as a hint for the server to know how many \"steps\" it can use to retrieve the keys. The default value is 10.</p> <code>None</code> <code>type</code> <code>ObjectType</code> <p>The type of object to scan for.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Union[bytes, List[bytes]]]</code> <p>List[Union[bytes, List[bytes]]]: A List containing the next cursor value and a list of keys, formatted as [cursor, [key1, key2, ...]]</p> <p>Examples:</p> <p>result = await client.scan(b'0')     print(result) #[b'17', [b'key1', b'key2', b'key3', b'key4', b'key5', b'set1', b'set2', b'set3']]     first_cursor_result = result[0]     result = await client.scan(first_cursor_result)     print(result) #[b'349', [b'key4', b'key5', b'set1', b'hash1', b'zset1', b'list1', b'list2',                             b'list3', b'zset2', b'zset3', b'zset4', b'zset5', b'zset6']]     result = await client.scan(result[0])     print(result) #[b'0', [b'key6', b'key7']]</p> <p>result = await client.scan(first_cursor_result, match=b'key*', count=2)     print(result) #[b'6', [b'key4', b'key5']]</p> <p>result = await client.scan(\"0\", type=ObjectType.Set)     print(result) #[b'362', [b'set1', b'set2', b'set3']]</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def scan(\n    self,\n    cursor: TEncodable,\n    match: Optional[TEncodable] = None,\n    count: Optional[int] = None,\n    type: Optional[ObjectType] = None,\n) -&gt; List[Union[bytes, List[bytes]]]:\n    \"\"\"\n    Incrementally iterate over a collection of keys.\n    SCAN is a cursor based iterator. This means that at every call of the command,\n    the server returns an updated cursor that the user needs to use as the cursor argument in the next call.\n    An iteration starts when the cursor is set to \"0\", and terminates when the cursor returned by the server is \"0\".\n\n    A full iteration always retrieves all the elements that were present\n    in the collection from the start to the end of a full iteration.\n    Elements that were not constantly present in the collection during a full iteration, may be returned or not.\n\n    See https://valkey.io/commands/scan for more details.\n\n    Args:\n        cursor (TResult): The cursor used for iteration. For the first iteration, the cursor should be set to \"0\".\n          Using a non-zero cursor in the first iteration,\n          or an invalid cursor at any iteration, will lead to undefined results.\n          Using the same cursor in multiple iterations will, in case nothing changed between the iterations,\n            return the same elements multiple times.\n            If the the db has changed, it may result an undefined behavior.\n        match (Optional[TResult]): A pattern to match keys against.\n        count (Optional[int]): The number of keys to return per iteration.\n            The number of keys returned per iteration is not guaranteed to be the same as the count argument.\n            the argument is used as a hint for the server to know how many \"steps\" it can use to retrieve the keys.\n            The default value is 10.\n        type (ObjectType): The type of object to scan for.\n\n    Returns:\n        List[Union[bytes, List[bytes]]]: A List containing the next cursor value and a list of keys,\n            formatted as [cursor, [key1, key2, ...]]\n\n    Examples:\n    &gt;&gt;&gt; result = await client.scan(b'0')\n        print(result) #[b'17', [b'key1', b'key2', b'key3', b'key4', b'key5', b'set1', b'set2', b'set3']]\n        first_cursor_result = result[0]\n        result = await client.scan(first_cursor_result)\n        print(result) #[b'349', [b'key4', b'key5', b'set1', b'hash1', b'zset1', b'list1', b'list2',\n                                b'list3', b'zset2', b'zset3', b'zset4', b'zset5', b'zset6']]\n        result = await client.scan(result[0])\n        print(result) #[b'0', [b'key6', b'key7']]\n\n    &gt;&gt;&gt; result = await client.scan(first_cursor_result, match=b'key*', count=2)\n        print(result) #[b'6', [b'key4', b'key5']]\n\n    &gt;&gt;&gt; result = await client.scan(\"0\", type=ObjectType.Set)\n        print(result) #[b'362', [b'set1', b'set2', b'set3']]\n    \"\"\"\n    args = [cursor]\n    if match:\n        args.extend([\"MATCH\", match])\n    if count:\n        args.extend([\"COUNT\", str(count)])\n    if type:\n        args.extend([\"TYPE\", type.value])\n    return cast(\n        List[Union[bytes, List[bytes]]],\n        await self._execute_command(RequestType.Scan, args),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.script_exists","title":"<code>script_exists(sha1s)</code>  <code>async</code>","text":"<p>Check existence of scripts in the script cache by their SHA1 digest.</p> <p>See https://valkey.io/commands/script-exists for more details.</p> <p>Parameters:</p> Name Type Description Default <code>sha1s</code> <code>List[TEncodable]</code> <p>List of SHA1 digests of the scripts to check.</p> required <p>Returns:</p> Type Description <code>List[bool]</code> <p>List[bool]: A list of boolean values indicating the existence of each script.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.script_exists([\"sha1_digest1\", \"sha1_digest2\"])\n    [True, False]\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def script_exists(self, sha1s: List[TEncodable]) -&gt; List[bool]:\n    \"\"\"\n    Check existence of scripts in the script cache by their SHA1 digest.\n\n    See https://valkey.io/commands/script-exists for more details.\n\n    Args:\n        sha1s (List[TEncodable]): List of SHA1 digests of the scripts to check.\n\n    Returns:\n        List[bool]: A list of boolean values indicating the existence of each script.\n\n    Examples:\n        &gt;&gt;&gt; await client.script_exists([\"sha1_digest1\", \"sha1_digest2\"])\n            [True, False]\n    \"\"\"\n    return cast(\n        List[bool], await self._execute_command(RequestType.ScriptExists, sha1s)\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.script_flush","title":"<code>script_flush(mode=None)</code>  <code>async</code>","text":"<p>Flush the Lua scripts cache.</p> <p>See https://valkey.io/commands/script-flush for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[FlushMode]</code> <p>The flushing mode, could be either <code>SYNC</code> or <code>ASYNC</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.script_flush()\n    \"OK\"\n</code></pre> <pre><code>&gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n    \"OK\"\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def script_flush(self, mode: Optional[FlushMode] = None) -&gt; TOK:\n    \"\"\"\n    Flush the Lua scripts cache.\n\n    See https://valkey.io/commands/script-flush for more details.\n\n    Args:\n        mode (Optional[FlushMode]): The flushing mode, could be either `SYNC` or `ASYNC`.\n\n    Returns:\n        TOK: A simple `OK` response.\n\n    Examples:\n        &gt;&gt;&gt; await client.script_flush()\n            \"OK\"\n\n        &gt;&gt;&gt; await client.script_flush(FlushMode.ASYNC)\n            \"OK\"\n    \"\"\"\n\n    return cast(\n        TOK,\n        await self._execute_command(\n            RequestType.ScriptFlush, [mode.value] if mode else []\n        ),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.script_kill","title":"<code>script_kill()</code>  <code>async</code>","text":"<p>Kill the currently executing Lua script, assuming no write operation was yet performed by the script.</p> <p>See https://valkey.io/commands/script-kill for more details.</p> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple <code>OK</code> response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.script_kill()\n    \"OK\"\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def script_kill(self) -&gt; TOK:\n    \"\"\"\n    Kill the currently executing Lua script, assuming no write operation was yet performed by the script.\n\n    See https://valkey.io/commands/script-kill for more details.\n\n    Returns:\n        TOK: A simple `OK` response.\n\n    Examples:\n        &gt;&gt;&gt; await client.script_kill()\n            \"OK\"\n    \"\"\"\n    return cast(TOK, await self._execute_command(RequestType.ScriptKill, []))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.select","title":"<code>select(index)</code>  <code>async</code>","text":"<p>Change the currently selected database. See https://valkey.io/commands/select/ for details.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the database to select.</p> required <p>Returns:</p> Type Description <code>TOK</code> <p>A simple OK response.</p> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def select(self, index: int) -&gt; TOK:\n    \"\"\"\n    Change the currently selected database.\n    See https://valkey.io/commands/select/ for details.\n\n    Args:\n        index (int): The index of the database to select.\n\n    Returns:\n        A simple OK response.\n    \"\"\"\n    return cast(TOK, await self._execute_command(RequestType.Select, [str(index)]))\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.time","title":"<code>time()</code>  <code>async</code>","text":"<p>Returns the server time.</p> <p>See https://valkey.io/commands/time/ for more details.</p> <p>Returns:</p> Type Description <code>List[bytes]</code> <p>List[bytes]:  The current server time as a two items <code>array</code>:</p> <code>List[bytes]</code> <p>A Unix timestamp and the amount of microseconds already elapsed in the current second.</p> <code>List[bytes]</code> <p>The returned <code>array</code> is in a [Unix timestamp, Microseconds already elapsed] format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.time()\n    [b'1710925775', b'913580']\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def time(self) -&gt; List[bytes]:\n    \"\"\"\n    Returns the server time.\n\n    See https://valkey.io/commands/time/ for more details.\n\n    Returns:\n        List[bytes]:  The current server time as a two items `array`:\n        A Unix timestamp and the amount of microseconds already elapsed in the current second.\n        The returned `array` is in a [Unix timestamp, Microseconds already elapsed] format.\n\n    Examples:\n        &gt;&gt;&gt; await client.time()\n            [b'1710925775', b'913580']\n    \"\"\"\n    return cast(\n        List[bytes],\n        await self._execute_command(RequestType.Time, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.unwatch","title":"<code>unwatch()</code>  <code>async</code>","text":"<p>Flushes all the previously watched keys for a transaction. Executing a transaction will automatically flush all previously watched keys.</p> <p>See https://valkey.io/commands/unwatch for more details.</p> <p>Returns:</p> Name Type Description <code>TOK</code> <code>TOK</code> <p>A simple \"OK\" response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.watch(\"sampleKey\")\n    'OK'\n&gt;&gt;&gt; await client.unwatch()\n    'OK'\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def unwatch(self) -&gt; TOK:\n    \"\"\"\n    Flushes all the previously watched keys for a transaction. Executing a transaction will\n    automatically flush all previously watched keys.\n\n    See https://valkey.io/commands/unwatch for more details.\n\n    Returns:\n        TOK: A simple \"OK\" response.\n\n    Examples:\n        &gt;&gt;&gt; await client.watch(\"sampleKey\")\n            'OK'\n        &gt;&gt;&gt; await client.unwatch()\n            'OK'\n    \"\"\"\n    return cast(\n        TOK,\n        await self._execute_command(RequestType.UnWatch, []),\n    )\n</code></pre>"},{"location":"python/standalone_commands/#glide.async_commands.standalone_commands.StandaloneCommands.wait","title":"<code>wait(numreplicas, timeout)</code>  <code>async</code>","text":"<p>Blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least <code>numreplicas</code> of replicas. If <code>timeout</code> is reached, the command returns even if the specified number of replicas were not yet reached.</p> <p>See https://valkey.io/commands/wait for more details.</p> <p>Parameters:</p> Name Type Description Default <code>numreplicas</code> <code>int</code> <p>The number of replicas to reach.</p> required <code>timeout</code> <code>int</code> <p>The timeout value specified in milliseconds. A value of 0 will block indefinitely.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of replicas reached by all the writes performed in the context of the current connection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; await client.set(\"key\", \"value\");\n&gt;&gt;&gt; await client.wait(1, 1000);\n// return 1 when a replica is reached or 0 if 1000ms is reached.\n</code></pre> Source code in <code>glide/async_commands/standalone_commands.py</code> <pre><code>async def wait(\n    self,\n    numreplicas: int,\n    timeout: int,\n) -&gt; int:\n    \"\"\"\n    Blocks the current client until all the previous write commands are successfully transferred\n    and acknowledged by at least `numreplicas` of replicas. If `timeout` is\n    reached, the command returns even if the specified number of replicas were not yet reached.\n\n    See https://valkey.io/commands/wait for more details.\n\n    Args:\n        numreplicas (int): The number of replicas to reach.\n        timeout (int): The timeout value specified in milliseconds. A value of 0 will block indefinitely.\n\n    Returns:\n        int: The number of replicas reached by all the writes performed in the context of the current connection.\n\n    Examples:\n        &gt;&gt;&gt; await client.set(\"key\", \"value\");\n        &gt;&gt;&gt; await client.wait(1, 1000);\n        // return 1 when a replica is reached or 0 if 1000ms is reached.\n    \"\"\"\n    args: List[TEncodable] = [str(numreplicas), str(timeout)]\n    return cast(\n        int,\n        await self._execute_command(RequestType.Wait, args),\n    )\n</code></pre>"}]}